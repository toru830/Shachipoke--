<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>シャチポケ！</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="シャチポケ２">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="社畜キャラクター育成シミュレーションゲーム「シャチポケ２」。16種類のユニークなキャラクターを育成し、イベントを完了して、アイテムを購入してキャラクターを育てよう！">
    <meta name="keywords" content="ゲーム,育成シミュレーション,キャラクター育成,モバイルゲーム,無料ゲーム,社畜">
    <meta name="author" content="シャチポケ２">
    
    <!-- Open Graph (Facebook, Twitter等で使用) -->
    <meta property="og:title" content="シャチポケ２ - 社畜キャラクター育成ゲーム">
    <meta property="og:description" content="16種類のユニークなキャラクターを育成するシミュレーションゲーム。Google認証でマルチデバイス対応！">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="シャチポケ２">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="シャチポケ２ - 社畜キャラクター育成ゲーム">
    <meta name="twitter:description" content="16種類のユニークなキャラクターを育成するシミュレーションゲーム">
    
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-NCQSMFEPQL"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-NCQSMFEPQL', { 
        'anonymize_ip': true,
        'page_title': 'シャチポケ２',
        'page_location': window.location.href
      });
    </script>
    
    <!-- Supabase CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        #game-container {
            max-width: 480px;
            margin: 0 auto;
            min-height: 100vh;
            background: #f8f9fa;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 20px;
            padding-bottom: 90px; /* 下部ナビゲーションの高さ分の余白 */
            overflow-y: auto;
            transition: all 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
            opacity: 1;
            transform: translateY(0);
            background: #FDF0F5 !important;
        }

        .screen.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }
        
        .screen.showing {
            animation: slideInFromRight 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes slideOutToLeft {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(-30px);
            }
        }

        #loading-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%);
            color: white;
        }

        .loading-content {
            text-align: center;
        }

        .loading-content h1 {
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @keyframes wiggle {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            25% { transform: translateX(-3px) rotate(-2deg); }
            50% { transform: translateX(0) rotate(0deg); }
            75% { transform: translateX(3px) rotate(2deg); }
        }

        .screen-header {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.5rem;
            padding: 0.75rem;
            background: linear-gradient(135deg, #FFFEF5, #FFF8E1);
            border-radius: 12px;
            border: 2px solid #FFB74D;
            min-height: 45px;
            position: relative;
        }

        .screen-header h1 {
            font-size: 1.35rem;
            color: #495057;
            text-align: center;
            margin: 0;
            font-weight: 700;
        }

        .back-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background 0.3s ease;
        }

        .back-btn:hover {
            background: #5a6268;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 2rem;
        }

        .character-card {
            background: white;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .character-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }

        .character-card.selected {
            border-color: #007bff;
            background: #e3f2fd;
        }

        .character-card .character-icon {
            width: 80px;
            height: 80px;
            background: transparent;
            border-radius: 0;
            margin: 0 auto 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            border: none;
            animation: wiggle 2s ease-in-out infinite;
        }

        .character-card .character-name {
            font-size: 0.8rem;
            font-weight: 700;
            color: #495057;
            margin-bottom: 5px;
        }

        .character-card .character-level {
            font-size: 0.7rem;
            color: #6c757d;
        }

        .character-preview {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .preview-image {
            width: 100px;
            height: 100px;
            background: #f8f9fa;
            border-radius: 50%;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            border: 3px solid #dee2e6;
        }

        .preview-info h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #495057;
        }

        .preview-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .stat-icon {
            font-size: 1.2rem;
        }

        .game-header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            padding: 12px 16px;
            background: linear-gradient(135deg, #FFFEF5, #FFF8E1);
            border-radius: 12px;
            border: 2px solid #FFB74D;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            min-height: 45px;
            position: relative;
        }

        .game-header h1 {
            font-size: 1.8rem;
            color: #495057;
            text-align: center;
            margin: 0;
            font-weight: 700;
        }

        .currency-display {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.78rem;
            font-weight: 700;
            color: #2E7D32;
            background: #E8F5E9;
            border: 2px solid #66BB6A;
            padding: 6px 12px;
            border-radius: 999px;
        }

        .currency-icon {
            font-size: 1.5rem;
        }

        .character-display {
            background: linear-gradient(135deg, #FFFEF5, #FFF8E1);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: visible;
            min-height: 280px;
        }


        .character-sway {
            animation: sway 3s ease-in-out infinite;
        }

        @keyframes sway {
            0%, 100% { transform: translateX(0px); }
            50% { transform: translateX(5px); }
        }
        .rainbow-title {
            background: linear-gradient(90deg, 
                #FF6B6B 0%, 
                #FFE66D 14.28%, 
                #98D982 28.56%, 
                #4ECDC4 42.84%, 
                #45B7D1 57.12%, 
                #9693E4 71.4%, 
                #FF6B9D 85.68%, 
                #FF6B6B 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: rainbow-move 3s linear infinite;
            font-family: 'Comic Sans MS', 'M PLUS Rounded 1c', cursive;
            font-weight: 700;
            letter-spacing: 2px;
        }

        @keyframes rainbow-move {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .character-display {
            background: linear-gradient(135deg, #FFFEF5, #FFF8E1);
            border-radius: 20px;
            padding: 30px;
            text-align: center;
            margin-bottom: 2rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
            overflow: visible;
        }

        .character-container {
            position: relative;
            width: 100%;
            height: 200px;
            margin: 0 auto 20px;
        }

        .character-image {
            width: 188px;
            height: 188px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7.1rem;
            border-radius: 50%;
            z-index: 2;
            background: transparent;
        }

        .character-image img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            background: transparent;
            border-radius: 38px;
            filter: drop-shadow(0 14px 28px rgba(32, 23, 70, 0.18));
            transition: filter 0.25s ease, transform 0.25s ease;
        }

        #main-character-image {
            cursor: pointer;
            position: relative;
            transition: transform 0.25s ease;
        }

        #main-character-image.icon-3d-active {
            width: 244px;
            height: 244px;
        }

        #main-character-image.icon-3d-active img {
            width: 95%;
            height: 95%;
            filter: drop-shadow(0 18px 32px rgba(95, 82, 255, 0.35));
            transform: translateY(-4px);
        }

        #main-character-image .icon-mode-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 0.85rem;
            font-weight: 700;
            padding: 4px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.9);
            color: #5b4a72;
            border: 1px solid rgba(91, 74, 114, 0.3);
            text-transform: uppercase;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }


        .character-roam {
            animation: random-walk 12s linear infinite;
        }

        @keyframes random-walk {
            0% { top: 50%; left: 10%; }
            10% { top: 50%; left: 20%; }
            20% { top: 40%; left: 30%; }
            30% { top: 50%; left: 40%; }
            40% { top: 60%; left: 50%; }
            50% { top: 50%; left: 60%; }
            60% { top: 40%; left: 70%; }
            70% { top: 50%; left: 80%; }
            80% { top: 60%; left: 70%; }
            90% { top: 50%; left: 60%; }
            100% { top: 50%; left: 10%; }
        }

        .character-info h2 {
            font-size: 1.5rem;
            color: #495057;
            margin-bottom: 10px;
        }

        .status-action-card {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            max-width: 260px;
            margin: 0 auto 12px auto;
            gap: 8px;
        }

        .status-chip {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 12px;
            border-radius: 16px;
            border: 1.5px solid rgba(68, 80, 97, 0.2);
            background: #fff;
            color: #2f3444;
            text-align: center;
            min-height: 80px;
            gap: 4px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.05);
        }

        .status-chip .chip-icon {
            font-size: 1.2rem;
        }

        .status-chip .label {
            font-size: 0.9rem;
            letter-spacing: 0.08em;
            opacity: 0.72;
        }

        .status-chip .value {
            font-size: 1.25rem;
            font-weight: 700;
        }
        
        .status-chip.level .label {
            font-size: 1.2rem;
            letter-spacing: 0.12em;
        }
        
        .status-chip.level .value {
            font-size: 1.6rem;
        }

        .rare-items-panel {
            background: linear-gradient(135deg, rgba(255, 247, 253, 0.9), rgba(245, 255, 250, 0.9));
            border: 2px dashed rgba(255, 128, 171, 0.5);
            border-radius: 18px;
            padding: 16px 18px;
            margin: 12px 0 30px;
            box-shadow: 0 12px 30px rgba(255, 192, 203, 0.2);
        }

        .rare-items-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .rare-items-title-row {
            display: flex;
            align-items: baseline;
            gap: 10px;
        }

        .rare-items-title {
            font-size: 1rem;
            font-weight: 800;
            color: #d654a1;
            letter-spacing: 0.08em;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .rare-items-title::before {
            content: '✨';
        }

        .rare-items-count {
            font-size: 0.85rem;
            padding: 2px 10px;
            border-radius: 999px;
            background: rgba(214, 84, 161, 0.12);
            color: #d654a1;
            font-weight: 700;
        }

        .rare-items-tip {
            font-size: 0.75rem;
            color: #888;
        }

        .rare-folder-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            max-width: 400px;
            margin: 0 auto;
        }

        .rare-folder-icon {
            border: none;
            background: transparent;
            border-radius: 0;
            padding: 8px;
            box-shadow: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .rare-folder-icon:hover:not(.disabled) {
            transform: scale(1.05);
        }

        .rare-folder-icon.disabled {
            opacity: 0.5;
            cursor: default;
        }

        .rare-folder-thumbnail {
            width: 140px;
            height: 140px;
            border-radius: 12px;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: #a855f7;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .rare-folder-label {
            font-size: 1.1rem;
            font-weight: 700;
            color: #7740a8;
            text-shadow: 0 1px 2px rgba(255,255,255,0.8);
        }

        /* レスポンシブ対応 */
        @media (max-width: 480px) {
            .rare-folder-grid {
                gap: 15px;
                max-width: 320px;
            }
            
            .rare-folder-thumbnail {
                width: 120px;
                height: 120px;
            }
            
            .rare-folder-label {
                font-size: 1rem;
            }
        }

        .rare-items-empty {
            color: #b36ba0;
            font-size: 0.85rem;
            text-align: center;
        }

        .card-viewer-body {
            display: flex;
            flex-direction: column;
            gap: 18px;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .card-viewer-display {
            perspective: 1200px;
        }

        .card-flip {
            width: 230px;
            height: 330px;
            border-radius: 18px;
            background: linear-gradient(135deg, #ffe7f5, #f4eaff);
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 20px 40px rgba(0,0,0,0.18);
            transform-style: preserve-3d;
        }

        .card-flip img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 14px;
            box-shadow: 0 16px 32px rgba(0,0,0,0.25);
        }

        .card-flip.flipping {
            animation: cardFlip 0.6s ease;
        }

        @keyframes cardFlip {
            0% { transform: rotateY(0deg); opacity: 1; }
            50% { transform: rotateY(90deg); opacity: 0.3; }
            100% { transform: rotateY(0deg); opacity: 1; }
        }

        .card-viewer-info .card-viewer-name {
            font-size: 1.2rem;
            font-weight: 800;
            color: #a02078;
            letter-spacing: 0.05em;
        }

        .card-viewer-info .card-viewer-effect {
            font-size: 0.95rem;
            color: #5f5f5f;
            margin-top: 8px;
            line-height: 1.5;
        }

        .card-viewer-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
        }

        .card-viewer-nav button {
            border: none;
            background: linear-gradient(135deg, #ff94c2, #a77bff);
            color: #fff;
            font-size: 1rem;
            font-weight: 700;
            padding: 10px 20px;
            border-radius: 999px;
            cursor: pointer;
            box-shadow: 0 10px 18px rgba(0,0,0,0.15);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card-viewer-nav button:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 28px rgba(0,0,0,0.18);
        }

        .card-viewer-counter {
            font-size: 0.9rem;
            font-weight: 700;
            color: #666;
        }

        .rare-card-preview {
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
        }

        .rare-card-preview img {
            width: 170px;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.25);
        }

        .status-chip.rank {
            background: linear-gradient(135deg, rgba(255, 214, 237, 0.6), rgba(197, 222, 255, 0.6));
            border-color: rgba(255, 145, 190, 0.5);
            cursor: pointer;
        }

        .status-chip.level {
            background: linear-gradient(135deg, rgba(232, 248, 255, 0.7), rgba(226, 255, 242, 0.7));
            border-color: rgba(120, 200, 220, 0.45);
        }

        .status-chip.action {
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .status-chip.action.switch {
            background: linear-gradient(135deg, rgba(201, 213, 255, 0.9), rgba(216, 193, 255, 0.9));
            color: #4c4f8f;
        }

        .status-chip.action.video {
            background: linear-gradient(135deg, rgba(255, 214, 232, 0.9), rgba(255, 210, 210, 0.9));
            color: #a84c64;
        }

        .status-chip.action:hover {
            transform: translateY(-2px);
            box-shadow: 0 14px 24px rgba(0,0,0,0.12);
        }


        .stats-display {
            background: linear-gradient(135deg, #FFFEF5, #FFF8E1); /* キャラクターと同じ淡い薄い黄色のグラデーション */
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .currency-banner {
            text-align: center;
            margin: 0 0 16px 0;
            padding: 10px;
            background: #E8F5E9;
            border: 2px solid #66BB6A;
            border-radius: 12px;
        }
        .currency-text {
            font-size: 1.1rem;
            font-weight: 700;
            color: #2E7D32;
        }

        .stat-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
            padding: 12px;
            border-radius: 12px;
        }

        .stat-item:nth-child(1) { /* 耐ストレス */
            background: #FFE3E3; /* 淡いピンク */
        }
        .stat-item:nth-child(2) { /* 知識 */
            background: #E6F3FF; /* 淡い水色 */
        }
        .stat-item:nth-child(3) { /* 体力 */
            background: #E6FFE6; /* 淡い緑 */
        }
        .stat-item:nth-child(4) { /* コミュ力 */
            background: #F0E6FF; /* 淡い紫 */
        }

        .stat-item:last-child {
            margin-bottom: 0;
        }

        .stat-icon {
            font-size: 1.5rem;
            width: 30px;
            text-align: center;
        }

        .stat-label {
            font-weight: 700;
            color: #495057;
            min-width: 80px;
        }

        .stat-bar {
            flex: 1;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            background: #28a745;
            border-radius: 10px;
            transition: width 0.8s cubic-bezier(0.4, 0.0, 0.2, 1), background-color 0.3s ease;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-fill.low-tier {
            background: linear-gradient(90deg, #28a745, #20c997);
        }
        
        .stat-fill.mid-tier {
            background: linear-gradient(90deg, #FF6B6B, #FF8787);
        }
        
        .stat-fill.high-tier {
            background: linear-gradient(90deg, #2196F3, #42A5F5);
        }
        
        .stat-fill.ultra-tier {
            background: linear-gradient(90deg, #9C27B0, #BA68C8);
        }
        
        .stat-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
            50% { box-shadow: inset 0 2px 4px rgba(0,0,0,0.2); }
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .stat-value {
            font-weight: 700;
            color: #495057;
            min-width: 30px;
            text-align: right;
        }

        .main-navigation {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            position: fixed !important;
            bottom: 0 !important;
            left: 50% !important;
            transform: translateX(-50%);
            width: 100% !important;
            max-width: 480px;
            padding: 2px 4px;
            background: white !important;
            border-top: 2px solid #FF8E9B;
            box-shadow: 0 -4px 20px rgba(255, 182, 193, 0.2);
            z-index: 9999 !important;
            margin: 0 !important;
            box-sizing: border-box;
        }

        .nav-btn {
            background: white;
            border: none;
            border-radius: 8px;
            padding: 0;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1px;
            font-size: 0.65rem;
            position: relative;
            justify-content: center;
        }

        .nav-icon img {
            width: 70px;
            height: 70px;
            object-fit: contain;
        }

        .nav-btn:hover:not(.active) {
            background: #f8f9fa;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.12);
        }

        .nav-btn.active {
            background: #F8BBD9;
            color: white;
            box-shadow: 0 4px 15px rgba(248, 187, 217, 0.4);
            transform: translateY(-2px);
        }
        
        .nav-btn.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.5), transparent);
            border-radius: 12px 12px 0 0;
        }

        .nav-icon {
            font-size: 1.2rem;
        }

        .nav-btn span:last-child {
            font-weight: 700;
            color: #495057;
            font-size: 0.7rem;
        }

        .nav-btn.active span:last-child {
            color: white;
        }

        /* 習慣トラッカー画面スタイル */
        #habits.screen {
            padding-bottom: 120px;
        }
        
        .habit-tracker-content {
            background: transparent;
            padding: 0;
            margin: 0;
        }
        
        /* 習慣トラッカータイトル */
        #habits .screen-header h1 {
            font-size: 1.35rem;
            font-weight: 700;
            color: #495057;
            margin: 0;
            text-align: center;
        }

        .week-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 0 8px 16px 8px;
            padding: 12px 16px;
            background: #E1F5FE;
            border: 2px solid #B3E5FC;
            border-radius: 15px;
            width: calc(100% - 16px);
            max-width: none;
            box-sizing: border-box;
        }

        .week-nav-btn {
            background: #455A64;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            color: white;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .week-nav-btn:hover {
            background: #333;
        }

        .week-range {
            font-weight: 600;
            color: #495057;
            font-size: 0.95rem;
            flex: 1;
            text-align: center;
            min-width: 150px;
        }
        .habit-tracker-grid {
            margin: 0 8px 16px 8px;
            background: linear-gradient(135deg, #FFF8E1, #FFECB3, #FFE0B2);
            border: 2px solid #FFB74D;
            border-radius: 15px;
            overflow: hidden;
            border-collapse: separate;
            border-spacing: 0;
        }

        .habit-grid-row {
            display: grid;
            grid-template-columns: 60px repeat(7, 33px) 22px 18px;
            gap: 0;
            padding: 0;
            border-bottom: 1px solid #FFB74D;
            align-items: stretch;
        }

        .habit-grid-row > * {
            border-right: 1px solid #FFB74D;
            padding: 8px 12px;
        }

        .habit-grid-row > *:last-child {
            border-right: none;
        }

        .habit-grid-row:nth-child(odd) {
            background: linear-gradient(135deg, #FFF8E1, #FFECB3);
        }

        .habit-grid-row:nth-child(even) {
            background: linear-gradient(135deg, #FFFDE7, #FFF9C4);
        }

        .habit-grid-row.header-row {
            background: #FFF3C4;
            font-weight: 700;
            color: #333333;
            font-size: 0.95rem;
            height: 35px;
        }

        .habit-grid-row.date-row {
            background: linear-gradient(135deg, #FFFDE7, #FFF9C4);
            font-weight: 400;
            font-size: 0.85rem;
            color: #495057;
            height: 35px;
        }

        .habit-grid-row:last-child {
            border-bottom: none;
        }

        .habit-item-name {
            font-weight: 700;
            text-align: center;
            padding: 8px 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 0.95rem;
            min-width: 50px;
            height: 35px;
        }

        .habit-day-header {
            text-align: center;
            padding: 5px;
            font-size: 0.9rem;
            font-weight: 700;
            line-height: 1.2;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 35px;
        }

        .habit-day-header:last-child {
            border-right: none;
        }
        
        .habit-day-header.today {
            background: #4FC3F7 !important;
            color: white !important;
        }
        
        .habit-grid-row .habit-day-header.today {
            background: #4FC3F7 !important;
            color: white !important;
        }
        
        .habit-day-header small {
            font-size: 0.7rem;
            font-weight: 400;
            display: block;
            margin-top: 2px;
        }

        .habit-day-cell {
            text-align: center;
            padding: 8px 5px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 35px;
        }

        .habit-day-cell:last-child {
            border-right: none;
        }

        .habit-day-cell.today-column {
            background: #E3F2FD !important;
        }

        .habit-day-cell:hover {
            background: rgba(255,255,255,0.3);
        }

        .habit-day-cell.checked {
            background: transparent;
        }

        .habit-day-cell input[type="checkbox"] {
            width: 22px;
            height: 22px;
            cursor: pointer;
            accent-color: #4CAF50;
        }

        .habit-week-total,
        .habit-total {
            text-align: center;
            font-weight: 700;
            color: #333;
            font-size: 0.8rem;
            min-width: 30px;
            padding: 8px 2px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .legend-section {
            margin: 0 16px 0 16px;
            padding: 16px;
            background: #E8F5E8;
            border: 2px solid #81C784;
            border-radius: 15px;
        }

        .legend-section h3 {
            margin-bottom: 12px;
            color: #333;
            font-size: 1rem;
            font-weight: 600;
        }

        .legend-items {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .legend-item {
            background: white;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 0.9rem;
            color: #333;
        }

        /* イベント画面スタイル */
        .event-selection {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .main-story-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .event-types {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        @media (max-width: 900px) {
            .event-types { grid-template-columns: repeat(2, 1fr); }
        }
        @media (max-width: 560px) {
            .event-types { grid-template-columns: repeat(2, 1fr); }
        }

        .event-type-card {
            background: linear-gradient(135deg, #E3F2FD, #BBDEFB);
            border: 2px solid #64B5F6;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .event-type-card.boss-type {
            background: linear-gradient(135deg, #FFCDD2, #FF8A80);
            border: 2px solid #F44336;
        }
        
        .event-type-card.boss-type:hover {
            border-color: #D32F2F;
            box-shadow: 0 6px 12px rgba(244, 67, 54, 0.3);
            background: linear-gradient(135deg, #FF8A80, #FF5722);
        }
        
        .event-type-card.customer-type {
            background: linear-gradient(135deg, #FFE0B2, #FFCC02);
            border: 2px solid #FF9800;
        }
        
        .event-type-card.customer-type:hover {
            border-color: #F57C00;
            box-shadow: 0 6px 12px rgba(255, 152, 0, 0.3);
            background: linear-gradient(135deg, #FFCC02, #FF8F00);
        }
        
        .event-type-card.ojou-type {
            background: linear-gradient(135deg, #C8E6C9, #81C784);
            border: 2px solid #4CAF50;
        }
        
        .event-type-card.ojou-type:hover {
            border-color: #388E3C;
            box-shadow: 0 6px 12px rgba(76, 175, 80, 0.3);
            background: linear-gradient(135deg, #81C784, #66BB6A);
        }

        .event-type-card:hover {
            border-color: #42A5F5;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(66, 165, 245, 0.3);
            background: linear-gradient(135deg, #BBDEFB, #90CAF9);
        }
        
        .event-type-card h4 {
            transition: color 0.3s ease;
        }
        
        .event-type-card.boss-type h4 {
            color: #C2185B;
        }
        
        .event-type-card.customer-type h4 {
            color: #E65100;
        }
        
        .event-type-card.system-type {
            background: linear-gradient(135deg, #E1F5FE, #81D4FA);
            border: 2px solid #29B6F6;
        }
        
        .event-type-card.system-type:hover {
            border-color: #0288D1;
            box-shadow: 0 6px 12px rgba(41, 182, 246, 0.3);
            background: linear-gradient(135deg, #81D4FA, #4FC3F7);
        }
        
        .event-type-card.event-type {
            background: linear-gradient(135deg, #F3E5F5, #CE93D8);
            border: 2px solid #AB47BC;
        }
        
        .event-type-card.event-type:hover {
            border-color: #8E24AA;
            box-shadow: 0 6px 12px rgba(171, 71, 188, 0.3);
            background: linear-gradient(135deg, #CE93D8, #BA68C8);
        }
        
        .event-type-card.skill-type {
            background: linear-gradient(135deg, #FFF8E1, #FFE082);
            border: 2px solid #FFC107;
        }
        
        .event-type-card.skill-type:hover {
            border-color: #FF8F00;
            box-shadow: 0 6px 12px rgba(255, 193, 7, 0.3);
            background: linear-gradient(135deg, #FFE082, #FFD54F);
        }
        
        .event-type-card.system-type h4 {
            color: #0277BD;
        }
        
        .event-type-card.event-type h4 {
            color: #6A1B9A;
        }
        
        .event-type-card.skill-type h4 {
            color: #F57C00;
        }
        
        .event-type-card.ojou-type h4 {
            color: #2E7D32;
        }

        .event-type-card.main-story-type {
            background: linear-gradient(135deg, #1A1A2E, #16213E);
            border: 3px solid #FF6B00;
            box-shadow: 0 8px 24px rgba(255, 107, 0, 0.4), inset 0 0 50px rgba(255, 107, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        .event-type-card.main-story-type::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 107, 0, 0.1) 50%, transparent 70%);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .event-type-card.main-story-type:hover {
            border-color: #FF8C00;
            box-shadow: 0 12px 32px rgba(255, 107, 0, 0.6), inset 0 0 80px rgba(255, 107, 0, 0.2);
            transform: translateY(-5px) scale(1.02);
            background: linear-gradient(135deg, #2A2A4A, #223354);
        }

        .event-type-card.main-story-type .event-series {
            color: #FFD700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .event-type-card.main-story-type p {
            color: #FFF;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .event-type-card.completed {
            background: linear-gradient(135deg, #F0F0F0, #E5E5E5); /* completed: muted gray */
            border-color: #CCCCCC;
            opacity: 1;
            cursor: default;
            pointer-events: none;
        }

        .event-type-card.completed:hover {
            transform: none;
            box-shadow: none;
        }

        .event-type-card.completed h4,
        .event-type-card.completed p {
            color: #999;
        }

        .completed-badge {
            background: #6c757d;
            color: white;
            padding: 5px 15px;
            border-radius: 10px;
            font-size: 0.85rem;
            margin-top: 10px;
            display: inline-block;
        }

        .event-series {
            font-size: 1.0rem;
            font-weight: 700;
            margin-bottom: 8px;
        }
        .event-icon {
            font-size: 3rem;
            margin: 6px 0 10px 0;
        }
        .event-type-card h4 { display: none; }

        .event-type-card p {
            color: #666;
            font-size: 0.9rem;
        }

        .event-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .event-choices {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .event-choice-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .event-choice-btn:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .event-complete {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .event-rewards {
            margin: 15px 0;
        }

        .reward-positive {
            color: #28a745;
            font-weight: bold;
        }

        .reward-negative {
            color: #dc3545;
            font-weight: bold;
        }

        /* ショップ画面スタイル */
        .shop-items {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            padding: 20px;
        }

        .shop-item-card {
            background: white;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .shop-item-card.rank-1 {
            background: linear-gradient(135deg, #FFF3E0, #FFE0B2);
            border: 2px solid #FF9800;
        }

        .shop-item-card.rank-2 {
            background: linear-gradient(135deg, #E1F5FE, #B3E5FC);
            border: 2px solid #03A9F4;
        }

        .shop-item-card.rank-3 {
            background: linear-gradient(135deg, #F3E5F5, #E1BEE7);
            border: 2px solid #9C27B0;
        }

        .item-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .item-name {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .item-description {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .item-cost {
            color: #007bff;
            font-weight: bold;
            margin-bottom: 15px;
        }

        /* 編成画面スタイル */
        .party-formation, .owned-characters, .purchasable-characters {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .party-slots {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .party-slot {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot-content {
            width: 100%;
        }

        .slot-content img {
            width: 50px;
            height: 50px;
            object-fit: contain;
            margin-bottom: 5px;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .character-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .character-card:hover {
            border-color: #007bff;
            transform: translateY(-2px);
        }

        .character-card img {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin-bottom: 10px;
        }

        .character-cost {
            color: #007bff;
            font-weight: bold;
            margin: 5px 0;
        }

        /* アチーブメント通知スタイル */
        .achievement-notification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.3s ease;
        }
        
        .achievement-content {
            background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%);
            padding: 40px;
            border-radius: 20px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            color: white;
        }
        
        .achievement-content .achievement-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: bounce 0.6s ease;
        }
        
        .achievement-content h3 {
            font-size: 1.5rem;
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .achievement-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .achievement-description {
            font-size: 1rem;
            margin: 10px 0;
            opacity: 0.9;
        }
        
        .achievement-progress {
            font-size: 0.9rem;
            margin: 15px 0;
            opacity: 0.8;
        }
        
        /* アチーブメント一覧スタイル */
        .achievement-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .achievement-item {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .achievement-item.completed {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }
        
        .achievement-item.completed .achievement-item-name {
            color: #2e7d32;
        }
        
        .achievement-item.completed .achievement-item-description {
            color: #1b5e20;
        }
        
        .achievement-item-icon {
            font-size: 2.5rem;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .achievement-item-info {
            flex-grow: 1;
        }
        
        .achievement-item-name {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }
        
        .achievement-item-description {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }
        
        .achievement-progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        
        .achievement-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            transition: width 0.3s ease;
        }
        
        .achievement-progress-text {
            font-size: 0.85rem;
            color: #666;
        }
        
        .achievement-checkmark {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: #4caf50;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
        }
        
        /* 設定画面スタイル */
        .settings-section {
            background: white;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .save-load-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
        }

        .game-stats p {
            margin: 10px 0;
            font-size: 1.1rem;
        }

        .game-stats span {
            font-weight: bold;
            color: #007bff;
        }

        /* 動画ギャラリースタイル */
        .video-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .video-item h4 {
            color: #333;
            margin-bottom: 15px;
        }

        .video-item video {
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .video-item p {
            color: #666;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        /* トースト通知 */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.error {
            background: #dc3545;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .btn-primary {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            width: 100%;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0, 123, 255, 0.3);
        }

        .btn-primary:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 123, 255, 0.4);
        }
        
        .btn-primary:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 123, 255, 0.3);
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn-primary:active:not(:disabled)::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease;
        }

        .toast.error {
            background: #dc3545;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* 購入成功ダイアログ */
        .purchase-success-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
        }

        .purchase-success-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: scaleIn 0.3s ease;
        }

        .purchase-success-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: bounce 0.5s ease;
        }

        .purchase-success-content h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .stat-changes {
            margin: 30px 0;
        }

        .stat-change-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            background: #f8f9fa;
            animation: slideUp 0.3s ease;
        }

        .stat-change-item.positive {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .stat-change-item.negative {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
        }

        .stat-icon {
            font-size: 1.5rem;
            margin-right: 10px;
        }

        .stat-name {
            flex: 1;
            text-align: left;
            color: #333;
            font-weight: 500;
        }

        .stat-change {
            font-weight: bold;
            font-size: 1.2rem;
        }

        .stat-change-item.positive .stat-change {
            color: #28a745;
        }

        .stat-change-item.negative .stat-change {
            color: #dc3545;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* キャラクター詳細ダイアログ */
        .character-details-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease;
            overflow-y: auto;
        }

        .character-details-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: scaleIn 0.3s ease;
        }

        .character-details-header {
            display: flex;
            align-items: center;
            margin-bottom: 30px;
            gap: 20px;
        }

        .character-details-icon img,
        .character-details-icon div {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: contain;
        }

        .character-details-info h2 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.8rem;
        }

        .character-description {
            color: #666;
            font-size: 0.95rem;
        }

        .character-details-stats {
            margin: 30px 0;
        }

        .character-details-stats h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .stat-item .stat-icon {
            font-size: 1.5rem;
        }
        .stat-item .stat-label {
            flex: 1;
            color: #333;
            font-weight: 500;
        }

        .stat-item .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #007bff;
        }

        .character-details-purchases {
            margin: 30px 0;
        }

        .character-details-purchases h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .purchase-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .purchase-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .purchase-icon {
            font-size: 1.5rem;
        }

        .purchase-name {
            flex: 1;
            color: #333;
            font-weight: 500;
        }

        .purchase-date {
            color: #666;
            font-size: 0.9rem;
        }

        .character-card-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn-detail,
        .btn-add {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .btn-detail {
            background: #6c757d;
            color: white;
        }

        .btn-detail:hover {
            background: #5a6268;
        }

        .btn-add {
            background: #28a745;
            color: white;
        }

        .btn-add:hover {
            background: #218838;
        }

        /* レベルアップ演出ダイアログ */
        .level-up-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            animation: fadeIn 0.5s ease;
        }

        .level-up-content {
            background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%);
            padding: 50px 40px;
            border-radius: 25px;
            text-align: center;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
            animation: scaleIn 0.5s ease;
            max-width: 400px;
            width: 90%;
        }

        .level-up-icon {
            font-size: 5rem;
            margin-bottom: 20px;
            animation: bounce 1s ease infinite;
        }

        .level-up-content h2 {
            color: white;
            font-size: 2rem;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .level-up-animation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .old-level,
        .new-level {
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .old-level {
            animation: fadeOut 0.5s ease;
        }

        .new-level {
            animation: fadeIn 0.5s ease;
            font-size: 3rem;
            color: #ffd700;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
        }

        .arrow {
            font-size: 3rem;
            color: white;
        }

        .level-up-message {
            color: white;
            font-size: 1.2rem;
            margin: 20px 0;
        }

        /* タブレット対応 (481px - 1024px) */
        @media (min-width: 481px) and (max-width: 1024px) {
            #game-container {
                max-width: 600px;
            }
            
            .screen {
                padding: 25px;
                padding-bottom: 100px;
            }
            
            .character-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 20px;
            }
            
            .screen-header h1 {
                font-size: 1.35rem;
                text-align: center;
                margin: 0;
                font-weight: 700;
            }
            
            .character-card .character-icon {
                width: 100px;
                height: 100px;
                font-size: 3rem;
            }
            
            .btn-primary {
                padding: 15px 30px;
                font-size: 1.1rem;
            }
        }
        
        /* 大画面対応 (1025px+) */
        @media (min-width: 1025px) {
            #game-container {
                max-width: 800px;
            }
            
            .screen {
                padding: 30px;
                padding-bottom: 110px;
            }
            
            .character-grid {
                grid-template-columns: repeat(5, 1fr);
                gap: 25px;
            }
            
            .screen-header h1 {
                font-size: 1.35rem;
                text-align: center;
                margin: 0;
                font-weight: 700;
            }
            
            .character-card .character-icon {
                width: 120px;
                height: 120px;
                font-size: 3.5rem;
            }
            
            .main-navigation {
                padding: 20px 15px;
                gap: 15px;
            }
            
            .nav-icon {
                font-size: 1.5rem;
            }
            
            .nav-btn span {
                font-size: 1rem;
            }
            
            .btn-primary {
                padding: 18px 40px;
                font-size: 1.2rem;
            }
            
            /* PC版 習慣トラッカー列幅設定
             * 項目: 120px
             * 曜日（月〜日）: 各70px（合計7列 = 490px）
             * 週: 50px
             * 計: 50px
             * 合計: 120 + 490 + 50 + 50 = 710px
             */
            .habit-grid-row {
                grid-template-columns: 120px repeat(7, 70px) 50px 50px;
            }
        }
        
        /* モバイル対応 (480px以下) */
        @media (max-width: 480px) {
            .screen {
                padding: 15px;
                padding-bottom: 90px;
            }
            
            .character-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
            }
            
            .main-navigation {
                padding: 10px 5px;
            }
            
            .shop-items {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 10px;
            }
            
            .event-types {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            /* 習慣トラッカーのスマホ対応 */
            .habit-tracker-grid {
                margin: 0 4px 16px 4px;
                overflow: hidden;
            }
            
            /* スマホ版 習慣トラッカー列幅設定（メモ）
             * 項目: 40px
             * 曜日（月〜日）: 各33px（合計7列）
             * 週: 22px
             * 計: 22px
             * 合計: 40 + 231 + 22 + 22 = 315px
             */
            .habit-grid-row {
                grid-template-columns: 40px repeat(7, 33px) 22px 22px;
            }
            
            .habit-item-name {
                font-size: 0.75rem;
                padding: 4px 2px;
                min-width: 35px;
            }
            
            .habit-day-header,
            .habit-day-cell {
                font-size: 0.7rem;
                padding: 4px 2px;
            }
            
            .habit-week-total,
            .habit-total {
                font-size: 0.65rem;
                padding: 4px 2px;
            }
            
            .legend-section {
                margin: 0 8px 16px 8px;
            }
            
            .legend-items {
                flex-wrap: wrap;
                gap: 8px;
                font-size: 0.8rem;
            }
        }
        /* 横向き対応 */
        @media (orientation: landscape) and (max-height: 600px) {
            .screen {
                padding: 10px;
                padding-bottom: 70px;
            }
            
            .screen-header {
                margin-bottom: 1rem;
            }
            
            .screen-header h1 {
                font-size: 1.35rem;
                text-align: center;
                margin: 0;
                font-weight: 700;
            }
            
            .character-card .character-icon {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
            
            .main-navigation {
                padding: 8px 5px;
            }
            
            .nav-icon {
                font-size: 1rem;
            }
            
            .nav-btn span {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Loading Screen -->
        <div id="loading-screen" class="screen">
            <div class="loading-content">
                <h1 class="rainbow-title">シャチポケ！</h1>
                <div class="loading-spinner"></div>
                <p>読み込み中...</p>
            </div>
        </div>

        <!-- Login Required Screen -->
        <div id="login-required" class="screen">
            <div class="screen-header">
                <h1 class="rainbow-title">シャチポケ！</h1>
                <p>ゲームを開始するにはGoogle認証が必要です</p>
            </div>
            <div style="text-align: center; padding: 40px 20px;">
                <div style="background: #f8f9fa; padding: 30px; border-radius: 10px; margin: 20px 0;">
                    <h2 style="color: #333; margin-bottom: 20px;">🔐 認証が必要です</h2>
                    <p style="color: #666; margin-bottom: 30px;">
                        ゲームデータを安全に保存し、複数のデバイスで同期するために<br>
                        Googleアカウントでのログインが必要です
                    </p>
                    <button onclick="signInWithGoogle()" 
                            aria-label="Googleアカウントでログイン"
                            style="padding: 15px 30px; background: #4285f4; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold;">
                        Googleでログイン
                    </button>
                </div>
                <div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p style="color: #856404; margin: 0; font-size: 14px;">
                        💡 ログイン後は、ゲームデータが自動的にクラウドに保存され、<br>
                        他のデバイスからも同じデータでゲームを続けることができます
                    </p>
                </div>
            </div>
        </div>

        <!-- Character Selection Screen -->
        <div id="character-selection" class="screen hidden">
            <div class="character-grid" id="character-grid">
                <!-- Characters will be populated by JavaScript -->
            </div>
            <div class="character-preview" id="character-preview">
                <div class="preview-image"></div>
                <div class="preview-info">
                    <h3 id="preview-name">キャラクター名</h3>
                    <div class="preview-stats">
                        <div class="stat-item">
                            <span class="stat-icon">😤</span>
                            <span>耐ストレス: <span id="preview-stress">0</span></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-icon">🧠</span>
                            <span>知識: <span id="preview-knowledge">0</span></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-icon">💪</span>
                            <span>体力: <span id="preview-physical">0</span></span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-icon">💬</span>
                            <span>コミュ力: <span id="preview-communication">0</span></span>
                        </div>
                    </div>
                </div>
            </div>
            <button id="confirm-character" class="btn-primary" disabled>選択確定</button>
        </div>

        <!-- Main Game Screen -->
        <div id="main" class="screen hidden">
            <!-- Header -->
            <div class="game-header">
                <h1 class="rainbow-title">シャチポケ！</h1>
            </div>

            <!-- Character Display -->
            <div class="character-display">
                <div class="character-container">
                    <div class="character-image character-roam" id="main-character-image">
                        <div class="character-sway"></div>
                    </div>
                </div>
                <div class="character-info">
                    <h2 id="character-name">キャラクター名</h2>
                    <div class="status-action-card">
                        <button id="rank-info-button" type="button" class="status-chip rank">
                            <span class="chip-icon">🏅</span>
                            <span id="character-rank-name" class="value">平社員</span>
                        </button>
                        <div class="status-chip level">
                            <span class="label">LEVEL</span>
                            <span id="character-level" class="value">1</span>
                    </div>
                        <button onclick="showCharacterSwitch()" class="status-chip action switch" type="button">
                            <span class="chip-icon">🔄</span>
                            <span class="value">Change</span>
                        </button>
                        <button onclick="playCurrentCharacterMovie()" class="status-chip action video" type="button">
                            <span class="chip-icon">🎥</span>
                            <span class="value">Movie</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Currency Display -->
            <div class="currency-banner" style="display: flex; justify-content: space-between; align-items: center; position: relative;">
                <span class="currency-text" style="position: absolute; left: 50%; transform: translateX(-50%);">保有：<span id="currency-amount">0</span>シャチ</span>
                <button onclick="showScreen('shachi-history')" style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer; margin-left: auto;">履歴</button>
            </div>
            <div class="rare-items-panel">
                <div class="rare-folder-grid">
                    <button class="rare-folder-icon" type="button" onclick="openCardFolder()">
                        <div class="rare-folder-thumbnail">
                            <img src="30_差し込み画像/Card File.png" alt="Card File" style="width: 100%; height: 100%; object-fit: cover; border-radius: 12px;">
                        </div>
                        <div class="rare-folder-label">Card File</div>
                    </button>
                    <button class="rare-folder-icon" type="button" onclick="openRareBox()">
                        <div class="rare-folder-thumbnail">
                            <img src="30_差し込み画像/Rare Box.png" alt="Rare Box" style="width: 100%; height: 100%; object-fit: cover; border-radius: 12px;">
                        </div>
                        <div class="rare-folder-label">Rare Box</div>
                    </button>
                </div>
            </div>

            <!-- Stats Display -->
            <div class="stats-display">
                <div class="stat-item">
                    <span class="stat-icon">😤</span>
                    <span class="stat-label">耐ストレス</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="stress-bar"></div>
                    </div>
                    <span class="stat-value" id="stress-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">🧠</span>
                    <span class="stat-label">知識</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="knowledge-bar"></div>
                    </div>
                    <span class="stat-value" id="knowledge-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">💪</span>
                    <span class="stat-label">体力</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="physical-bar"></div>
                    </div>
                    <span class="stat-value" id="physical-value">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">💬</span>
                    <span class="stat-label">コミュ力</span>
                    <div class="stat-bar">
                        <div class="stat-fill" id="communication-bar"></div>
                    </div>
                    <span class="stat-value" id="communication-value">0</span>
                </div>
            </div>
        </div>

        <!-- Events Screen -->
        <div id="events" class="screen hidden">
            <div class="screen-header">
                <h1>イベント</h1>
            </div>
            <div class="events-content" id="events-content">
                <!-- イベント選択画面 -->
                <div class="event-selection" id="event-selection">
                    <h3>今日のイベントを選択してください</h3>
                    <!-- メインストーリー専用エリア -->
                    <div class="main-story-container" id="main-story-container" style="margin-bottom: 30px;">
                        <!-- メインストーリーはここに表示 -->
                    </div>
                    <!-- 通常イベントエリア -->
                    <div class="event-types" id="event-types">
                        <!-- イベントカードは JavaScript で動的に生成 -->
                    </div>
                </div>
                
                <!-- イベント詳細画面 -->
                <div class="event-card" id="current-event" style="display: none;">
                    <h3 id="event-title"></h3>
                    <p id="event-description"></p>
                    <div class="event-choices" id="event-choices"></div>
                </div>
                <div class="event-complete" id="event-complete" style="display: none;">
                    <h3>イベント完了！</h3>
                    <p id="event-feedback"></p>
                    <div class="event-rewards" id="event-rewards"></div>
                    <button class="btn-primary" onclick="nextEvent()">イベント選択に戻る</button>
                </div>
                <div class="no-events" id="no-events" style="display: none;">
                    <h3>今日のイベントは終了しました</h3>
                    <p>明日また新しいイベントが発生します！</p>
                    <button class="btn-primary" onclick="showScreen('main')">ホームに戻る</button>
                </div>
            </div>
        </div>

        <!-- Shop Screen -->
        <div id="shop" class="screen hidden">
            <div class="screen-header">
                <h1>ショップ</h1>
            </div>
            <div class="shop-content">
                <div class="shop-currency-info" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding: 0.5rem; background: #E8F5E9; border-radius: 8px; border: 2px solid #66BB6A; position: relative;">
                    <span style="position: absolute; left: 50%; transform: translateX(-50%); font-size: 1rem; font-weight: 700; color: #2E7D32;">保有：<span id="shop-currency-amount">0</span>シャチ</span>
                    <button onclick="showScreen('shachi-history')" style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 8px; font-size: 0.85rem; font-weight: 600; cursor: pointer; margin-left: auto;">履歴</button>
                </div>
                <div class="gacha-section" style="background: linear-gradient(135deg, #FFD700, #FFA500); border-radius: 15px; padding: 20px; margin-bottom: 20px; box-shadow: 0 8px 16px rgba(0,0,0,0.2);">
                    <div style="text-align: center; margin-bottom: 15px;">
                        <img src="30_差し込み画像/Gacha_Top01.png" alt="ガチャトップ画像" style="max-width: 100%; height: auto; border-radius: 10px;">
                    </div>
                    <h2 style="text-align: center; font-size: 1.5rem; margin-bottom: 15px; color: #FFF; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                        🎰 ガチャガチャ 🎰
                    </h2>
                    <div style="text-align: center; margin-top: 15px;">
                        <button id="gacha-button" class="gacha-btn" onclick="drawGacha()" style="font-size: 1.2rem; padding: 15px 30px; background: #FF1744; color: white; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.3); display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto;">
                            <span id="gacha-btn-text" style="text-align: center; line-height: 1.5;">
                                💎ガチャを引く💎<br>
                                <span id="gacha-cost-text">(無料)</span>
                            </span>
                        </button>
                    </div>
                </div>
                <div class="shop-items" id="shop-items">
                    <!-- ショップアイテムがここに動的に生成されます -->
                </div>
                <!-- 社畜を解放するセクション -->
                <div class="character-liberation-section" id="character-liberation-section" style="margin-top: 30px;">
                    <h2 style="text-align: center; font-size: 1.5rem; margin-bottom: 20px; color: #333;">🏥 社畜を解放する</h2>
                    <div class="liberation-characters" id="liberation-characters">
                        <!-- 購入可能なキャラクターがここに表示されます -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Formation Screen -->
        <div id="formation" class="screen hidden">
            <div class="screen-header">
                <h1>編成</h1>
            </div>
            <div class="formation-content">
                <div class="party-formation">
                    <h3>パーティー編成</h3>
                    <div class="party-slots" id="party-slots">
                        <!-- パーティースロットがここに生成されます -->
                    </div>
                </div>
                
                <div class="owned-characters">
                    <h3>所有キャラクター</h3>
                    <div class="character-grid" id="owned-characters">
                        <!-- 所有キャラクターがここに生成されます -->
                    </div>
                </div>
                
                <div class="purchasable-characters">
                    <h3>購入可能キャラクター</h3>
                    <div class="character-grid" id="purchasable-characters">
                        <!-- 購入可能キャラクターがここに生成されます -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Habits Screen -->
        <div id="habits" class="screen hidden">
            <div class="screen-header">
                <h1>習慣トラッカー</h1>
            </div>
            <div class="habit-tracker-content">
                <div class="week-navigation">
                    <button class="week-nav-btn" onclick="changeWeek(-1)">← 前週</button>
                    <span class="week-range" id="week-range">10/27 - 11/2</span>
                    <button class="week-nav-btn" onclick="changeWeek(1)">次週 →</button>
                </div>
                <div class="habit-tracker-grid" id="habit-tracker-grid">
                    <!-- 習慣トラッカーグリッドがここに生成されます -->
                </div>
                <div class="legend-section">
                    <h3>詳細</h3>
                    <div class="legend-items" id="legend-items">
                        <!-- 詳細がここに生成されます -->
                    </div>
                </div>
            </div>
        </div>
        <!-- Shachi History Screen -->
        <div id="shachi-history" class="screen hidden">
            <div class="screen-header" style="position: relative;">
                <h1 style="margin: 0;">シャチ履歴</h1>
                <button onclick="showScreen('main')" style="position: absolute; right: 10px; background: #666; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">戻る</button>
            </div>
            <div class="screen-content" style="padding: 20px;">
                <div id="shachi-history-list" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                    <!-- 履歴がここに表示されます -->
                </div>
            </div>
        </div>
        <!-- Rank List Screen -->
        <div id="rank-list" class="screen hidden">
            <div class="screen-header" style="position: relative;">
                <h1 style="margin: 0;">役職一覧</h1>
                <button onclick="showScreen('settings')" style="position: absolute; right: 10px; background: #666; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">戻る</button>
            </div>
            <div class="screen-content" style="padding: 20px;">
                <div id="rank-list-content" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                    <!-- 役職一覧がここに表示されます -->
                </div>
            </div>
        </div>
        <!-- Settings Screen -->
        <div id="settings" class="screen hidden">
            <div class="screen-header">
                <h1>設定</h1>
            </div>
            <div class="settings-content">
                <div class="settings-section">
                    <h3>セーブ・ロード</h3>
                    <div class="save-load-buttons">
                        <button class="btn-primary" onclick="saveGame()">ゲームをセーブ</button>
                        <button class="btn-secondary" onclick="loadGame()">ゲームをロード</button>
                        <button class="btn-danger" onclick="resetGame()">ゲームをリセット</button>
                    </div>
                    
                    <!-- 認証状態表示（設定画面） -->
                    <div id="settings-auth-status" style="margin-top: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px; border: 1px solid #dee2e6;">
                        <div id="settings-auth-info" style="display: none;">
                            <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #2e7d32;">
                                <strong>ログイン中:</strong> <span id="settings-user-email"></span>
                            </p>
                            <button onclick="signOut()" style="padding: 5px 10px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8rem;">ログアウト</button>
                        </div>
                        <div id="settings-login-prompt" style="display: none;">
                            <p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; color: #666;">
                                ゲームデータをクラウドに保存するにはログインしてください
                            </p>
                            <button onclick="signInWithGoogle()" style="padding: 8px 15px; background: #4285f4; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9rem;">Googleでログイン</button>
                        </div>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>ゲーム統計</h3>
                    <div class="game-stats" id="game-stats">
                        <p>プレイ日数: <span id="total-days">0</span>日</p>
                        <p>獲得シャチ: <span id="total-shachi">0</span>シャチ</p>
                        <p>完了イベント: <span id="total-events">0</span>個</p>
                        <p>所有キャラクター: <span id="owned-count">0</span>体</p>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>役職一覧</h3>
                    <button class="btn-primary" onclick="showScreen('rank-list')" style="width: 100%; margin-bottom: 10px;">役職一覧を見る</button>
                </div>
                
                <div class="settings-section" id="test-mode-section">
                    <h3>テストモード</h3>
                    <p class="settings-description">完了済み判定を無視し、全イベントを選択可能にします。DB保存を行いません。</p>
                    <div class="save-load-buttons">
                        <label style="display:flex;align-items:center;gap:8px;">
                            <input type="checkbox" id="toggle-test-mode" onchange="toggleTestMode()" /> 有効化（再読み込み不要）
                        </label>
                        <button class="btn-secondary" onclick="enableTestModeOnce()">今だけ有効化（次回起動で無効）</button>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>セキュリティ監査</h3>
                    <div class="save-load-buttons">
                        <button class="btn btn-secondary" onclick="performSecurityAudit()">
                            🔍 セキュリティ監査実行
                        </button>
                        <button class="btn btn-secondary" onclick="checkAndFixRLS()">
                            🛡️ RLS設定確認
                        </button>
                    </div>
                    <p class="settings-description">
                        データベースのセキュリティ設定を確認し、問題があれば修正手順を表示します。
                    </p>
                </div>
                
                <div class="settings-section">
                    <h3>バッチ</h3>
                    <div class="badge-grid" id="badge-grid">
                        <!-- バッチ一覧は動的に生成されます -->
                    </div>
                    <div class="completed-badges-section" id="completed-badges-section" style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #ddd;">
                        <h4 style="margin-bottom: 15px;">獲得済みバッチ</h4>
                        <div class="completed-badges-grid" id="completed-badges-grid">
                            <!-- 獲得済みバッチがここに表示されます -->
                        </div>
                    </div>
                    <button class="btn-secondary" onclick="renderBadges()" style="margin-top: 15px;">バッチを更新</button>
                </div>
                
                <div class="settings-section">
                    <h3>キャラクター一覧</h3>
                    <p class="settings-description">全16種類のキャラクターを確認できます。</p>
                    <div class="save-load-buttons">
                        <a href="characters.html" class="btn btn-primary" style="display: inline-block; text-decoration: none; color: white;">
                            📋 キャラクター一覧を見る
                        </a>
                    </div>
                </div>

                <div class="settings-section">
                    <h3>3Dキャラクター</h3>
                    <p class="settings-description">3Dキャラクターとムービーを確認できます。</p>
                    <div class="save-load-buttons">
                        <button class="btn btn-primary" onclick="showScreen('3d-characters')">
                            🎬 3Dキャラへ
                        </button>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h3>動画ギャラリー</h3>
                    <div class="video-gallery" id="video-gallery">
                        <div class="video-item">
                            <h4>イントロ動画</h4>
                            <video controls width="100%" style="max-width: 300px;">
                                <source src="20_movie/intro01.mp4" type="video/mp4">
                                お使いのブラウザは動画をサポートしていません。
                            </video>
                            <p>ゲームのイントロダクション動画</p>
                        </div>
                        </div>
                    </div>
                    
                <div class="settings-section">
                    <h3>キャラ専用動画</h3>
                    <p class="settings-description">現在選択しているキャラクターの特別動画を確認できます。</p>
                    <div id="current-character-movie" style="text-align: center; padding: 20px;">
                        <!-- 現在のキャラクターの動画がここに表示されます -->
                    </div>
                </div>

                <div class="settings-section">
                    <h3>法的文書</h3>
                    <p class="settings-description">サービスの利用に関する重要な情報をご確認ください。</p>
                    <div class="save-load-buttons" style="display: flex; flex-direction: column; gap: 10px;">
                        <a href="privacy-policy.html" class="btn btn-secondary" style="display: inline-block; text-decoration: none; color: white; text-align: center;">
                            🔒 プライバシーポリシー
                        </a>
                        <a href="terms-of-service.html" class="btn btn-secondary" style="display: inline-block; text-decoration: none; color: white; text-align: center;">
                            📜 利用規約
                        </a>
                        <a href="commercial-transactions.html" class="btn btn-secondary" style="display: inline-block; text-decoration: none; color: white; text-align: center;">
                            📋 特定商取引法に基づく表記
                        </a>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3Dキャラクター画面 -->
        <div id="3d-characters" class="screen hidden">
            <div class="screen-header">
                <button class="back-btn" onclick="showScreen('settings')">← 戻る</button>
                <h1>3Dキャラクター</h1>
            </div>
            <div class="settings-content">
                <div id="3d-video-gallery" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; padding: 20px;">
                    <!-- 3Dキャラクターアイコンとムービーがここに表示されます -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Supabase設定
        const SUPABASE_URL = 'https://uvrzanksalwjnxoreijl.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV2cnphbmtzYWx3am54b3JlaWpsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE0Mjg2MzcsImV4cCI6MjA3NzAwNDYzN30.ShwFpsm64P8IwWlLFM4BcbbWf9Ar8tLXUev3ZgAjQDM';
        
        // Supabaseクライアント初期化
        let supabase = null;
        let useLocalMode = false; // 認証必須のため、常にfalse（ローカルモードは無効化）
        // テストモード（完了制限やグレーアウトを無効化）
        let TEST_MODE = false;

        // Rare Box表示機能（早期定義）
        function openRareBox() {
            console.log('openRareBox called');
            console.log('Current window.gameState:', window.gameState);
            console.log('Current global gameState:', typeof gameState !== 'undefined' ? gameState : 'undefined');
            
            // グローバルgameStateとwindow.gameStateの両方をチェック
            let currentGameState = window.gameState || (typeof gameState !== 'undefined' ? gameState : null);
            
            if (!currentGameState || !currentGameState.rareItemsInventory) {
                console.log('gameState not ready, initializing empty array');
                if (!currentGameState) {
                    currentGameState = {};
                    if (typeof gameState !== 'undefined') gameState = currentGameState;
                    window.gameState = currentGameState;
                }
                if (!currentGameState.rareItemsInventory) currentGameState.rareItemsInventory = [];
            }
            
            const rareItems = currentGameState.rareItemsInventory || [];
            console.log('rareItems to display:', rareItems);
            console.log('rareItems length:', rareItems.length);
            console.log('Full gameState for debugging:', JSON.stringify(currentGameState, null, 2));
            
            const dialog = document.createElement('div');
            dialog.className = 'rare-box-modal';
            
            let itemsHtml = '';
            
            // 16種類全部のレアアイテムを表示（カードファイルと同じ形式）
            const allRareItems = window.RARE_ITEMS || RARE_ITEMS || [];
            
            allRareItems.forEach(itemData => {
                // 所持しているかチェック
                const ownedItem = rareItems.find(owned => owned.id === itemData.id);
                const isOwned = ownedItem !== undefined;
                const count = ownedItem ? (ownedItem.count || 1) : 0;
                
                const rarityClass = `rarity-${itemData.rarity}`;
                const ownedClass = isOwned ? 'owned' : 'not-owned';
                
                itemsHtml += `
                    <div class="rare-item-card ${rarityClass} ${ownedClass}" data-item-index="${itemData.id - 1}" data-item-id="${itemData.id}" ${isOwned ? 'style="cursor: pointer;"' : ''}>
                        <div class="rare-item-rarity-badge">${itemData.rarity.toUpperCase()}</div>
                        <div class="rare-item-image-large">
                            ${isOwned 
                                ? `<img src="${itemData.icon}" alt="${itemData.name}">`
                                : `<div class="no-image-placeholder-large">No Image</div>`
                            }
                        </div>
                        <div class="rare-item-info">
                            <div class="rare-item-name">${itemData.name}</div>
                            ${!isOwned ? `<div class="rare-item-status">未取得</div>` : ''}
                        </div>
                    </div>
                `;
            });
            
            dialog.innerHTML = `
                <div class="rare-box-content">
                    <div class="rare-box-header">
                        <h2>Rare Box</h2>
                        <button class="close-btn" onclick="this.closest('.rare-box-modal').remove()">×</button>
                    </div>
                    <div class="rare-items-grid">
                        ${itemsHtml}
                    </div>
                    <div class="rare-box-footer">
                        <button class="btn-secondary" onclick="this.closest('.rare-box-modal').remove()">閉じる</button>
                    </div>
                </div>
            `;
            
            // スタイルを追加
            if (!document.getElementById('rare-box-styles')) {
                const style = document.createElement('style');
                style.id = 'rare-box-styles';
                style.textContent = `
                    .rare-box-modal {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                        padding: 20px;
                        box-sizing: border-box;
                    }
                    .rare-box-content {
                        background: white;
                        border-radius: 20px;
                        max-width: 700px;
                        width: 95%;
                        max-height: 85vh;
                        overflow-y: auto;
                        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                    }
                    .rare-box-header {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 20px;
                        border-bottom: 2px solid #f0f0f0;
                    }
                    .rare-box-header h2 {
                        margin: 0;
                        color: #333;
                    }
                    .close-btn {
                        background: none;
                        border: none;
                        font-size: 24px;
                        cursor: pointer;
                        color: #666;
                    }
                    .rare-items-grid {
                        display: grid;
                        grid-template-columns: repeat(2, 1fr);
                        gap: 15px;
                        padding: 15px;
                        width: 100%;
                    }
                    .rare-item-card {
                        border: 2px solid;
                        border-radius: 16px;
                        padding: 15px;
                        text-align: center;
                        position: relative;
                        overflow: hidden;
                        transition: transform 0.2s ease;
                        min-height: 300px;
                        display: flex;
                        flex-direction: column;
                        justify-content: space-between;
                    }
                    .rare-item-card.owned:hover {
                        transform: scale(1.02);
                    }
                    .rarity-common { border-color: #9e9e9e; background: linear-gradient(135deg, #f5f5f5, #e0e0e0); }
                    .rarity-rare { border-color: #2196f3; background: linear-gradient(135deg, #e3f2fd, #bbdefb); }
                    .rarity-epic { border-color: #9c27b0; background: linear-gradient(135deg, #f3e5f5, #e1bee7); }
                    .rarity-legendary { border-color: #ff9800; background: linear-gradient(135deg, #fff3e0, #ffcc02); }
                    
                    .rarity-common .rare-item-rarity-badge { background: #9e9e9e; color: white; }
                    .rarity-rare .rare-item-rarity-badge { background: #2196f3; color: white; }
                    .rarity-epic .rare-item-rarity-badge { background: #9c27b0; color: white; }
                    .rarity-legendary .rare-item-rarity-badge { background: #ff9800; color: white; }
                    .rare-item-image-large img {
                        width: 100%;
                        height: 220px;
                        object-fit: contain;
                        margin: 5px auto 10px;
                        display: block;
                    }
                    .no-image-placeholder-large {
                        width: 100%;
                        height: 220px;
                        background: #f0f0f0;
                        border: 2px dashed #ccc;
                        border-radius: 12px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 1rem;
                        color: #999;
                        margin: 5px auto 10px;
                    }
                    .rare-item-rarity-badge {
                        position: absolute;
                        top: 8px;
                        left: 8px;
                        padding: 4px 8px;
                        border-radius: 6px;
                        font-size: 0.7rem;
                        font-weight: bold;
                        text-transform: uppercase;
                        letter-spacing: 0.5px;
                    }
                    .rare-item-card.not-owned {
                        opacity: 0.5;
                        filter: grayscale(100%);
                    }
                    .rare-item-card.not-owned .rare-item-name {
                        color: #999;
                    }
                    .rare-item-card.not-owned .rare-item-count {
                        color: #999;
                        font-style: italic;
                    }
                    .rare-item-name {
                        font-weight: bold;
                        font-size: 1rem;
                        margin-bottom: 8px;
                        line-height: 1.3;
                    }
                    .rare-item-status {
                        font-size: 0.8rem;
                        color: #999;
                        font-style: italic;
                    }
                    .no-rare-items {
                        text-align: center;
                        color: #666;
                        font-size: 1.1rem;
                        padding: 40px;
                    }
                    .rare-box-footer {
                        display: flex;
                        gap: 10px;
                        padding: 20px;
                        border-top: 2px solid #f0f0f0;
                        justify-content: center;
                    }
                    @media (max-width: 400px) {
                        .rare-items-grid {
                            grid-template-columns: 1fr;
                            gap: 10px;
                            padding: 10px;
                        }
                        .rare-item-card {
                            min-height: 250px;
                            padding: 10px;
                        }
                        .rare-item-image-large img, .no-image-placeholder-large {
                            width: 100%;
                            height: 180px;
                        }
                        .rare-box-footer {
                            flex-direction: column;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(dialog);
            
            // レアアイテムをクリックで拡大表示（所持しているアイテムのみ）
            const rareItemCards = dialog.querySelectorAll('.rare-item-card.owned');
            rareItemCards.forEach(item => {
                item.addEventListener('click', () => {
                    const itemIndex = parseInt(item.dataset.itemIndex);
                    const itemId = parseInt(item.dataset.itemId);
                    const allItems = window.RARE_ITEMS || RARE_ITEMS || [];
                    const currentItem = allItems[itemIndex];
                    
                    if (!currentItem) return;

                    // 拡大表示用のオーバーレイ
                    const zoomOverlay = document.createElement('div');
                    zoomOverlay.style.cssText = `
                        position: fixed;
                        inset: 0;
                        background: rgba(0,0,0,0.95);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10006;
                        padding: 20px;
                        touch-action: pan-y;
                    `;

                    const zoomContainer = document.createElement('div');
                    zoomContainer.style.cssText = `
                        position: relative;
                        max-width: 90vw;
                        max-height: 90vh;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 16px;
                        width: 100%;
                    `;

                    const zoomImage = document.createElement('img');
                    zoomImage.src = currentItem.icon;
                    zoomImage.alt = currentItem.name;
                    zoomImage.style.cssText = `
                        width: auto;
                        height: auto;
                        max-width: 100%;
                        max-height: 70vh;
                        border-radius: 16px;
                        box-shadow: 0 20px 40px rgba(0,0,0,0.5);
                        user-select: none;
                        -webkit-user-drag: none;
                    `;

                    const zoomName = document.createElement('div');
                    zoomName.textContent = currentItem.name;
                    zoomName.style.cssText = `
                        color: #fff;
                        font-size: 1.3rem;
                        font-weight: 700;
                        text-align: center;
                    `;

                    // 左右の矢印ボタン
                    const prevButton = document.createElement('button');
                    prevButton.setAttribute('aria-label', '前のアイテム');
                    prevButton.style.cssText = `
                        position: absolute;
                        left: 0;
                        top: 10%;
                        bottom: 10%;
                        width: 25%;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        z-index: 10;
                        opacity: 0;
                    `;

                    const nextButton = document.createElement('button');
                    nextButton.setAttribute('aria-label', '次のアイテム');
                    nextButton.style.cssText = `
                        position: absolute;
                        right: 0;
                        top: 10%;
                        bottom: 10%;
                        width: 25%;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        z-index: 10;
                        opacity: 0;
                    `;

                    let currentZoomIndex = itemIndex;
                    const updateZoomItem = () => {
                        const item = allItems[currentZoomIndex];
                        if (item) {
                            // 所持しているかチェック
                            const ownedItem = rareItems.find(owned => owned.id === item.id);
                            if (ownedItem) {
                                zoomImage.src = item.icon;
                                zoomImage.alt = item.name;
                                zoomName.textContent = item.name;
                                
                                // 前の所持アイテムがあるかチェック
                                let hasPrev = false;
                                for (let i = currentZoomIndex - 1; i >= 0; i--) {
                                    if (rareItems.find(owned => owned.id === allItems[i].id)) {
                                        hasPrev = true;
                                        break;
                                    }
                                }
                                
                                // 次の所持アイテムがあるかチェック
                                let hasNext = false;
                                for (let i = currentZoomIndex + 1; i < allItems.length; i++) {
                                    if (rareItems.find(owned => owned.id === allItems[i].id)) {
                                        hasNext = true;
                                        break;
                                    }
                                }
                                
                                prevButton.style.display = hasPrev ? 'flex' : 'none';
                                nextButton.style.display = hasNext ? 'flex' : 'none';
                            }
                        }
                    };

                    prevButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // 前の所持しているアイテムを探す
                        for (let i = currentZoomIndex - 1; i >= 0; i--) {
                            if (rareItems.find(owned => owned.id === allItems[i].id)) {
                                currentZoomIndex = i;
                                updateZoomItem();
                                break;
                            }
                        }
                    });

                    nextButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // 次の所持しているアイテムを探す
                        for (let i = currentZoomIndex + 1; i < allItems.length; i++) {
                            if (rareItems.find(owned => owned.id === allItems[i].id)) {
                                currentZoomIndex = i;
                                updateZoomItem();
                                break;
                            }
                        }
                    });

                    // スワイプ機能
                    let touchStartX = 0;
                    let touchEndX = 0;
                    zoomImage.addEventListener('touchstart', (e) => {
                        touchStartX = e.changedTouches[0].screenX;
                    });
                    zoomImage.addEventListener('touchend', (e) => {
                        touchEndX = e.changedTouches[0].screenX;
                        handleSwipe();
                    });

                    const handleSwipe = () => {
                        const swipeThreshold = 50;
                        const diff = touchStartX - touchEndX;
                        if (Math.abs(diff) > swipeThreshold) {
                            if (diff > 0) {
                                // 左スワイプ（次のアイテム）
                                nextButton.click();
                            } else {
                                // 右スワイプ（前のアイテム）
                                prevButton.click();
                            }
                        }
                    };

                    updateZoomItem();

                    const closeZoom = () => {
                        zoomOverlay.remove();
                    };

                    zoomOverlay.addEventListener('click', (e) => {
                        if (e.target === zoomOverlay) closeZoom();
                    });
                    
                    const keyHandler = (e) => {
                        if (e.key === 'Escape') {
                            closeZoom();
                            document.removeEventListener('keydown', keyHandler);
                        } else if (e.key === 'ArrowLeft') {
                            prevButton.click();
                        } else if (e.key === 'ArrowRight') {
                            nextButton.click();
                        }
                    };
                    document.addEventListener('keydown', keyHandler);

                    zoomContainer.appendChild(prevButton);
                    zoomContainer.appendChild(zoomImage);
                    zoomContainer.appendChild(nextButton);
                    zoomContainer.appendChild(zoomName);
                    zoomOverlay.appendChild(zoomContainer);
                    document.body.appendChild(zoomOverlay);
                });

                // ホバー効果
                item.addEventListener('mouseenter', () => {
                    item.style.transform = 'scale(1.05)';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.transform = 'scale(1)';
                });
            });
        }


        // Google認証関数（早期定義）
        async function signInWithGoogle() {
            if (!supabase) {
                console.log('Supabase接続なしのため、認証をスキップ');
                showToast('Supabase接続に問題があります', 'error');
                return;
            }
            
            try {
                // SupabaseのデフォルトコールバックURLを使用（Supabaseが自動的に処理）
                const redirectUrl = window.location.protocol + '//' + window.location.host + '/auth-callback.html';
                const { data, error } = await supabase.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        redirectTo: redirectUrl
                    }
                });
                
                if (error) {
                    console.error('Google認証エラー:', error);
                    showToast('認証に失敗しました', 'error');
                    return;
                }
                
                console.log('Google認証成功:', data);
                showToast('認証が開始されました', 'success');
                
            } catch (error) {
                console.error('Google認証例外:', error);
                showToast('認証処理でエラーが発生しました', 'error');
            }
        }


        function initTestModeFromEnv() {
            try {
                const url = new URL(window.location.href);
                const testParam = url.searchParams.get('test');
                if (testParam === '1' || testParam === 'true') {
                    localStorage.setItem('TEST_MODE', '1');
                }
            } catch (e) { /* no-op */ }
            TEST_MODE = localStorage.getItem('TEST_MODE') === '1';
            console.log('TEST_MODE:', TEST_MODE);
        }
        
        // モバイル端末を検出
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        console.log('デバイス検出:', isMobile ? 'スマホ' : 'PC');
        console.log('User Agent:', navigator.userAgent);
        
        initTestModeFromEnv();
        try {
            // すべてのデバイスでSupabase接続を試行
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
            console.log('Supabaseクライアント初期化成功');
            useLocalMode = false; // 認証必須なのでローカルモードは無効化
        } catch (error) {
            console.error('Supabaseクライアント初期化エラー:', error);
            console.error('Supabase接続に失敗しましたが、認証は必須です');
            // 認証必須のため、useLocalModeはfalseのままにする
            useLocalMode = false;
            // supabaseはnullのまま（認証チェック時にエラーハンドリング）
        }
        
        // 接続テスト
        if (supabase) {
            supabase.auth.getSession().then(({ data, error }) => {
                if (error) {
                    console.error('Supabase接続テストエラー:', error);
                } else {
                    console.log('Supabase接続テスト成功:', data.session ? 'セッションあり' : 'セッションなし');
                }
            });
        }
        
        // 認証状態管理
        let currentUser = null;
        let isAuthenticated = false;
        
        // イベント選択状態管理
        let selectedEventType = null; // 現在のイベントID
        let selectedSeriesKey = null; // 現在のシリーズキー
        let currentSelectedEventId = null;
        
        // キャッシュ管理
        const dataCache = {
            profiles: null,
            gameSaves: null,
            eventHistory: null,
            purchaseHistory: null,
            lastFetch: {},
            TTL: 60000 // 1分間キャッシュ
        };
        
        function getCachedData(key) {
            const cached = dataCache[key];
            if (!cached) return null;
            
            const now = Date.now();
            const lastFetch = dataCache.lastFetch[key] || 0;
            
            if (now - lastFetch > dataCache.TTL) {
                dataCache[key] = null;
                return null;
            }
            
            return cached;
        }
        
        function setCachedData(key, data) {
            dataCache[key] = data;
            dataCache.lastFetch[key] = Date.now();
        }
        
        function clearCache() {
            dataCache.profiles = null;
            dataCache.gameSaves = null;
            dataCache.eventHistory = null;
            dataCache.purchaseHistory = null;
            dataCache.lastFetch = {};
        }
        
        // ゲームデータ
        const GAME_CONFIG = {
            INITIAL_SHACHI: 200,
            CHARACTER_COST: 500,
            MAX_DAILY_EVENTS: 6, // 6シリーズを1日最大6回（各シリーズ1回）
            STAT_CAP: 999,
            LEVEL_UP_SHACHI: 50,
            RARE_ITEM_DROP_RATE: 0.17 // 17%の確率でレアアイテム
        };

        // レアアイテムデータ
        const RARE_ITEMS = [
            { id: 1, name: '伝説の定時退社バッジ', icon: '12_カード/20_レアアイテム/01_RareItem.png', rarity: 'legendary' },
            { id: 2, name: '無限コーヒーのマグカップ', icon: '12_カード/20_レアアイテム/02_RareItem.png', rarity: 'epic' },
            { id: 3, name: 'ブラックホールUSBメモリ', icon: '12_カード/20_レアアイテム/03_RareItem.png', rarity: 'epic' },
            { id: 4, name: '社畜の涙（エリクサー）', icon: '12_カード/20_レアアイテム/04_RareItem.png', rarity: 'rare' },
            { id: 5, name: 'パワポの聖典', icon: '12_カード/20_レアアイテム/05_RareItem.png', rarity: 'epic' },
            { id: 6, name: 'タイムカードの鍵', icon: '12_カード/20_レアアイテム/06_RareItem.png', rarity: 'rare' },
            { id: 7, name: '会議スキップの巻物', icon: '12_カード/20_レアアイテム/07_RareItem.png', rarity: 'epic' },
            { id: 8, name: 'Excel神の加護', icon: '12_カード/20_レアアイテム/08_RareItem.png', rarity: 'legendary' },
            { id: 9, name: '社内チャット封印の指輪', icon: '12_カード/20_レアアイテム/09_RareItem.png', rarity: 'rare' },
            { id: 10, name: '無限ToDoリスト', icon: '12_カード/20_レアアイテム/10_RareItem.png', rarity: 'rare' },
            { id: 11, name: '評価面談の護符', icon: '12_カード/20_レアアイテム/11_RareItem.png', rarity: 'epic' },
            { id: 12, name: '昼休み延長の砂時計', icon: '12_カード/20_レアアイテム/12_RareItem.png', rarity: 'rare' },
            { id: 13, name: '社畜の鎧（スーツ）', icon: '12_カード/20_レアアイテム/13_RareItem.png', rarity: 'epic' },
            { id: 14, name: '上司召喚の笛', icon: '12_カード/20_レアアイテム/14_RareItem.png', rarity: 'rare' },
            { id: 15, name: '社内政治の指南書', icon: '12_カード/20_レアアイテム/15_RareItem.png', rarity: 'epic' },
            { id: 16, name: '退職届（伝説級）', icon: '12_カード/20_レアアイテム/16_RareItem.png', rarity: 'legendary' }
        ];

        // バッチ定義（6カテゴリー、各段階的に難易度が上がる）
        const BADGES = [
            // 1. レベル
            {
                id: 'level_5',
                name: '新人社員',
                description: 'レベル5に到達',
                category: 'level',
                target: 5,
                icon: '🎓',
                reward: 100,
                order: 1
            },
            {
                id: 'level_10',
                name: '中堅社員',
                description: 'レベル10に到達',
                category: 'level',
                target: 10,
                icon: '📊',
                reward: 200,
                order: 2
            },
            {
                id: 'level_20',
                name: '上級社員',
                description: 'レベル20に到達',
                category: 'level',
                target: 20,
                icon: '⭐',
                reward: 300,
                order: 3
            },
            {
                id: 'level_30',
                name: 'エキスパート',
                description: 'レベル30に到達',
                category: 'level',
                target: 30,
                icon: '🏆',
                reward: 500,
                order: 4
            },
            {
                id: 'level_50',
                name: 'マスター',
                description: 'レベル50に到達',
                category: 'level',
                target: 50,
                icon: '👑',
                reward: 1000,
                order: 5
            },
            // 2. イベント
            {
                id: 'events_5',
                name: 'イベント初心者',
                description: 'イベントを5回完了',
                category: 'events',
                target: 5,
                icon: '📅',
                reward: 80,
                order: 1
            },
            {
                id: 'events_15',
                name: 'イベント経験者',
                description: 'イベントを15回完了',
                category: 'events',
                target: 15,
                icon: '📆',
                reward: 150,
                order: 2
            },
            {
                id: 'events_30',
                name: 'イベントエキスパート',
                description: 'イベントを30回完了',
                category: 'events',
                target: 30,
                icon: '🗓️',
                reward: 300,
                order: 3
            },
            {
                id: 'events_50',
                name: 'イベントマスター',
                description: 'イベントを50回完了',
                category: 'events',
                target: 50,
                icon: '🎯',
                reward: 500,
                order: 4
            },
            {
                id: 'events_100',
                name: 'イベントレジェンド',
                description: 'イベントを100回完了',
                category: 'events',
                target: 100,
                icon: '🌟',
                reward: 1000,
                order: 5
            },
            // 3. アイテム
            {
                id: 'items_3',
                name: 'ショッパー',
                description: 'アイテムを3回購入',
                category: 'items',
                target: 3,
                icon: '🛒',
                reward: 60,
                order: 1
            },
            {
                id: 'items_10',
                name: 'コレクター',
                description: 'アイテムを10回購入',
                category: 'items',
                target: 10,
                icon: '🛍️',
                reward: 150,
                order: 2
            },
            {
                id: 'items_25',
                name: 'ショッピングマニア',
                description: 'アイテムを25回購入',
                category: 'items',
                target: 25,
                icon: '💳',
                reward: 300,
                order: 3
            },
            {
                id: 'items_50',
                name: '購入王',
                description: 'アイテムを50回購入',
                category: 'items',
                target: 50,
                icon: '💎',
                reward: 600,
                order: 4
            },
            {
                id: 'items_100',
                name: 'コレクションの神',
                description: 'アイテムを100回購入',
                category: 'items',
                target: 100,
                icon: '👑',
                reward: 1200,
                order: 5
            },
            // 4. シャチ
            {
                id: 'shachi_500',
                name: '貯金開始',
                description: 'シャチを500獲得',
                category: 'shachi',
                target: 500,
                icon: '💰',
                reward: 50,
                order: 1
            },
            {
                id: 'shachi_1000',
                name: '貯金上手',
                description: 'シャチを1000獲得',
                category: 'shachi',
                target: 1000,
                icon: '💵',
                reward: 100,
                order: 2
            },
            {
                id: 'shachi_3000',
                name: '富裕層',
                description: 'シャチを3000獲得',
                category: 'shachi',
                target: 3000,
                icon: '💸',
                reward: 200,
                order: 3
            },
            {
                id: 'shachi_5000',
                name: '大富豪',
                description: 'シャチを5000獲得',
                category: 'shachi',
                target: 5000,
                icon: '💴',
                reward: 400,
                order: 4
            },
            {
                id: 'shachi_10000',
                name: 'シャチの神',
                description: 'シャチを10000獲得',
                category: 'shachi',
                target: 10000,
                icon: '💶',
                reward: 800,
                order: 5
            },
            // 5. キャラクター保有
            {
                id: 'characters_3',
                name: 'コレクション開始',
                description: 'キャラクターを3体保有',
                category: 'characters',
                target: 3,
                icon: '👤',
                reward: 150,
                order: 1
            },
            {
                id: 'characters_5',
                name: 'キャラクター好き',
                description: 'キャラクターを5体保有',
                category: 'characters',
                target: 5,
                icon: '👥',
                reward: 250,
                order: 2
            },
            {
                id: 'characters_10',
                name: 'コレクター',
                description: 'キャラクターを10体保有',
                category: 'characters',
                target: 10,
                icon: '👬',
                reward: 500,
                order: 3
            },
            {
                id: 'characters_15',
                name: 'キャラクターマスター',
                description: 'キャラクターを15体保有',
                category: 'characters',
                target: 15,
                icon: '👨‍👩‍👧‍👦',
                reward: 750,
                order: 4
            },
            {
                id: 'characters_16',
                name: '完全制覇',
                description: '全キャラクターを保有',
                category: 'characters',
                target: 16,
                icon: '🎖️',
                reward: 1500,
                order: 5
            },
            // 6. 習慣
            {
                id: 'habits_10',
                name: '習慣始め',
                description: '習慣チェックを10回達成',
                category: 'habits',
                target: 10,
                icon: '📝',
                reward: 100,
                order: 1
            },
            {
                id: 'habits_30',
                name: '習慣継続者',
                description: '習慣チェックを30回達成',
                category: 'habits',
                target: 30,
                icon: '📋',
                reward: 200,
                order: 2
            },
            {
                id: 'habits_70',
                name: '習慣の達人',
                description: '習慣チェックを70回達成',
                category: 'habits',
                target: 70,
                icon: '✅',
                reward: 400,
                order: 3
            },
            {
                id: 'habits_150',
                name: '習慣マスター',
                description: '習慣チェックを150回達成',
                category: 'habits',
                target: 150,
                icon: '🎯',
                reward: 600,
                order: 4
            },
            {
                id: 'habits_300',
                name: '習慣の神',
                description: '習慣チェックを300回達成',
                category: 'habits',
                target: 300,
                icon: '🏅',
                reward: 1000,
                order: 5
            }
        ];

        const SHOP_ITEMS = [
            {
                id: 'stomach_medicine',
                name: '胃薬',
                icon: '💊',
                cost: 50,
                description: 'ストレス耐性+10',
                effect: { stress: 10 },
                requiredRank: null
            },
            {
                id: 'trackball_mouse',
                name: 'トラックボールマウス',
                icon: '🖱️',
                cost: 80,
                description: '体力+15',
                effect: { physical: 15 },
                requiredRank: null
            },
            {
                id: 'energy_drink',
                name: 'エナジードリンク',
                icon: '🥤',
                cost: 30,
                description: '体力+5, ストレス耐性+5',
                effect: { physical: 5, stress: 5 },
                requiredRank: null
            },
            {
                id: 'sleeping_bag',
                name: '寝袋',
                icon: '🛌',
                cost: 100,
                description: 'ストレス耐性+20',
                effect: { stress: 20 },
                requiredRank: null
            },
            {
                id: 'coffee',
                name: 'コーヒー',
                icon: '☕',
                cost: 20,
                description: '知識+8',
                effect: { knowledge: 8 },
                requiredRank: null
            },
            {
                id: 'vitamin',
                name: 'ビタミン剤',
                icon: '💊',
                cost: 40,
                description: '体力+10, コミュ力+5',
                effect: { physical: 10, communication: 5 },
                requiredRank: null
            },
            {
                id: 'convenience_bento',
                name: 'コンビニ弁当',
                icon: '🍱',
                cost: 25,
                description: '体力+8',
                effect: { physical: 8 },
                requiredRank: null
            },
            {
                id: 'cup_noodle',
                name: 'カップラーメン',
                icon: '🍜',
                cost: 15,
                description: '体力+3, ストレス耐性+3',
                effect: { physical: 3, stress: 3 },
                requiredRank: null
            },
            {
                id: 'shoe_polish',
                name: '靴磨き',
                icon: '👞',
                cost: 150,
                description: '体力+20, ストレス耐性+15',
                effect: { physical: 20, stress: 15 },
                requiredRank: 1
            },
            {
                id: 'breath_care',
                name: 'ブレスケア',
                icon: '💨',
                cost: 120,
                description: 'コミュ力+20',
                effect: { communication: 20 },
                requiredRank: 1
            },
            {
                id: 'expensive_keyboard',
                name: '高いキーボード',
                icon: '⌨️',
                cost: 200,
                description: '知識+30',
                effect: { knowledge: 30 },
                requiredRank: 2
            },
            {
                id: 'apology_yokan',
                name: '謝罪用の羊羹',
                icon: '🍮',
                cost: 180,
                description: 'ストレス耐性+25, コミュ力+15',
                effect: { stress: 25, communication: 15 },
                requiredRank: 2
            },
            {
                id: 'golf_goods',
                name: 'ゴルフグッズ',
                icon: '⛳',
                cost: 300,
                description: '体力+40, コミュ力+30',
                effect: { physical: 40, communication: 30 },
                requiredRank: 3
            },
            {
                id: 'jacket_for_placement',
                name: '置きジャケット',
                icon: '🧥',
                cost: 250,
                description: 'ストレス耐性+35',
                effect: { stress: 35 },
                requiredRank: 3
            }
        ];
        const DAILY_EVENTS = [
            // 上司シリーズ 👔（リライト）
            {
                id: 'boss_weekend_push',
                series: 'boss',
                title: '土日対応の押し付け',
                description: '上司が慌てた様子でやってきた。「すまん！月曜の朝イチでクライアントに提出する資料、今から作ってもらえる？実は先週から分かってたんだけど、君の能力なら土日でサクッと仕上がると思って。もちろん振替休日は後で取ってもらうから！家族サービス？来月にでもしたらいいじゃない。会社があってこその家族でしょ？」',
                choices: [
                    { text: '「承知しました！今すぐ取り掛かります！」', effect: { stress: 3, shachi: 200 } , feedback: '猛烈なプレッシャーの中、超特急で着手！' },
                    { text: '「今日は予定があるので、月曜早朝に出社して対応します」', effect: { knowledge: 2, communication: 1, shachi: 150 }, feedback: '計画的な提案で折衷案に。少しは休日が守れた' },
                    { text: '「事前に教えていただければ平日に準備できました」', effect: { communication: 3, shachi: 100 }, feedback: '冷静にフィードバック。次回は改善される…かも' },
                    { text: '「申し訳ありませんが、今回は対応できません」', effect: { physical: 2, stress: -2, shachi: 50 }, feedback: '自分の時間を守った。評価は微妙でも体は大切' }
                ]
            },
            {
                id: 'boss_flipflop_denial',
                series: 'boss',
                title: '昨日まで褒めていた企画を全否定',
                description: '昨日は「君のアイデアは素晴らしい！」と絶賛していたのに、今日は一転して「やっぱりダメだね。根本的に考え直して。とりあえず今日中に新しい案を3つ」との無茶ぶり。昨日の話は無かったことに…',
                choices: [
                    { text: '「承知しました。すぐに新しい案を考えます」', effect: { stress: 4, shachi: 175 }, feedback: '気持ちを切り替えて前進。タフさが鍛えられる' },
                    { text: '「昨日の企画のどの部分が問題でしょうか？」', effect: { knowledge: 3, shachi: 225 }, feedback: '問題点を具体化し、建設的に進めるきっかけへ' },
                    { text: '「メールで経緯を記録しておきましょうか？」', effect: { knowledge: 4, communication: 1, shachi: 250 }, feedback: '記録は未来の自分を助ける最強の盾' },
                    { text: '心の中で舌打ちしながら黙って頷く', effect: { stress: 2, physical: -1, shachi: 125 }, feedback: '感情を飲み込み、静かに嵐が過ぎるのを待つ' }
                ]
            },
            {
                id: 'boss_steals_credit',
                series: 'boss',
                title: '責任は部下、手柄は上司',
                description: 'あなたが半年かけて成功させたプロジェクトを、上司が「私の戦略」と発表；会議後には「失敗したら君の責任、成功したら私の手柄。それがチームワーク」と言い放つ。',
                choices: [
                    { text: '「はい、チームの一員として貢献できて光栄です」', effect: { stress: 5, shachi: 150 }, feedback: '大人の対応で場は丸く収まる' },
                    { text: '「プロジェクトの詳細資料をまとめておきますね」', effect: { knowledge: 4, shachi: 275 }, feedback: '成果の証跡を残し、評価の土台を作る' },
                    { text: '「関係者の皆さんにも報告させていただきます」', effect: { communication: 4, shachi: 300 }, feedback: '関係者連携で実績を可視化。周囲は見ている' },
                    { text: '「それはチームワークとは言わないと思います」', effect: { physical: 3, stress: -3, shachi: 75 }, feedback: '一線を引く勇気。自尊心は守られた' }
                ]
            },
            {
                id: 'boss_spiritual_overtime',
                series: 'boss',
                title: '「みんなで頑張ろう」残業',
                description: '定時間際、上司が「ここが踏ん張りどころ！やりがいを感じながら働けるなんて幸せだ！」と精神論で残業を煽ってくる。',
                choices: [
                    { text: '「はい！みんなで頑張りましょう！」', effect: { stress: 3, communication: 2, shachi: 200 }, feedback: '場の空気を優先。チームの士気は上がった…かも' },
                    { text: '「効率的な作業分担を提案させてください」', effect: { knowledge: 4, shachi: 250 }, feedback: '仕組み化で残業を最小化。合理性は力' },
                    { text: '「残業代の申請方法を確認させてください」', effect: { knowledge: 3, shachi: 225 }, feedback: '権利は知る者の味方。堂々と確認' },
                    { text: '「今日は体調が優れないので失礼します」', effect: { physical: 2, stress: 1, shachi: 100 }, feedback: 'セルフケアを最優先。明日へ備える' }
                ]
            },
            // お客系エピソード
            {
                id: 'impossible_demands',
                series: 'customer',
                title: '不可能な要求をしてくる客',
                description: '「無料で1日で完成させてください」😤 物理的に無理すぎる',
                choices: [
                    {
                        text: 'YESマンになって無理やり達成',
                        effect: { shachi: 200, stress: 35, knowledge: 8, physical: -25 },
                        feedback: '寝ずに完成✅ でも次回も同レベルの要求が来る'
                    },
                    {
                        text: '丁寧に条件調整を提案',
                        effect: { shachi: 88, stress: 10, communication: 15, knowledge: 5 },
                        feedback: 'プロ対応が評価！品質も担保できた🎯'
                    },
                    {
                        text: '上司に丸投げして自分は距離を置く',
                        effect: { shachi: 25, stress: -10, physical: 10, communication: -30 },
                        feedback: '責任回避成功...でも担当から外された'
                    }
                ]
            },
            {
                id: 'angry_customer_storm',
                series: 'customer',
                title: '激怒客の電話責め',
                description: '「お前の会社はクソだ！」電話越しに怒鳴られ続ける脅迫電話...',
                choices: [
                    {
                        text: 'ひたすら謝罪して相手をなだめる',
                        effect: { shachi: 125, stress: 25, communication: 12, knowledge: 3 },
                        feedback: '根気で収めた✅ でも心がボロボロ'
                    },
                    {
                        text: '冷静に事実確認とルール説明',
                        effect: { shachi: 75, stress: 15, knowledge: 8, communication: 8 },
                        feedback: 'プロフェッショナル対応で切り返した🎯'
                    },
                    {
                        text: '上司に代わってもらう',
                        effect: { shachi: 50, stress: -5, physical: 5, communication: -15 },
                        feedback: '現場放棄判定...でもストレスは回避'
                    }
                ]
            },
            {
                id: 'last_minute_change',
                series: 'customer',
                title: '最後の最後に変更依頼',
                description: '納品1時間前に「やっぱ違うので全部変えて」💥 頭おかしい',
                choices: [
                    {
                        text: '無理やり全部やり直して徹夜',
                        effect: { shachi: 225, stress: 45, physical: -30, knowledge: 10 },
                        feedback: '金輪際この客は覚えた💀 体は限界'
                    },
                    {
                        text: '追加費用を提示して断る',
                        effect: { shachi: 100, stress: 5, communication: 10, knowledge: 5 },
                        feedback: 'ビジネス判断で守れた...でも関係悪化'
                    },
                    {
                        text: '部分的変更で折り合いを付ける',
                        effect: { shachi: 125, stress: 20, communication: 12, knowledge: 6 },
                        feedback: '最適解を見つけた🎯 でも心は疲弊'
                    }
                ]
            },
            {
                id: 'customer_god_mantra',
                series: 'customer',
                title: '「お客様は神様」を連呼する客',
                description: '威圧的な声で「お客様は神様だろ？できないなんて言葉はないはずだ。責任者出せ！社長出せ！」と要求。内容は規定外で物理的にも不可能。',
                choices: [
                    { text: '「申し訳ございません、おっしゃる通りです」', effect: { stress: 4, shachi: 150 }, feedback: '嵐が過ぎるのを待つ…タフさは上がった' },
                    { text: '「規定の範囲内でできる限り対応いたします」', effect: { communication: 3, shachi: 200 }, feedback: '落としどころを提示。会話が前に進んだ' },
                    { text: '「上司に確認いたします」', effect: { knowledge: 2, shachi: 175 }, feedback: 'エスカレーションで時間を稼ぐ' },
                    { text: '「ご要望は承りましたが、実現は困難です」', effect: { knowledge: 4, stress: -1, shachi: 225 }, feedback: '事実ベースで線引き。納得はされないが明確化' }
                ]
            },
            {
                id: 'customer_two_hour_claim',
                series: 'customer',
                title: '理不尽なクレームで2時間拘束',
                description: '「この商品のせいで人生が狂った！」と続く罵倒。明らかな使用ミスだが謝罪と賠償を要求。',
                choices: [
                    { text: 'ひたすら謝罪し続ける', effect: { stress: 5, physical: -2, shachi: 250 }, feedback: '怒りは収まったが、体力も時間も消耗' },
                    { text: '冷静に事実を説明する', effect: { knowledge: 4, communication: 2, shachi: 300 }, feedback: '根拠を示しつつ丁寧に説明。一定の理解へ' },
                    { text: '「この通話を録音しております」', effect: { knowledge: 5, shachi: 375 }, feedback: '態度が一変。法的リスクを意識させた' },
                    { text: '「お客様相談室におつなぎします」', effect: { communication: 3, shachi: 200 }, feedback: '専門窓口へ誘導し、業務継続' }
                ]
            },
            {
                id: 'customer_return_fraud',
                series: 'customer',
                title: '返品詐欺の常習犯',
                description: '使い古しを「新品同様」と主張。レシートは無く、過去にも同様の履歴あり。',
                choices: [
                    { text: '「確認いたします」と言って時間を稼ぐ', effect: { knowledge: 3, shachi: 175 }, feedback: '冷静に裏取り。記録の確認時間を確保' },
                    { text: '「購入証明書が必要です」と説明', effect: { knowledge: 4, communication: 1, shachi: 225 }, feedback: 'ルールを明確化し、悪質対応を牽制' },
                    { text: '「過去の履歴を確認させてください」', effect: { knowledge: 5, shachi: 275 }, feedback: '履歴を根拠に不正を抑止' },
                    { text: '「特別対応として半額返金いたします」', effect: { stress: 3, shachi: 125 }, feedback: '現場判断で収束。ただし前例化に注意' }
                ]
            },
            {
                id: 'customer_nostalgia_uncle',
                series: 'customer',
                title: '「昔の方が良かった」おじさん客',
                description: '「昔はもっと親身だった」「夜中でも対応した」と昔話。すでに1時間経過し、他の電話が鳴り続けている。',
                choices: [
                    { text: '「昔の方は素晴らしかったのですね」と共感', effect: { communication: 4, stress: 2, shachi: 200 }, feedback: '共感で温度を下げ、話を前に進めた' },
                    { text: '「現在のサービス内容についてご説明します」', effect: { knowledge: 4, shachi: 225 }, feedback: '現行ルールを丁寧に説明し理解を促す' },
                    { text: '「貴重なご意見として承ります」', effect: { communication: 3, knowledge: 1, shachi: 250 }, feedback: '意見として受け止め、記録して次へ' },
                    { text: '「申し訳ありませんが、他のお客様もお待ちなので...」', effect: { physical: 2, stress: 1, shachi: 150 }, feedback: '業務優先を明確化。会話を切り上げた' }
                ]
            },
            // 御局系エピソード（リライト）
            {
                id: 'ojou_overtime_lecture',
                series: 'ojou',
                title: '「私の時代は残業代なんてなかった」説教',
                description: 'お局様がコーヒーを片手にやってきた。「最近の若い子は残業代ばっかり...私たちの時代は当たり前だったのよ。やりがいや成長が大事でしょ？お金じゃ買えない経験を積ませてるんだから、感謝しなさい。」',
                choices: [
                    { text: '「そうですね、勉強になります」', effect: { communication: 2, stress: 1, shachi: 125 }, feedback: '表面は和やかに、内心は...もうぎゅうぎゅう' },
                    { text: '「時代が変わって、法律も変わりましたから」', effect: { knowledge: 3, shachi: 225 }, feedback: '冷静に事実を提示。ただし次回は要注意' },
                    { text: '「やりがいも大切ですが、生活もありますので...」', effect: { communication: 3, shachi: 175 }, feedback: 'バランスを見せつつ、自分の線を示した' },
                    { text: '「それって労働基準法違反じゃないですか？」', effect: { knowledge: 4, stress: -2, shachi: 100 }, feedback: '毅然とした態度。でも後で嫌味がくるかも' }
                ]
            },
            {
                id: 'ojou_copy_machine_sermon',
                series: 'ojou',
                title: 'コピー機の使い方で1時間説教',
                description: 'お局様がコピー機の前で呼び止めてきた。「そのコピーの取り方、全然ダメよ！私は入社時は手動のコピー機で一枚一枚...今の子は機械に頼りすぎ。基本を覚えなさい。あとこの前のファイリングも雑よ。」',
                choices: [
                    { text: '熱心にメモを取りながら聞く', effect: { knowledge: 2, communication: 3, shachi: 200 }, feedback: '大人な対応で好感度アップ。でも時間は消えた' },
                    { text: '「マニュアルを読んで覚えます」', effect: { knowledge: 4, shachi: 150 }, feedback: 'クイックに対応。でもお局は満足してない' },
                    { text: '「他の方法も教えていただけますか？」', effect: { communication: 4, shachi: 225 }, feedback: '建設的姿勢で関係を改善。意外と好印象' },
                    { text: '心の中で時計を見ながら相槌を打つ', effect: { stress: 4, shachi: 100 }, feedback: '時は過ぎてゆく。でもストレス耐性は強化された' }
                ]
            },
            {
                id: 'ojou_gender_task',
                series: 'ojou',
                title: '「女性は気配りができるから」理論',
                description: 'お局様がにこやかに近づいてきた。「歓送迎会の準備、お願いしようと思って。会場、料理、席次表、司会...女性の方が場を盛り上げるのが上手だから。え？忙しい？でも女性の方がマルチタスクが得意でしょ？期待してるから！」',
                choices: [
                    { text: '「ありがとうございます、頑張ります」', effect: { stress: 2, communication: 2, shachi: 175 }, feedback: '素直に引き受け。でも胃が痛い' },
                    { text: '「他の方と分担してもよろしいでしょうか？」', effect: { communication: 4, shachi: 250 }, feedback: '負担分散を提案。スマートにタスクをシェア' },
                    { text: '「男性陣にも協力してもらいましょう」', effect: { knowledge: 3, communication: 2, shachi: 275 }, feedback: '公平性を訴求。チーム全体の意識が変わるかも' },
                    { text: '「今は別の重要な業務があるので...」', effect: { physical: 2, stress: 1, shachi: 125 }, feedback: '仕事を優先。優先順位の整理力が評価される' }
                ]
            },
            {
                id: 'ojou_tea_service',
                series: 'ojou',
                title: 'お茶出しは女性の仕事論',
                description: '会議準備中、お局様が指示。「お茶の準備お願い。温度も気をつけて。来客用の上等な茶葉でね。男性陣は会議の準備があるから、こういうのは女性の仕事よ。おもてなしの心が大切なの。日本の美しい文化でしょ？あ、お菓子の盛り付けも綺麗にしてね。」',
                choices: [
                    { text: '「承知しました、心を込めて準備します」', effect: { communication: 3, stress: 2, shachi: 200 }, feedback: 'プロ意識で対応。評価は上がるが負担は増える' },
                    { text: '「会議資料の準備もあるので、交代でお願いします」', effect: { knowledge: 3, communication: 2, shachi: 225 }, feedback: '業務の配分を提案。合理的なアプローチで理解を得る' },
                    { text: '「男性の方にもお茶当番をお願いしてみては？」', effect: { knowledge: 4, shachi: 175 }, feedback: '性別役割分担の見直しを提言。波紋が広がる' },
                    { text: '「今回は会議に集中したいので失礼します」', effect: { physical: 3, stress: -1, shachi: 100 }, feedback: '自分の役割に集中。ただし次の会では要注意' }
                ]
            },
            // システム障害シリーズ（リライト）
            {
                id: 'system_deadline_crash',
                series: 'system',
                title: '締切直前のシステムクラッシュ',
                description: '最終確認中にPCがブルースクリーン。バックアップは3日前。ITは原因調査中、上司は「なんとかしろ」。',
                choices: [
                    { text: '徹夜で手作業で資料を再作成', effect: { stress: 5, physical: -3, shachi: 300 }, feedback: '力業で仕上げた。体はボロボロ' },
                    { text: '3日前のバックアップを修正して対応', effect: { knowledge: 4, shachi: 250 }, feedback: '被害を最小化。現実的な落とし所' },
                    { text: 'プレゼンの延期を上司に相談', effect: { communication: 3, shachi: 200 }, feedback: '信頼を失わない形で調整を試みた' },
                    { text: '他部署のPCを借りて作業継続', effect: { communication: 4, knowledge: 2, shachi: 275 }, feedback: '横連携で突破口を作る' }
                ]
            },
            {
                id: 'system_mail_error_hell',
                series: 'system',
                title: 'メール送信エラーの地獄',
                description: '重要メールが送れず、ITは「メンテ中」。告知はなし。クライアントからは催促コール。',
                choices: [
                    { text: '個人のメールアカウントから送信', effect: { knowledge: 3, shachi: 225 }, feedback: '一時しのぎ。ただし社内ルールには注意' },
                    { text: '電話でクライアントに直接説明', effect: { communication: 4, shachi: 250 }, feedback: '誠実な説明で信頼を維持' },
                    { text: 'FAXで資料を送信', effect: { knowledge: 2, shachi: 175 }, feedback: '旧来手段で突破。意外と役立つ' },
                    { text: 'IT部門に緊急対応を要請', effect: { stress: 3, shachi: 200 }, feedback: '優先度を上げてもらい復旧が早まった' }
                ]
            },
            {
                id: 'system_data_loss',
                series: 'system',
                title: 'データ消失パニック',
                description: '共有サーバーが消滅。バックアップは1週間前。締切まで3日。',
                choices: [
                    { text: 'チーム総出で1週間分を3日で再作成', effect: { stress: 6, physical: -2, shachi: 375 }, feedback: '根性で巻き返し。精神力が鍛えられた' },
                    { text: '締切延期の交渉を上司に依頼', effect: { communication: 4, shachi: 200 }, feedback: '現実的なスケジュールに再設定' },
                    { text: '外部業者に復旧作業を依頼', effect: { knowledge: 5, shachi: 300 }, feedback: 'プロの力で復旧。費用対効果は十分' },
                    { text: '個人PCのバックアップデータを確認', effect: { knowledge: 4, communication: 2, shachi: 250 }, feedback: 'ローカルの救いが大きく貢献' }
                ]
            },
            {
                id: 'system_printer_disaster',
                series: 'system',
                title: '印刷機の大規模故障',
                description: '1000部印刷中に複合機から煙。全社同型機が一斉故障。会議は明日。',
                choices: [
                    { text: '複数のコンビニを回って少しずつ印刷', effect: { physical: -1, stress: 3, shachi: 200 }, feedback: '泥臭いが確実。達成感はある' },
                    { text: '緊急で印刷業者に特急料金で依頼', effect: { knowledge: 3, shachi: 175 }, feedback: 'コストはかかるが品質と確実性を取る' },
                    { text: '資料をデジタル配布に変更提案', effect: { knowledge: 4, communication: 3, shachi: 275 }, feedback: 'DXで乗り切る。参加者の反応も良好' },
                    { text: '他社に印刷機使用をお願い', effect: { communication: 5, shachi: 300 }, feedback: '社外連携で突破。感謝が次の縁に繋がる' }
                ]
            },
            {
                id: 'system_network_meltdown',
                series: 'system',
                title: '社内ネットワーク全面ダウン',
                description: '社内ネットが全社一斉にダウン。作業中のファイルは保存されておらず、ITは復旧時間未定。重要会議の資料提出まで30分。',
                choices: [
                    { text: '個人のスマホのテザリングで急いで再作成', effect: { stress: 4, knowledge: 3, shachi: 250 }, feedback: '機転を利かせて間に合わせた。柔軟性が評価' },
                    { text: '上司に状況を説明して提出を延期', effect: { communication: 4, shachi: 200 }, feedback: '誠実に報告。信頼関係を維持' },
                    { text: '他部署のPCでログインして作業継続', effect: { knowledge: 3, communication: 2, shachi: 225 }, feedback: '臨機応変に対応。協調力が向上' },
                    { text: '紙媒体で手書き資料を作成', effect: { physical: -1, knowledge: 2, shachi: 175 }, feedback: 'アナログ対応。根性は評価される' }
                ]
            },
            {
                id: 'system_smartphone_ban',
                series: 'system',
                title: 'スマホ持ち込み全面禁止',
                description: 'セキュリティ強化で社内へのスマホ持ち込み禁止に。あなたは通勤・連絡・業務全てでスマホ依存。代替手段も用意されていない。',
                choices: [
                    { text: '「業務効率が大幅に低下します」と反論', effect: { communication: 3, shachi: 200 }, feedback: '論理的に主張。効果的な反論' },
                    { text: '「会社用スマホ支給は可能でしょうか」', effect: { knowledge: 3, shachi: 225 }, feedback: '代替案を提示。建設的提案' },
                    { text: '内緒で持ち込み続ける', effect: { knowledge: -1, stress: 4, shachi: 150 }, feedback: '規則違反リスクは高い' },
                    { text: '紙の資料と固定電話で対応', effect: { knowledge: 2, physical: 2, shachi: 175 }, feedback: 'アナログ化で逆に集中力が向上' }
                ]
            },
            {
                id: 'system_cloud_sync_error',
                series: 'system',
                title: 'クラウド同期エラーの連鎖',
                description: 'ファイルの自動同期が狂って古いバージョンに上書き。チーム全員の作業が1週間分消失。上司は怒り心頭で詰め寄ってくる。',
                choices: [
                    { text: '徹夜で全員分の作業を再現', effect: { stress: 5, physical: -3, shachi: 300 }, feedback: 'チームワークで巻き返し。信頼回復' },
                    { text: 'クラウドサポートに緊急対応を依頼', effect: { knowledge: 4, shachi: 250 }, feedback: 'プロの力で復旧。冷静な判断' },
                    { text: '『自動バックアップの整備を提案』', effect: { knowledge: 5, shachi: 275 }, feedback: '再発防止策が評価。システム力向上' },
                    { text: '「大変申し訳ございません」と謝罪', effect: { communication: 2, shachi: 200 }, feedback: '誠実に謝罪。最小限の被害' }
                ]
            },
        // 社内イベントシリーズ（アップデート）
            {
            id: 'event_drink_shuffle',
                series: 'event',
            title: '終電後の飲み会ラリー',
            description: '部長「今日は朝までハシゴね！新人は一滴も残さず！」　翌朝は朝会あり。どう乗り切る？',
                choices: [
                { text: 'ワンオペで全員分のソフトドリンクをキープ', effect: { communication: 4, knowledge: 2, stress: 3, shachi: 220 }, feedback: '誰も酔いつぶれず終了。幹事スキルUP' },
                { text: '飲んだふりをして議事メモを取り続ける', effect: { knowledge: 4, stress: 2, shachi: 250 }, feedback: '翌朝の朝会も資料化。評価爆上がり' },
                { text: 'タクシーチケットを確保し終電前に撤収', effect: { physical: 2, stress: 1, shachi: 180 }, feedback: '自衛は大事。少し距離を置かれた' },
                { text: '全力で盛り上げて自分もダウン', effect: { physical: -3, stress: 5, shachi: 150 }, feedback: '翌日ゾンビ。だが友情は芽生えた' }
            ]
        },
        {
            id: 'event_welcome_farewell',
                series: 'event',
            title: '歓送迎会の席次地獄',
            description: '「新人・ベテラン・役員・リモート組」全部入りの歓送迎会。失敗すると翌日社内チャットが炎上する。',
                choices: [
                { text: '全員の関係図を作って席をアルゴリズム配置', effect: { knowledge: 4, communication: 3, shachi: 260 }, feedback: '科学の力で平和を実現' },
                { text: '席をくじ引きにして公平アピール', effect: { communication: 3, stress: 2, shachi: 210 }, feedback: '場は盛り上がるが役員の隣に新人が...' },
                { text: 'リモート勢は同時接続のバーチャル席を用意', effect: { knowledge: 5, shachi: 280 }, feedback: 'DX歓迎。全社ニュースに載った' },
                { text: '上司に任せて当日は会場係に徹する', effect: { physical: 2, shachi: 160 }, feedback: '波風は立たないが成長もなし' }
            ]
        },
        {
            id: 'event_sports_festival',
                series: 'event',
            title: '社畜大運動会',
            description: '土曜開催・振替休日なし。「部署対抗ガチリレー」「裸足でビーチフラッグ」などブラック種目。',
                choices: [
                { text: '実況アナウンサー役を買って出る', effect: { communication: 4, stress: 1, shachi: 230 }, feedback: '声を枯らしつつ好評を博した' },
                { text: '医務係として救急箱と湿布を配りまくる', effect: { knowledge: 3, physical: 2, shachi: 200 }, feedback: '裏方ヒーロー。感謝スタンプ大量' },
                { text: '勝てる競技に絞って猛練習', effect: { physical: 5, stress: 3, shachi: 250 }, feedback: '怪我をしつつも部署優勝' },
                { text: '映像班としてドローン撮影を担当', effect: { knowledge: 4, stress: 1, shachi: 240 }, feedback: '編集スキルまで評価された' }
            ]
        },
        {
            id: 'event_volunteer_clean',
                series: 'event',
            title: '休日ボランティア掃除',
            description: '「社会貢献も仕事のうち」と言われ、海岸清掃＋SNS発信を任される。',
                choices: [
                { text: 'タイムラプスで進捗を撮影しレポ作成', effect: { knowledge: 4, communication: 3, shachi: 260 }, feedback: 'CSR委員会から表彰' },
                { text: '社内メッセでリアルタイム配信', effect: { communication: 4, stress: 2, shachi: 210 }, feedback: '参加できない社員も満足' },
                { text: '清掃ロボを持ち込み自動化アピール', effect: { knowledge: 5, stress: 1, shachi: 270 }, feedback: '技術推進賞を獲得' },
                { text: '黙々と清掃して誰よりもゴミ袋を集める', effect: { physical: 3, stress: 1, shachi: 190 }, feedback: '評価は地味だが達成感はあった' }
            ]
        },
        {
            id: 'event_year_end',
            series: 'event',
            title: '忘年会カラオケ地獄',
            description: '「持ち歌3曲必要」「社歌アレンジ必須」。音痴だと翌日社内SNSで話題に。',
            choices: [
                { text: '社歌をEDM風にアレンジし全員で合唱', effect: { communication: 5, stress: 3, shachi: 260 }, feedback: '期待以上。動画が社内バズ' },
                { text: '映像付きのスライドでカラオケを演出', effect: { knowledge: 4, stress: 2, shachi: 230 }, feedback: '演出家として覚えられた' },
                { text: '機材トラブル係として幕の裏に隠れる', effect: { knowledge: 3, physical: 1, shachi: 200 }, feedback: '裏方で安全にやり過ごした' },
                { text: 'プロ歌手をこっそり雇いサプライズ', effect: { stress: 1, communication: 4, shachi: -200 }, feedback: '赤字だが熱狂的な盛り上がり' }
            ]
        },
        {
            id: 'event_new_year',
            series: 'event',
            title: '新年書き初めミーティング',
            description: '仕事始めの日に全員が抱負を書いてプレゼン。内容は経営陣の前で読み上げ。',
            choices: [
                { text: '部署KPIを俳句にまとめて発表', effect: { knowledge: 4, communication: 3, shachi: 250 }, feedback: '読みやすくて高評価' },
                { text: '書き初めをインフォグラフィック化', effect: { knowledge: 5, stress: 2, shachi: 270 }, feedback: 'デザイン賞を受賞' },
                { text: '抱負をARで表示するデモを作成', effect: { knowledge: 5, communication: 2, shachi: 280 }, feedback: '未来感たっぷりで話題に' },
                { text: 'あえて直筆のみで味を出す', effect: { physical: 1, stress: 1, shachi: 190 }, feedback: '地味だが誠実と評価' }
            ]
        },
        {
            id: 'event_promotion_party',
            series: 'event',
            title: '昇格祝いのサプライズ任務',
            description: '急遽、部長の昇格祝いを明日までに準備するよう依頼。予算は1万円。',
            choices: [
                { text: 'Slackスタンプでサプライズ動画を制作', effect: { knowledge: 3, communication: 4, shachi: 240 }, feedback: '低コストで涙を誘った' },
                { text: '部内アンケートを集めフォトブック化', effect: { knowledge: 4, stress: 2, shachi: 230 }, feedback: '思い出の結晶で好感度UP' },
                { text: '昇格者の似顔絵ケーキを自作', effect: { physical: 2, communication: 3, shachi: 210 }, feedback: '手作り感に大喜び' },
                { text: 'カレンダー形式のスライドで成果を振り返る', effect: { knowledge: 5, shachi: 260 }, feedback: '上層部にも配布され評価高騰' }
            ]
        },
        // 謎のセミナーシリーズ（アップデート）
        {
            id: 'skill_brainstorm_retreat',
                series: 'skill',
            title: '海辺の無音ブレスト合宿',
            description: '「2泊3日でマインドを空にする」社外セミナー。海岸で叫び→砂にKPIを書くプログラム。',
                choices: [
                { text: 'とりあえず参加し海岸で議事録を取る', effect: { knowledge: 3, stress: 4, shachi: -120 }, feedback: '潮風でPCが砂まみれ' },
                { text: '近場からリモート参加を提案', effect: { communication: 3, shachi: 220 }, feedback: 'コスト削減に成功' },
                { text: '科学的根拠を添えて社内勉強会に変換', effect: { knowledge: 5, shachi: 250 }, feedback: '合理的だと評価され却下' },
                { text: '断りつつ代替として実務研修を企画', effect: { knowledge: 4, communication: 3, shachi: 230 }, feedback: '現場に感謝される' }
            ]
        },
        {
            id: 'skill_blockchain_yoga',
                series: 'skill',
            title: 'ブロックチェーン×ヨガ体験セミナー',
            description: '謎の講師が「姿勢を整えるとWeb3が見える」と豪語。参加費8万円。',
                choices: [
                { text: '筋肉痛覚悟でフル参加', effect: { physical: -3, knowledge: 2, shachi: -200 }, feedback: '健康は得たが財布は空' },
                { text: 'レポート目的でオンライン聴講だけ申し込む', effect: { knowledge: 4, shachi: 220 }, feedback: '要点だけ吸収' },
                { text: 'IT部門に協力を仰ぎ内容を検証', effect: { knowledge: 5, communication: 2, shachi: 240 }, feedback: 'やんわりお断り成功' },
                { text: '福利厚生での補助対象か交渉', effect: { communication: 3, shachi: 210 }, feedback: '制度の穴を突いて費用を削減' }
            ]
        },
        {
            id: 'skill_laugh_therapy',
                series: 'skill',
            title: '笑いヨガで売上3倍セミナー',
            description: '「1日笑えば売上3倍」と講師が豪語。社長が社内全員に受講させようとしている。',
                choices: [
                { text: '全力で笑いながら議事録を作る', effect: { stress: 4, communication: 3, shachi: 200 }, feedback: '終わった頃には顎が痛い' },
                { text: '効果計測のアンケートを自ら実施', effect: { knowledge: 5, shachi: 250 }, feedback: '根拠を示し受講回数を削減' },
                { text: '営業向けに実践編をアレンジし成果を可視化', effect: { knowledge: 4, communication: 4, shachi: 270 }, feedback: '社長のご機嫌を取った' },
                { text: '代替として科学的ストレスケア研修を提案', effect: { knowledge: 4, shachi: 230 }, feedback: 'こっそり真面目な研修へ誘導' }
            ]
        },
        {
            id: 'skill_future_sound',
                series: 'skill',
            title: '周波数で潜在能力を開く講座',
            description: '説明会で配られたのは謎の金属棒。「デスクに置くだけで集中力がMAX」だという。',
                choices: [
                { text: '棒を分解して仕組みを調査', effect: { knowledge: 5, stress: 1, shachi: 240 }, feedback: 'ただの風鈴だと判明' },
                { text: '上司の席に置いて効果検証', effect: { communication: 3, stress: 2, shachi: 210 }, feedback: '気休めアイテムとして採用' },
                { text: '産業医に相談して正式な評価を求める', effect: { knowledge: 4, shachi: 230 }, feedback: '安全上の理由で導入見送りに' },
                { text: '棒を活用したタイマーアプリを勝手に開発', effect: { knowledge: 5, communication: 3, shachi: 260 }, feedback: '社内ツールとして配布' }
            ]
        },
        {
            id: 'skill_remote_retreat',
                series: 'skill',
            title: '砂漠リトリートでキャリア設計',
            description: '「電波なしで1週間。ラップトップ禁止。」人事が本気で全員を送り込もうとしている。',
                choices: [
                { text: '代わりに社内で48時間ハッカソンを企画', effect: { knowledge: 5, shachi: 260 }, feedback: '実務的代替案で予定が変更に' },
                { text: '安全面のリスクをまとめて提言', effect: { knowledge: 4, communication: 3, shachi: 230 }, feedback: '現実的なリスク管理で評価UP' },
                { text: '自腹で参加してSNSで実況', effect: { physical: -4, stress: 5, shachi: -300 }, feedback: 'フォロワーは増えたが精神が限界' },
                { text: '現地で必要な許可証や予算を算出し上層部に提示', effect: { knowledge: 5, shachi: 250 }, feedback: '費用が高すぎて自然消滅' }
                ]
            },
            {
                id: 'skill_nlp_seminar',
                series: 'skill',
                title: '高額NLPセミナーの勧誘',
                description: '上司から「部下が変わった！人間関係が激変した奇跡のNLP」セミナーの紹介。料金12万円、社費で半分負担。残りは自己負担で土日2日間コース。',
                choices: [
                    { text: '「ぜひ参加させてください」', effect: { communication: 2, knowledge: 1, shachi: -600 }, feedback: 'ポジティブ思考は身についたが、財布は寂しい' },
                    { text: '「本で勉強してみます」', effect: { knowledge: 3, shachi: 90 }, feedback: '自己学習で十分。コストパフォーマンス重視' },
                    { text: '「効果が実証されたものか確認します」', effect: { knowledge: 4, shachi: 100 }, feedback: '科学的根拠を調べる習慣。判断力向上' },
                    { text: '「今は他に必要な資格があります」', effect: { communication: 3, shachi: 70 }, feedback: '優先順位を明確化。現実的な選択' }
                ]
            },
            {
                id: 'skill_powerpoint_hell',
                series: 'skill',
                title: 'ひたすらパワポ資料作り',
                description: '上司「全社共有のプレゼン資料作りまくって。デザイン凝って。アニメーション入れて。全部手戻りさせて作り直し。参考資料なし。期日は今日。',
                choices: [
                    { text: '徹夜で全ページ完璧に仕上げる', effect: { knowledge: 2, shachi: 80 }, feedback: '資料作成マスター。でも睡眠は...' },
                    { text: '簡潔な内容で間に合わせる', effect: { knowledge: 3, shachi: 90 }, feedback: '効率重視で完成。ポイントを押さえた' },
                    { text: '「テンプレートで代用できますか？」', effect: { communication: 2, shachi: 70 }, feedback: '提案力が身につく' },
                    { text: '『参考資料をいただけますか』', effect: { knowledge: 4, shachi: 100 }, feedback: '情報収集力と交渉力が鍛えられた' }
                ]
            },
            {
                id: 'skill_random_questions',
                series: 'skill',
                title: '謎のテスト勉強会',
                description: '「来週の業務テスト全員満点で！」内容は業務と無関係な雑学問題。「会社に愛着を持ってもらうため」という名目の強制参加。勉強時間は業務時間外。',
                choices: [
                    { text: '徹夜で暗記して満点を取る', effect: { knowledge: 1, physical: -2, shachi: 60 }, feedback: '記憶力は上がった。でも体は...' },
                    { text: '「実務に必要な知識だけ優先します」', effect: { knowledge: 3, shachi: 80 }, feedback: '優先順位をつける力が向上' },
                    { text: '「このテストの意義を教えてください」', effect: { communication: 3, shachi: 90 }, feedback: '批判的思考で建設的に質問' },
                    { text: '「業務に集中したいです」', effect: { physical: 2, knowledge: 1, shachi: 70 }, feedback: '明確に意思表示。自己主張力がついた' }
                ]
            }
        ];

        // ボスイベント（役職昇格試験）- 4択形式で正解は1つのみ
        const BOSS_EVENTS = [
            {
                id: 'boss_rank_1',
                title: '係長昇格試験：朝礼の立ち振る舞い',
                description: '全社オンライン朝礼で、新人が資料を共有し忘れてパニック中。社畜として「波風を立てずに仕事だけ前に進める」最適解は？',
                icon: '📢',
                participationCost: 500,
                requiredRank: 1,
                correctAnswerIndex: 2,
                choices: [
                    { text: '「え、聞こえてません」と全員の前で指摘する', effect: { stress: -10, communication: -20, shachi: -500 }, feedback: '❌ 失敗：空気を凍らせた' },
                    { text: 'チャットで「聞こえます？」を連投する', effect: { stress: -5, knowledge: -5, shachi: -500 }, feedback: '❌ 失敗：騒音源になった' },
                    { text: '新人の画面を共有で支援しつつ、何事もなかった顔で進行', effect: { stress: 30, knowledge: 35, communication: 40, shachi: -500 }, feedback: '✅ 正解：陰徳を積むのが社畜の正義' },
                    { text: '会議を切断して様子を見る', effect: { stress: -30, knowledge: -15, shachi: -500 }, feedback: '❌ 失敗：逃げ癖を見抜かれた' }
                ]
            },
            {
                id: 'boss_rank_2',
                title: '主任昇格試験：終わらないCC地獄',
                description: '上司から「念のためCC」で毎日300通。社畜主任として一番平和的に処理する方法は？',
                icon: '📨',
                participationCost: 800,
                requiredRank: 2,
                correctAnswerIndex: 0,
                choices: [
                    { text: '要点だけ毎朝3行にまとめて上司へ献上', effect: { stress: 35, knowledge: 40, communication: 45, shachi: -800 }, feedback: '✅ 正解：社畜要約術で好感度UP' },
                    { text: 'フィルタで全部削除する', effect: { stress: -25, knowledge: -30, shachi: -800 }, feedback: '❌ 失敗：重要メールも消滅' },
                    { text: 'CC全員に「返信不要です」と送り返す', effect: { stress: -20, communication: -35, shachi: -800 }, feedback: '❌ 失敗：逆ギレ上司爆誕' },
                    { text: '深夜にまとめて既読だけ付ける', effect: { stress: -10, physical: -15, shachi: -800 }, feedback: '❌ 失敗：働き方改革とは' }
                ]
            },
            {
                id: 'boss_rank_3',
                title: '課長代理昇格試験：社畜あるあるクレーム',
                description: '顧客「御社の他部署がミスしたので今すぐ謝罪して」。社畜は部門を超えて土下座すべきか？',
                icon: '🙏',
                participationCost: 1200,
                requiredRank: 3,
                correctAnswerIndex: 1,
                choices: [
                    { text: '「うちの部署じゃないので」と即座に転送', effect: { stress: -35, communication: -45, shachi: -1200 }, feedback: '❌ 失敗：社畜の連帯感ゼロ' },
                    { text: 'まず謝罪→社内で原因特定→改善案まで添えて顧客に逆提案', effect: { stress: 40, knowledge: 55, communication: 50, shachi: -1200 }, feedback: '✅ 正解：誰の尻拭いでも完走するのが社畜' },
                    { text: '顧客と一緒に他部署へ怒鳴りに行く', effect: { stress: 20, physical: -20, shachi: -1200 }, feedback: '❌ 失敗：対立を拡大した' },
                    { text: 'すべてのメールに上層部をCCして様子見', effect: { stress: -15, knowledge: -25, shachi: -1200 }, feedback: '❌ 失敗：火に油' }
                ]
            },
            {
                id: 'boss_rank_4',
                title: '課長昇格試験：ブラック会議の生存術',
                description: '議題不明・終了未定の会議に呼ばれた。課長候補として正しい振る舞いは？',
                icon: '🕘',
                participationCost: 1500,
                requiredRank: 4,
                correctAnswerIndex: 2,
                choices: [
                    { text: 'ノートPCを閉じ、静かに精神統一', effect: { stress: -40, knowledge: -25, shachi: -1500 }, feedback: '❌ 失敗：寝てると思われた' },
                    { text: '毎回「それってKPIですか？」と聞きまくる', effect: { stress: 10, communication: -20, shachi: -1500 }, feedback: '❌ 失敗：煙たがられた' },
                    { text: '勝手に議事メモを取り、決定事項とToDoを配布して終了宣言', effect: { stress: 55, knowledge: 60, communication: 60, shachi: -1500 }, feedback: '✅ 正解：会議を畳める社畜は神' },
                    { text: '退室して別の仕事を優先', effect: { stress: -30, knowledge: -30, shachi: -1500 }, feedback: '❌ 失敗：消えた課長候補' }
                ]
            },
            {
                id: 'boss_rank_5',
                title: '部長代理昇格試験：終電ダッシュの采配',
                description: '大型案件の最終日。メンバーは終電ギリギリ。部長代理候補としてどう動く？',
                icon: '🚇',
                participationCost: 2000,
                requiredRank: 5,
                correctAnswerIndex: 3,
                choices: [
                    { text: '「帰れる人から帰って」と言いつつ自分だけ帰る', effect: { stress: -50, communication: -60, shachi: -2000 }, feedback: '❌ 失敗：信頼ゼロ' },
                    { text: '夜明けまで根性論で鼓舞', effect: { stress: 60, physical: -50, shachi: -2000 }, feedback: '❌ 失敗：離職予備軍が増えた' },
                    { text: 'タクシー代で解決', effect: { stress: 40, knowledge: 20, shachi: -2600 }, feedback: '❌ 失敗：コスト感覚皆無' },
                    { text: '残タスクを即分解→優先順位付け→リモート待機組へ再配分', effect: { stress: 70, knowledge: 85, communication: 80, shachi: -2000 }, feedback: '✅ 正解：社畜は配車より配分' }
                ]
            },
            {
                id: 'boss_rank_6',
                title: '部長昇格試験：社畜プレゼン術',
                description: '取締役会で5分だけプレゼンすることに。社畜流の勝ち筋は？',
                icon: '📊',
                participationCost: 2500,
                requiredRank: 6,
                correctAnswerIndex: 0,
                choices: [
                    { text: '質問を先回りし「ご懸念は３点です」と指摘潰しを宣言', effect: { stress: 80, knowledge: 90, communication: 85, shachi: -2500 }, feedback: '✅ 正解：社畜は質問時間を短縮して褒められる' },
                    { text: 'とにかくスライドを読み上げる', effect: { stress: -60, knowledge: -70, shachi: -2500 }, feedback: '❌ 失敗：寝かしつけ成功' },
                    { text: 'ジョークを連発して場を和ませる', effect: { communication: 40, stress: 10, shachi: -2500 }, feedback: '❌ 失敗：ここはお笑いライブではない' },
                    { text: '資料は当日朝に作る', effect: { stress: -30, knowledge: -40, shachi: -2500 }, feedback: '❌ 失敗：社畜タイムマネジメント崩壊' }
                ]
            },
            {
                id: 'boss_rank_7',
                title: '事業部長代理昇格試験：社畜飲み会の心得',
                description: '突然の「明日オンライン飲み！全員強制参加」の通知。正しい社畜ムーブは？',
                icon: '🍺',
                participationCost: 3000,
                requiredRank: 7,
                correctAnswerIndex: 2,
                choices: [
                    { text: '無視してログアウト', effect: { stress: -70, communication: -80, shachi: -3000 }, feedback: '❌ 失敗：冷酷無情' },
                    { text: '全員分のUberを手配', effect: { stress: 50, knowledge: 10, shachi: -3600 }, feedback: '❌ 失敗：出費で自滅' },
                    { text: '開始15分で乾杯＆議題回収→30分で「次は仕事WBSです」で締める', effect: { stress: 85, knowledge: 95, communication: 90, shachi: -3000 }, feedback: '✅ 正解：飲み会も案件化するのが社畜' },
                    { text: '延々と愚痴を聞き役に徹する', effect: { stress: 30, physical: -30, shachi: -3000 }, feedback: '❌ 失敗：翌朝ダウン' }
                ]
            },
            {
                id: 'boss_rank_8',
                title: '事業部長昇格試験：社畜資料の魔改造',
                description: '「社長が分かる資料」に10分で変えろと言われた。どうする？',
                icon: '📑',
                participationCost: 3500,
                requiredRank: 8,
                correctAnswerIndex: 1,
                choices: [
                    { text: 'スライドを全部捨ててゼロから作る', effect: { stress: 100, knowledge: 80, shachi: -3500 }, feedback: '❌ 失敗：間に合わない' },
                    { text: '1枚目にサマリー・2枚目に数字・最後にお願い事だけ残す', effect: { stress: 95, knowledge: 110, communication: 105, shachi: -3500 }, feedback: '✅ 正解：社畜資料は3枚まで' },
                    { text: 'グラフを虹色にして視覚訴求する', effect: { stress: 40, knowledge: 15, shachi: -3500 }, feedback: '❌ 失敗：情報ゼロ' },
                    { text: '自動翻訳で英語にする', effect: { stress: 20, knowledge: -20, shachi: -3500 }, feedback: '❌ 失敗：誰も読めない' }
                ]
            },
            {
                id: 'boss_rank_9',
                title: '本部長代理昇格試験：社畜パワポ大喜利',
                description: '経営陣「とりあえず“攻めのDX”っぽい資料を明日欲しい」。社畜的正解は？',
                icon: '🧠',
                participationCost: 4000,
                requiredRank: 9,
                correctAnswerIndex: 0,
                choices: [
                    { text: '社内の成功事例を3つストック→流行語を上書き→現実的ロードマップを添える', effect: { stress: 105, knowledge: 120, communication: 115, shachi: -4000 }, feedback: '✅ 正解：中身3割・安心感7割で突破' },
                    { text: 'ChatGPTに丸投げ', effect: { stress: -60, knowledge: -70, shachi: -4000 }, feedback: '❌ 失敗：コピペ感MAX' },
                    { text: 'DXの定義から語り始める', effect: { stress: 30, knowledge: 40, shachi: -4000 }, feedback: '❌ 失敗：長い' },
                    { text: '資料ではなく詩を書いて提出', effect: { stress: -80, communication: -90, shachi: -4000 }, feedback: '❌ 失敗：芸術点ゼロ' }
                ]
            },
            {
                id: 'boss_rank_10',
                title: '本部長昇格試験：社畜KPIの調教',
                description: 'KPIが20個ある部門。社畜本部長としてどうやって上層部を納得させる？',
                icon: '🎯',
                participationCost: 4500,
                requiredRank: 10,
                correctAnswerIndex: 3,
                choices: [
                    { text: '全部まとめて「そのうちやります」', effect: { stress: -90, knowledge: -110, shachi: -4500 }, feedback: '❌ 失敗：抽象パワー不足' },
                    { text: '各KPIごとに担当者へ丸投げ', effect: { stress: -80, communication: -70, shachi: -4500 }, feedback: '❌ 失敗：統制不能' },
                    { text: 'KPIを倍に増やしインパクト演出', effect: { stress: 20, knowledge: 10, shachi: -4500 }, feedback: '❌ 失敗：数だけの地獄' },
                    { text: '3つの経営指標に束ね、残りはサブKPIとしてダッシュボード化', effect: { stress: 115, knowledge: 130, communication: 125, shachi: -4500 }, feedback: '✅ 正解：KPIを調教するのも社畜の嗜み' }
                ]
            },
            {
                id: 'boss_rank_11',
                title: '常務昇格試験：社畜の昼休み',
                description: '役員会議が昼休みをまたいだ。常務候補としてどの姿勢が評価される？',
                icon: '🍱',
                participationCost: 5000,
                requiredRank: 11,
                correctAnswerIndex: 1,
                choices: [
                    { text: '「休憩しましょう」と堂々提案', effect: { stress: -120, communication: -130, shachi: -5000 }, feedback: '❌ 失敗：空気が読めない' },
                    { text: '資料を配布しながらおにぎりを差し入れ、会議を進める', effect: { stress: 125, knowledge: 140, communication: 135, shachi: -5000 }, feedback: '✅ 正解：社畜は炭水化物で議事を進める' },
                    { text: '席を外してしっかり昼寝', effect: { stress: -60, physical: 10, shachi: -5000 }, feedback: '❌ 失敗：戻ったら決定済み' },
                    { text: 'Slackでランチ写真を投稿', effect: { stress: -80, knowledge: -90, shachi: -5000 }, feedback: '❌ 失敗：炎上' }
                ]
            },
            {
                id: 'boss_rank_12',
                title: '専務昇格試験：社畜の謝罪会見',
                description: '不具合リリースで炎上。専務候補としてマスコミ対応を任された。どう演じる？',
                icon: '📺',
                participationCost: 6000,
                requiredRank: 12,
                correctAnswerIndex: 0,
                choices: [
                    { text: '全責任は当社にあると宣言→再発防止策&数字付きロードマップを披露', effect: { stress: 135, knowledge: 150, communication: 145, shachi: -6000 }, feedback: '✅ 正解：土下座より計画' },
                    { text: '開発ベンダーのせいにする', effect: { stress: -140, communication: -150, shachi: -6000 }, feedback: '❌ 失敗：炎上継続' },
                    { text: 'とりあえず深くお辞儀して終わる', effect: { stress: 40, knowledge: 5, shachi: -6000 }, feedback: '❌ 失敗：中身ゼロ' },
                    { text: 'SNSでライブ配信', effect: { stress: -100, knowledge: -120, shachi: -6000 }, feedback: '❌ 失敗：コメント欄が地獄' }
                ]
            },
            {
                id: 'boss_rank_13',
                title: '副社長昇格試験：社畜の退職慰留',
                description: '有能部下が「辞めます」と宣言。副社長候補として最も社畜らしい動きは？',
                icon: '📝',
                participationCost: 7000,
                requiredRank: 13,
                correctAnswerIndex: 2,
                choices: [
                    { text: '「好きにしたら？」と即答', effect: { stress: -120, communication: -140, shachi: -7000 }, feedback: '❌ 失敗：冷酷無情' },
                    { text: 'とにかく給与を釣り上げる', effect: { stress: 60, knowledge: 40, shachi: -9000 }, feedback: '❌ 失敗：財務崩壊' },
                    { text: '本人のキャリアプランを一緒に更新し、半年の越境ミッションを提示', effect: { stress: 145, knowledge: 160, communication: 155, shachi: -7000 }, feedback: '✅ 正解：社畜の情と理で引き留め成功' },
                    { text: '退職届を紛失したフリをする', effect: { stress: -80, knowledge: -90, shachi: -7000 }, feedback: '❌ 失敗：信頼失墜' }
                ]
            },
            {
                id: 'boss_rank_14',
                title: '社長昇格試験：社畜の最後の選択',
                description: '巨大プロジェクトが炎上中。社長候補として「社畜として正しい未来」を示せ。',
                icon: '👑',
                participationCost: 10000,
                requiredRank: 14,
                correctAnswerIndex: 1,
                choices: [
                    { text: '全責任を中間管理職に押し付ける', effect: { stress: -200, communication: -180, shachi: -10000 }, feedback: '❌ 失敗：社畜の頂点にはなれない' },
                    { text: '顧客・従業員・株主の損失を同時に最小化する撤退＋再挑戦プランを提示', effect: { stress: 200, knowledge: 200, communication: 200, shachi: -10000 }, feedback: '✅ 正解：社畜哲学の完成形' },
                    { text: '炎上を無視して新規事業を語る', effect: { stress: -190, knowledge: -170, shachi: -10000 }, feedback: '❌ 失敗：現実逃避' },
                    { text: 'SNSで謝罪だけして終わる', effect: { stress: -150, knowledge: -160, shachi: -10000 }, feedback: '❌ 失敗：実行力ゼロ' }
                ]
            }
        ];

        // ボス試験では参加費でシャチを消費するため、選択肢の効果からシャチ変動を排除
        BOSS_EVENTS.forEach(event => {
            event.choices.forEach(choice => {
                if (choice.effect && typeof choice.effect === 'object' && 'shachi' in choice.effect) {
                    delete choice.effect.shachi;
                }
            });
        });
        const BOSS_EVENT_MAP = Object.fromEntries(BOSS_EVENTS.map(event => [event.id, event]));
        const BOSS_EVENT_STAT_GAIN_SCALE = 0.35;

        // メインストーリーイベント
        const MAIN_STORY_EVENTS = [
            {
                id: 'main_story_01',
                title: '係長への最終試験',
                description: '「係長になりたければ、この難題を乗り越えろ」上司が厳しい目で告げた。超過酷なプロジェクト、理不尽な要求、そして燃え尽きるまでの労働。あなたの社畜としての心意気が試される時が来た。',
                icon: '🔥',
                participationCost: 500,
                requiredRank: 1,
                choices: [
                    { text: '昼夜問わず働き抜く', effect: { stress: 25, knowledge: 30, physical: -15, shachi: -500 }, feedback: '超人的な努力で試験を突破。だが体は限界...' },
                    { text: '効率化を追求して突破', effect: { knowledge: 40, stress: 20, shachi: -500 }, feedback: '戦略的思考で難題を解決。知識が飛躍的に向上！' },
                    { text: 'チームを操って乗り切る', effect: { communication: 35, knowledge: 25, stress: 30, shachi: -500 }, feedback: 'チームマネジメントで成功。しかし社畜として更に深く...' },
                    { text: '今回は見送る', effect: { stress: -5, shachi: 0 }, feedback: '死を避けた。だが挑戦する勇気を失った。' }
                ]
            },
            {
                id: 'main_story_02',
                title: '課長への地獄の試練',
                description: '課長の座は甘くない。365日24時間体制の管理責任、部下の失敗は全てあなたの責任、そして上層部からの理不尽な圧力。あなたの心身はどこまで耐えられるか？真の社畜の証明が今始まる。',
                icon: '🔥',
                participationCost: 1000,
                requiredRank: 2,
                choices: [
                    { text: '全てを犠牲にして合格', effect: { stress: 40, knowledge: 50, communication: 40, physical: -30, shachi: -1000 }, feedback: '課長の座を勝ち取った。だが失ったものは計り知れない...' },
                    { text: '部下を人柱にして昇格', effect: { communication: 60, stress: 50, shachi: -1000 }, feedback: '冷酷な戦略で成功。マネジメント能力は頂点に達した。' },
                    { text: '完璧主義で全てを成し遂げる', effect: { knowledge: 70, stress: 35, physical: -20, shachi: -1000 }, feedback: '完璧な遂行力で課長就任。しかし完璧主義の呪縛が...' },
                    { text: '降参する', effect: { physical: 20, stress: -10, shachi: 0 }, feedback: '潔く降参。自分の限界を受け入れた。' }
                ]
            },
            {
                id: 'main_story_03',
                title: '部長への煉獄',
                description: 'ここから先は地上の話ではない。部長の椅子は血に染まった鋼鉄製だ。組織全体の運命を背負い、社畜界の頂点を目指す者だけが辿り着ける領域。あなたはその資格があるのか？肉体と精神の完全破壊と引き換えに、超人になれる。',
                icon: '☠️',
                participationCost: 2000,
                requiredRank: 3,
                choices: [
                    { text: '死の覚悟で挑む', effect: { stress: 60, knowledge: 80, communication: 70, physical: -50, shachi: -2000 }, feedback: '煉獄を生き延びた。部長として人間を超えた。だが人としての心は...' },
                    { text: '組織を支配して頂点へ', effect: { communication: 90, knowledge: 70, stress: 55, physical: -40, shachi: -2000 }, feedback: '圧倒的な支配力で部長就任。あなたはもう人間ではない。' },
                    { text: '全てを計算して成功', effect: { knowledge: 100, communication: 80, stress: 50, shachi: -2000 }, feedback: '完璧な戦略で部長の座を掴む。超人的知性の体現者となった。' },
                    { text: '恐怖に屈する', effect: { physical: 30, communication: 20, shachi: 0 }, feedback: '恐怖に負けた。だが人間としての尊厳は保った。' }
                ]
            },
            {
                id: 'main_story_04',
                title: '本部長への絶頂',
                description: '社畜としての究極形態。本部長は神に最も近い存在だ。全社を支配し、無数の社畜をコントロールし、組織の根幹を動かす。しかしこの位に就くには、人間であることを完全に放棄し、組織という機械の歯車になる覚悟がいる。あなたは本当にこの頂点を目指すのか？',
                icon: '👑',
                participationCost: 5000,
                requiredRank: 4,
                choices: [
                    { text: '完璧な社畜神となる', effect: { stress: 100, knowledge: 150, communication: 150, physical: -80, shachi: -5000 }, feedback: 'あなたは神となった。完璧な社畜の最終形態。人間という存在を超越した。' },
                    { text: '支配者として君臨', effect: { communication: 180, knowledge: 130, stress: 80, physical: -60, shachi: -5000 }, feedback: '絶対的な支配者となった。全てを操る存在として君臨する。' },
                    { text: '知の巨人として統括', effect: { knowledge: 200, communication: 140, stress: 70, shachi: -5000 }, feedback: '究極の知性を獲得。全てを見通す存在となった。' },
                    { text: '最後の理性で拒否', effect: { physical: 100, knowledge: 50, communication: 50, shachi: 0 }, feedback: '人間としての最後の尊厳を守った。あなたは人間でいることを選んだ。' }
                ]
            }
        ];

        // メインストーリーも参加費を別途要求するため、効果内のシャチ増減をクリア
        MAIN_STORY_EVENTS.forEach(event => {
            event.choices.forEach(choice => {
                if (choice.effect && typeof choice.effect === 'object' && 'shachi' in choice.effect) {
                    delete choice.effect.shachi;
                }
            });
        });

        // 役職システム（14レベル）
        const RANK_SYSTEM = [
            { rank: 0, name: '平社員', requiredStats: { stress: 0, knowledge: 0, physical: 0, communication: 0 } },
            { rank: 1, name: '係長', requiredStats: { stress: 50, knowledge: 50, physical: 50, communication: 50 } },
            { rank: 2, name: '主任', requiredStats: { stress: 100, knowledge: 100, physical: 100, communication: 100 } },
            { rank: 3, name: '課長代理', requiredStats: { stress: 150, knowledge: 150, physical: 150, communication: 150 } },
            { rank: 4, name: '課長', requiredStats: { stress: 200, knowledge: 200, physical: 200, communication: 200 } },
            { rank: 5, name: '部長代理', requiredStats: { stress: 250, knowledge: 250, physical: 250, communication: 250 } },
            { rank: 6, name: '部長', requiredStats: { stress: 300, knowledge: 300, physical: 300, communication: 300 } },
            { rank: 7, name: '事業部長代理', requiredStats: { stress: 350, knowledge: 350, physical: 350, communication: 350 } },
            { rank: 8, name: '事業部長', requiredStats: { stress: 400, knowledge: 400, physical: 400, communication: 400 } },
            { rank: 9, name: '本部長代理', requiredStats: { stress: 450, knowledge: 450, physical: 450, communication: 450 } },
            { rank: 10, name: '本部長', requiredStats: { stress: 500, knowledge: 500, physical: 500, communication: 500 } },
            { rank: 11, name: '常務', requiredStats: { stress: 550, knowledge: 550, physical: 550, communication: 550 } },
            { rank: 12, name: '専務', requiredStats: { stress: 600, knowledge: 600, physical: 600, communication: 600 } },
            { rank: 13, name: '副社長', requiredStats: { stress: 650, knowledge: 650, physical: 650, communication: 650 } },
            { rank: 14, name: '社長', requiredStats: { stress: 700, knowledge: 700, physical: 700, communication: 700 } }
        ];

        // ランク別の動画・機能定義
        const RANK_REWARDS = {
            0: { type: 'video', videoPath: '20_movie/01_紹介動画/intro.mp4', title: '紹介動画', unlock: false },
            1: { type: 'video', videoPath: '20_movie/02_特別動画1/special1.mp4', title: '特別動画1', unlock: false },
            2: { type: 'video', videoPath: '20_movie/03_特別動画2/special2.mp4', title: '特別動画2', unlock: false },
            3: { type: 'none' },
            4: { type: '3d_icon', unlock: true },
            5: { type: 'none' },
            6: { type: 'video', videoPath: '20_movie/04_3D動画1/3d1.mp4', title: '3D動画1', unlock: false },
            7: { type: 'none' },
            8: { type: 'video', videoPath: '20_movie/05_3D動画2/3d2.mp4', title: '3D動画2', unlock: false },
            9: { type: 'none' },
            10: { type: 'video', videoPath: '20_movie/06_3D動画3/3d3.mp4', title: '3D動画3', unlock: false }
        };

        const CHARACTERS = [
            { id: 'ikisui', name: '生粋の社畜', icon: '001.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'genkai', name: '限界突破社畜', icon: '002.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'muhai', name: '無敗の職人社畜', icon: '003.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'kokou', name: '孤高の成果主義社畜', icon: '004.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'kokoro', name: '心優しき社畜', icon: '005.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'seijitsu', name: '誠実な観察社員', icon: '006.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'kyousou', name: '共創リーダー社員', icon: '007.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'mypace', name: 'マイペース社員', icon: '008.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'yurufuwa', name: 'ゆるふわ社畜', icon: '009.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'kakure', name: '隠れ疲労社畜', icon: '010.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'ohitoyoshi', name: 'お人好し社員', icon: '011.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'genjitsu', name: '現実派社員', icon: '012.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'katei', name: '家庭が大事社員', icon: '013.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'balancer', name: 'バランサー社員', icon: '014.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'seika', name: '成果最適化社畜', icon: '015.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } },
            { id: 'jiyujin', name: '自由人', icon: '016.png', baseStats: { stress: 30, knowledge: 30, physical: 30, communication: 30 } }
        ];

        const THREE_D_ICON_UNLOCK_RANK = 6; // 部長
        const CHARACTER_3D_ICON_MAP = {
            ikisui: '11_３Dアイコン/01_3D.png',
            genkai: '11_３Dアイコン/02_3D.png',
            muhai: '11_３Dアイコン/03_3D.png',
            kokou: '11_３Dアイコン/04_3D.png',
            kokoro: '11_３Dアイコン/05_3D.png',
            seijitsu: '11_３Dアイコン/06_3D.png',
            kyousou: '11_３Dアイコン/07_3D.png',
            mypace: '11_３Dアイコン/08_3D.png',
            yurufuwa: '11_３Dアイコン/09_3D.png',
            kakure: '11_３Dアイコン/10_3D.png',
            ohitoyoshi: '11_３Dアイコン/11_3D.png',
            genjitsu: '11_３Dアイコン/12_3D.png',
            katei: '11_３Dアイコン/13_3D.png',
            balancer: '11_３Dアイコン/14_3D.png',
            seika: '11_３Dアイコン/15_3D.png',
            jiyujin: '11_３Dアイコン/16_3D.png'
        };

        // 習慣トラッカーデータ
        const HABIT_TRACKER_ITEMS = [
            { id: 'early_bed', icon: '🌙', icon2: '🌅', name: '早寝起' },
            { id: 'exercise', icon: '🏋️', icon2: '💪', name: '運動' },
            { id: 'journal', icon: '📔', icon2: '✍️', name: '日記' },
            { id: 'study', icon: '📚', icon2: '✏️', name: '勉強' },
            { id: 'read', icon: '📖', icon2: '👓', name: '読書' },
            { id: 'no_alcohol', icon: '🚫', icon2: '🍺', name: 'No酒' }
        ];
        
        let currentWeekOffset = 0; // 現在の週オフセット
        let habitTrackerData = {}; // { '2024-10-27': { 'early_bed': true, ... }, ... }
        
        // 現在の週の日付範囲を取得（日本時間ベース）
        function getCurrentWeekDates() {
            const today = getJSTDate(); // 日本時間で今日の日付を取得
            const currentDay = today.getDay(); // 0=日曜日, 1=月曜日, ...
            const monday = new Date(today);
            monday.setDate(today.getDate() - currentDay + 1); // 月曜日に調整
            
            // 週オフセットを適用
            monday.setDate(monday.getDate() + (currentWeekOffset * 7));
            
            const dates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                dates.push(date);
            }
            
            return dates;
        }
        
        // 日本時間（JST）で現在の日付を取得
        function getJSTDate() {
            const now = new Date();
            // UTC時刻を取得してJST（UTC+9）に変換
            const jstOffset = 9 * 60; // JSTはUTC+9時間
            const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
            const jst = new Date(utc + (jstOffset * 60000));
            return jst;
        }
        
        // 日付をYYYY-MM-DD形式に変換（日本時間ベース）
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // 日本時間で今日の日付文字列を取得（日付比較用）
        function getJSTDateString() {
            const jstDate = getJSTDate();
            return jstDate.toDateString();
        }
        
        // 週を変更
        function changeWeek(delta) {
            currentWeekOffset += delta;
            renderHabitTracker();
        }
        
        // 習慣トラッカーを描画
        function renderHabitTracker() {
            const dates = getCurrentWeekDates();
            
            // 週の範囲を更新
            const startDate = dates[0];
            const endDate = dates[6];
            const startStr = `${startDate.getMonth() + 1}/${startDate.getDate()}`;
            const endStr = `${endDate.getMonth() + 1}/${endDate.getDate()}`;
            document.getElementById('week-range').textContent = `${startStr} - ${endStr}`;
            
            // グリッドを作成
            const grid = document.getElementById('habit-tracker-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            // 今日の日付を取得
            const today = getJSTDate();
            const todayDateStr = formatDate(today);
            
            // 表示している週の中に「今日」が含まれているか、そのインデックスを取得
            let todayIndex = -1;
            dates.forEach((date, index) => {
                if (formatDate(date) === todayDateStr) {
                    todayIndex = index;
                }
            });
            
            // ヘッダー1行目（項目＋曜日）
            const headerRow1 = document.createElement('div');
            headerRow1.className = 'habit-grid-row header-row';
            headerRow1.innerHTML = `
                <div class="habit-item-name header">項目</div>
                <div class="habit-day-header header ${todayIndex === 0 ? 'today' : ''}">月</div>
                <div class="habit-day-header header ${todayIndex === 1 ? 'today' : ''}">火</div>
                <div class="habit-day-header header ${todayIndex === 2 ? 'today' : ''}">水</div>
                <div class="habit-day-header header ${todayIndex === 3 ? 'today' : ''}">木</div>
                <div class="habit-day-header header ${todayIndex === 4 ? 'today' : ''}">金</div>
                <div class="habit-day-header header ${todayIndex === 5 ? 'today' : ''}">土</div>
                <div class="habit-day-header header ${todayIndex === 6 ? 'today' : ''}">日</div>
                <div class="habit-week-total header">週</div>
                <div class="habit-total header">計</div>
            `;
            grid.appendChild(headerRow1);
            
            // ヘッダー2行目（空＋日付）
            const headerRow2 = document.createElement('div');
            headerRow2.className = 'habit-grid-row date-row';
            headerRow2.innerHTML = `
                <div class="habit-item-name"></div>
                ${dates.map((date, index) => {
                    const dayNum = date.getDate();
                    const isToday = index === todayIndex;
                    return `<div class="habit-day-header ${isToday ? 'today' : ''}" 
                             style="font-weight: 400;">
                        ${dayNum}
                    </div>`;
                }).join('')}
                <div class="habit-week-total"></div>
                <div class="habit-total"></div>
            `;
            grid.appendChild(headerRow2);
            
            // 各習慣の行を作成
            HABIT_TRACKER_ITEMS.forEach(habit => {
                const row = document.createElement('div');
                row.className = 'habit-grid-row';
                
                let weekTotal = 0;
                let allTotal = 0;
                
                // 週計を計算（現在の週のみ）
                dates.forEach(date => {
                    const dateStr = formatDate(date);
                    if (habitTrackerData[dateStr] && habitTrackerData[dateStr][habit.id]) {
                        weekTotal++;
                    }
                });
                
                // 合計を計算（全期間）
                Object.keys(habitTrackerData).forEach(dateStr => {
                    if (habitTrackerData[dateStr] && habitTrackerData[dateStr][habit.id]) {
                        allTotal++;
                    }
                });
                
                const dayCells = dates.map((date, index) => {
                    const dateStr = formatDate(date);
                    const isChecked = habitTrackerData[dateStr] && habitTrackerData[dateStr][habit.id];
                    const isToday = index === todayIndex;
                    
                    return `<div class="habit-day-cell ${isChecked ? 'checked' : ''} ${isToday ? 'today-column' : ''}" 
                                onclick="toggleHabit('${dateStr}', '${habit.id}')">
                                <input type="checkbox" ${isChecked ? 'checked' : ''} />
                            </div>`;
                }).join('');
                
                row.innerHTML = `
                    <div class="habit-item-name">
                        ${habit.name}
                    </div>
                    ${dayCells}
                    <div class="habit-week-total">${weekTotal}</div>
                    <div class="habit-total">${allTotal}</div>
                `;
                grid.appendChild(row);
            });
            
            // 凡例を作成
            renderLegend();
        }
        
        // 詳細を描画
        function renderLegend() {
            const legend = document.getElementById('legend-items');
            if (!legend) return;
            
            legend.innerHTML = HABIT_TRACKER_ITEMS.map(habit => 
                `<div class="legend-item">${habit.icon}${habit.icon2 || ''} <small>${habit.name}</small></div>`
            ).join('');
        }
        // 習慣をトグル
        function toggleHabit(dateStr, habitId) {
            if (!habitTrackerData[dateStr]) {
                habitTrackerData[dateStr] = {};
            }
            
            habitTrackerData[dateStr][habitId] = !habitTrackerData[dateStr][habitId];
            
            // ローカルストレージに保存
            saveHabitTrackerData();
            
            // 再描画
            renderHabitTracker();
            
            // メイン画面更新
            updateMainScreen();
        }
        
        const HABIT_LOCAL_KEY_BASE = 'shachipoke2_habits';

        function getHabitLocalKey(userIdOverride) {
            const resolvedUserId = typeof userIdOverride === 'string' ? userIdOverride : currentUser?.id;
            return resolvedUserId ? `${HABIT_LOCAL_KEY_BASE}_${resolvedUserId}` : HABIT_LOCAL_KEY_BASE;
        }

        function removeHabitLocalData(options = {}) {
            const key = getHabitLocalKey();
            localStorage.removeItem(key);
            if (options.removeLegacy) {
                localStorage.removeItem(HABIT_LOCAL_KEY_BASE);
            }
        }

        // 習慣トラッカーデータを保存（ユーザー別）
        function saveHabitTrackerData() {
            const key = getHabitLocalKey();
            localStorage.setItem(key, JSON.stringify(habitTrackerData));
            if (key !== HABIT_LOCAL_KEY_BASE) {
                localStorage.removeItem(HABIT_LOCAL_KEY_BASE);
            }
        }
        
        // 習慣トラッカーデータを読み込み（ユーザー別。旧キーがあれば移行）
        function loadHabitTrackerData() {
            const key = getHabitLocalKey();
            let saved = localStorage.getItem(key);
            if (!saved && key !== HABIT_LOCAL_KEY_BASE) {
                const legacy = localStorage.getItem(HABIT_LOCAL_KEY_BASE);
                if (legacy) {
                    localStorage.setItem(key, legacy);
                    localStorage.removeItem(HABIT_LOCAL_KEY_BASE);
                    saved = legacy;
                }
            }
            if (saved) {
                habitTrackerData = JSON.parse(saved);
            }
        }

        // ゲーム状態
        let gameState = {
            selectedCharacter: null,
            shachi: GAME_CONFIG.INITIAL_SHACHI,
            level: 1,
            experience: 0,
            stats: {
                stress: 0,
                knowledge: 0,
                physical: 0,
                communication: 0
            },
            characterStates: {},
            ownedCharacters: [],
            party: [],
            dailyEventsCompleted: 0,
            completedEventTypes: [], // 今日完了したイベントタイプ
            completedSeriesKeys: [], // 今日完了したシリーズキー
            lastPlayDate: null,
            purchasedItems: [],
            totalDaysPlayed: 0,
            totalShachiEarned: 0,
            totalEventsCompleted: 0,
            totalItemsPurchased: 0,
            totalShachiSpent: 0,
            completedBadges: [], // バッチ獲得リスト
            lastGachaDate: null, // 最後にガチャを引いた日
            todayGachaCount: 0, // 今日のガチャ回数
            lastHabitRewardDate: null, // 最後に習慣トラッカーの報酬を受け取った日
            shachiHistory: [], // シャチ履歴 [{timestamp, amount, type, description}, ...]
            rareItems: [], // レアカードID一覧
            rareItemsInventory: [] // レアアイテム一覧
        };

        const CHARACTER_STAT_KEYS = ['stress', 'knowledge', 'physical', 'communication'];

        function createInitialStats(character) {
            const base = character?.baseStats || {};
            return {
                stress: typeof base.stress === 'number' ? base.stress : 0,
                knowledge: typeof base.knowledge === 'number' ? base.knowledge : 0,
                physical: typeof base.physical === 'number' ? base.physical : 0,
                communication: typeof base.communication === 'number' ? base.communication : 0
            };
        }

        function ensureCharacterStateMap() {
            if (!gameState.characterStates || typeof gameState.characterStates !== 'object') {
                gameState.characterStates = {};
            }
            return gameState.characterStates;
        }

        function ensureCharacterState(character) {
            if (!character || !character.id) {
                return null;
            }
            const states = ensureCharacterStateMap();
            let state = states[character.id];
            if (!state) {
                state = {
                    stats: createInitialStats(character),
                    level: 1,
                    experience: 0,
                    lastUsedAt: null,
                    updatedAt: new Date().toISOString(),
                    completedBossEvents: [],
                    rankProgress: 0,
                    unlocked3DIcon: false,
                    use3DIcon: false,
                    unlockedMovies: [],
                    unlockedBossEvents: []
                };
                states[character.id] = state;
            } else {
                if (!state.stats || typeof state.stats !== 'object') {
                    state.stats = createInitialStats(character);
                } else {
                    const template = createInitialStats(character);
                    CHARACTER_STAT_KEYS.forEach(key => {
                        if (typeof state.stats[key] !== 'number' || Number.isNaN(state.stats[key])) {
                            state.stats[key] = template[key];
                        }
                    });
                }
                if (typeof state.level !== 'number' || Number.isNaN(state.level)) {
                    state.level = 1;
                }
                if (typeof state.experience !== 'number' || Number.isNaN(state.experience)) {
                    state.experience = 0;
                }
            }
            if (!Array.isArray(state.completedBossEvents)) {
                state.completedBossEvents = [];
            }
            if (!Array.isArray(state.unlockedMovies)) {
                state.unlockedMovies = [];
            }
            if (!Array.isArray(state.unlockedBossEvents)) {
                state.unlockedBossEvents = [];
            }
            if (typeof state.rankProgress !== 'number' || Number.isNaN(state.rankProgress)) {
                const maxCompletedRank = state.completedBossEvents.reduce((maxRank, eventId) => {
                    const event = BOSS_EVENT_MAP[eventId];
                    return event ? Math.max(maxRank, event.requiredRank) : maxRank;
                }, 0);
                state.rankProgress = maxCompletedRank;
            }
            const has3DSource = Boolean(get3DIconPath(character));
            if (!has3DSource) {
                state.unlocked3DIcon = false;
                state.use3DIcon = false;
            } else {
                if (typeof state.unlocked3DIcon !== 'boolean') {
                    state.unlocked3DIcon = false;
                }
                if (state.rankProgress >= THREE_D_ICON_UNLOCK_RANK && !state.unlocked3DIcon) {
                    state.unlocked3DIcon = true;
                }
                if (typeof state.use3DIcon !== 'boolean') {
                    state.use3DIcon = false;
                }
                if (!state.unlocked3DIcon) {
                    state.use3DIcon = false;
                }
            }
            return state;
        }

        function applyCharacterState(character) {
            const state = ensureCharacterState(character);
            if (!state) {
                return;
            }
            if (gameState.stats !== state.stats) {
                gameState.stats = state.stats;
            }
            gameState.level = state.level ?? 1;
            gameState.experience = state.experience ?? 0;
            state.lastUsedAt = new Date().toISOString();
            state.updatedAt = state.lastUsedAt;
        }

        function syncCurrentCharacterState() {
            if (!gameState.selectedCharacter || !gameState.selectedCharacter.id) {
                return;
            }
            const state = ensureCharacterState(gameState.selectedCharacter);
            if (!state) {
                return;
            }
            if (state.stats !== gameState.stats && gameState.stats) {
                state.stats = gameState.stats;
            }
            state.level = gameState.level ?? state.level ?? 1;
            state.experience = gameState.experience ?? state.experience ?? 0;
            state.updatedAt = new Date().toISOString();
        }

        function sanitizeStatValue(value, fallback = 0) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return fallback;
            }
            const max = GAME_CONFIG.STAT_CAP || 200;
            return Math.max(0, Math.min(max, value));
        }

        function sanitizeStats(stats, character) {
            const template = createInitialStats(character);
            const safeStats = {};
            CHARACTER_STAT_KEYS.forEach(key => {
                safeStats[key] = sanitizeStatValue(stats?.[key], template[key]);
            });
            return safeStats;
        }

        function sanitizeShachiValue(value, fallback = 0) {
            let numericValue = value;
            if (typeof numericValue === 'string') {
                const cleaned = numericValue.replace(/[^\d\-.]/g, '');
                numericValue = cleaned.length ? Number(cleaned) : NaN;
            } else if (numericValue && typeof numericValue === 'object') {
                if (typeof numericValue.amount === 'number') {
                    numericValue = numericValue.amount;
                } else if (typeof numericValue.value === 'number') {
                    numericValue = numericValue.value;
                } else {
                    numericValue = NaN;
                }
            }
            if (typeof numericValue !== 'number' || Number.isNaN(numericValue)) {
                numericValue = fallback;
            }
            return Math.max(0, Math.floor(numericValue));
        }

        const SHACHI_DEBUG_MAX = 50;
        window.__shachiLog = window.__shachiLog || [];

        function logShachiDebug(entry) {
            window.__shachiLog.push({ time: new Date().toISOString(), ...entry });
            if (window.__shachiLog.length > SHACHI_DEBUG_MAX) {
                window.__shachiLog.shift();
            }
            console.log('[Shachi]', entry);
        }

        function getCurrentShachi() {
            const raw = gameState?.shachi;
            const sanitized = sanitizeShachiValue(raw, GAME_CONFIG?.INITIAL_SHACHI || 0);
            if (typeof raw !== 'number' && sanitized === 0 && raw !== undefined && raw !== null) {
                logShachiDebug({ type: 'sanitize', rawValue: raw, sanitized });
            }
            return sanitized;
        }

        function adjustShachi(delta) {
            const current = getCurrentShachi();
            const normalizedDelta = typeof delta === 'number' ? delta : sanitizeShachiValue(delta, 0);
            const next = Math.max(0, current + normalizedDelta);
            gameState.shachi = next;
            logShachiDebug({ type: 'adjust', current, delta: normalizedDelta, next, stack: new Error().stack.split('\n').slice(1, 6) });
            return next;
        }

        const LOCAL_SAVE_KEY_BASE = 'shachipoke2_save';

        function getLocalSaveKey(userIdOverride) {
            const resolvedUserId = typeof userIdOverride === 'string' ? userIdOverride : currentUser?.id;
            return resolvedUserId ? `${LOCAL_SAVE_KEY_BASE}_${resolvedUserId}` : LOCAL_SAVE_KEY_BASE;
        }

        function readLocalSaveData() {
            const key = getLocalSaveKey();
            let data = localStorage.getItem(key);
            if (!data && key !== LOCAL_SAVE_KEY_BASE) {
                const legacyData = localStorage.getItem(LOCAL_SAVE_KEY_BASE);
                if (legacyData) {
                    console.log('ローカルセーブデータをユーザー専用キーへ移行しました:', key);
                    localStorage.setItem(key, legacyData);
                    localStorage.removeItem(LOCAL_SAVE_KEY_BASE);
                    data = legacyData;
                }
            }
            return { key, data };
        }

        function writeLocalSaveData(payload) {
            const key = getLocalSaveKey();
            const serialized = typeof payload === 'string' ? payload : JSON.stringify(payload);
            localStorage.setItem(key, serialized);
            if (key !== LOCAL_SAVE_KEY_BASE) {
                localStorage.removeItem(LOCAL_SAVE_KEY_BASE);
            }
        }

        function removeLocalSaveData(options = {}) {
            const key = getLocalSaveKey();
            localStorage.removeItem(key);
            if (options.removeLegacy) {
                localStorage.removeItem(LOCAL_SAVE_KEY_BASE);
            }
        }

        function sanitizeLevel(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return 1;
            }
            return Math.max(1, Math.min(999, Math.floor(value)));
        }

        function sanitizeExperience(value) {
            if (typeof value !== 'number' || Number.isNaN(value)) {
                return 0;
            }
            return Math.max(0, Math.floor(value));
        }

        function normalizeCharacterEntry(entry) {
            if (!entry) {
                return null;
            }
            let id = null;
            if (typeof entry === 'string') {
                id = entry;
            } else if (typeof entry === 'object') {
                id = entry.id;
            }
            if (!id) {
                return null;
            }
            const base = CHARACTERS.find(char => char.id === id);
            if (!base) {
                return null;
            }
            if (typeof entry === 'object' && entry !== null) {
                return { ...base, ...entry };
            }
            return { ...base };
        }

        function normalizeGameState() {
            if (!gameState) {
                return;
            }

            const bossEventIds = new Set(BOSS_EVENTS.map(event => event.id));

            if (!Array.isArray(gameState.ownedCharacters)) {
                gameState.ownedCharacters = [];
            }
            if (!Array.isArray(gameState.party)) {
                gameState.party = [];
            }
            if (!gameState.characterStates || typeof gameState.characterStates !== 'object') {
                gameState.characterStates = {};
            }

            gameState.shachi = sanitizeShachiValue(gameState.shachi, GAME_CONFIG.INITIAL_SHACHI);
            gameState.totalShachiEarned = sanitizeShachiValue(gameState.totalShachiEarned || 0, 0);
            gameState.totalShachiSpent = sanitizeShachiValue(gameState.totalShachiSpent || 0, 0);
            if (!Array.isArray(gameState.rareItems)) {
                gameState.rareItems = [];
            } else {
                gameState.rareItems = gameState.rareItems.filter(Boolean);
            }
            if (!Array.isArray(gameState.rareItemsInventory)) {
                gameState.rareItemsInventory = [];
            }

            // Sanitize stored character states
            Object.keys(gameState.characterStates).forEach(characterId => {
                const base = CHARACTERS.find(char => char.id === characterId);
                if (!base) {
                    delete gameState.characterStates[characterId];
                    return;
                }
                const state = gameState.characterStates[characterId];
                if (!state || typeof state !== 'object') {
                    gameState.characterStates[characterId] = {
                        stats: createInitialStats(base),
                        level: 1,
                        experience: 0,
                        lastUsedAt: null,
                        updatedAt: new Date().toISOString()
                    };
                    return;
                }
                state.stats = sanitizeStats(state.stats, base);
                state.level = sanitizeLevel(state.level ?? 1);
                state.experience = sanitizeExperience(state.experience ?? 0);
                if (!Array.isArray(state.completedBossEvents)) {
                    state.completedBossEvents = [];
                } else {
                    state.completedBossEvents = state.completedBossEvents
                        .filter(eventId => typeof eventId === 'string');
                }
                if (typeof state.rankProgress !== 'number' || Number.isNaN(state.rankProgress)) {
                    const restoredRank = state.completedBossEvents.reduce((maxRank, eventId) => {
                        const event = BOSS_EVENT_MAP[eventId];
                        return event ? Math.max(maxRank, event.requiredRank) : maxRank;
                    }, 0);
                    state.rankProgress = restoredRank;
                }
                const baseHas3D = Boolean(get3DIconPath(base));
                if (!baseHas3D) {
                    state.unlocked3DIcon = false;
                    state.use3DIcon = false;
                } else {
                    if (typeof state.unlocked3DIcon !== 'boolean') {
                        state.unlocked3DIcon = false;
                    }
                    if (state.rankProgress >= THREE_D_ICON_UNLOCK_RANK && !state.unlocked3DIcon) {
                        state.unlocked3DIcon = true;
                    }
                    if (typeof state.use3DIcon !== 'boolean') {
                        state.use3DIcon = false;
                    }
                    if (!state.unlocked3DIcon) {
                        state.use3DIcon = false;
                    }
                }
            });

            // Normalize owned characters
            gameState.ownedCharacters = gameState.ownedCharacters
                .map(normalizeCharacterEntry)
                .filter(Boolean);

            // Normalize party slots (owned charactersのみ)
            gameState.party = gameState.party
                .map(normalizeCharacterEntry)
                .filter(character => character && gameState.ownedCharacters.some(owned => owned.id === character.id));

            // Normalize selected character
            let normalizedSelected = normalizeCharacterEntry(gameState.selectedCharacter);
            if (!normalizedSelected && gameState.ownedCharacters.length > 0) {
                normalizedSelected = gameState.ownedCharacters[0];
            }
            gameState.selectedCharacter = normalizedSelected || null;

            // Ensure character states exist for owned characters
            gameState.ownedCharacters.forEach(character => ensureCharacterState(character));

            if (gameState.selectedCharacter) {
                const selectedState = ensureCharacterState(gameState.selectedCharacter);
                if (selectedState) {
                    const safeStats = sanitizeStats(gameState.stats || selectedState.stats, gameState.selectedCharacter);
                    selectedState.stats = safeStats;
                    selectedState.level = sanitizeLevel(gameState.level ?? selectedState.level ?? 1);
                    selectedState.experience = sanitizeExperience(gameState.experience ?? selectedState.experience ?? 0);
                    gameState.stats = selectedState.stats;
                    gameState.level = selectedState.level;
                    gameState.experience = selectedState.experience;
                    applyCharacterState(gameState.selectedCharacter);
                }
            } else {
                gameState.stats = createInitialStats();
                gameState.level = 1;
                gameState.experience = 0;
            }

            // 移行: 以前はボスイベントIDをcompletedSeriesKeysに保存していたため、現在のキャラクター状態に移す
            if (Array.isArray(gameState.completedSeriesKeys) && gameState.completedSeriesKeys.length) {
                const remainingKeys = [];
                const targetState = gameState.selectedCharacter ? ensureCharacterState(gameState.selectedCharacter) : null;
                gameState.completedSeriesKeys.forEach(key => {
                    if (bossEventIds.has(key) && targetState) {
                        if (!targetState.completedBossEvents.includes(key)) {
                            targetState.completedBossEvents.push(key);
                        }
                        const migratedEvent = BOSS_EVENT_MAP[key];
                        if (migratedEvent) {
                            targetState.rankProgress = Math.max(targetState.rankProgress || 0, migratedEvent.requiredRank);
                        }
                    } else {
                        remainingKeys.push(key);
                    }
                });
                gameState.completedSeriesKeys = remainingKeys;
            }
        }

        function getCurrentCharacterState() {
            if (!gameState.selectedCharacter) {
                return null;
            }
            return ensureCharacterState(gameState.selectedCharacter);
        }

        function getCurrentCharacterCompletedBossEvents() {
            const state = getCurrentCharacterState();
            if (!state) return [];
            if (!Array.isArray(state.completedBossEvents)) {
                state.completedBossEvents = [];
            }
            return state.completedBossEvents;
        }

        function hasCurrentCharacterCompletedBossEvent(bossEventId) {
            if (!bossEventId) return false;
            return getCurrentCharacterCompletedBossEvents().includes(bossEventId);
        }

        function markCurrentCharacterBossEventCompleted(bossEventId) {
            if (!bossEventId) return;
            const events = getCurrentCharacterCompletedBossEvents();
            if (!events.includes(bossEventId)) {
                events.push(bossEventId);
            }
            const state = getCurrentCharacterState();
            const event = BOSS_EVENT_MAP[bossEventId];
            if (state && event) {
                const requiredRank = event.requiredRank || 0;
                state.rankProgress = Math.max(state.rankProgress || 0, requiredRank);
            }
        }

        function getCurrentCharacterRankProgress() {
            const state = getCurrentCharacterState();
            if (!state) return 0;
            if (typeof state.rankProgress !== 'number' || Number.isNaN(state.rankProgress)) {
                state.rankProgress = 0;
            }
            return state.rankProgress;
        }

        function get3DIconPath(character) {
            if (!character) return null;
            const characterId = typeof character === 'string' ? character : character.id;
            return CHARACTER_3D_ICON_MAP[characterId] || null;
        }

        function getCharacterIconPath(character, state) {
            if (!character) return '';
            const threeDPath = get3DIconPath(character);
            if (state && state.use3DIcon && state.unlocked3DIcon && threeDPath) {
                return threeDPath;
            }
            return `10_社畜アイコン/${character.icon}`;
        }

        function ensure3DIconUnlockForCurrentCharacter(rankData) {
            const state = getCurrentCharacterState();
            const character = gameState.selectedCharacter;
            if (!state || !character) return;
            const threeDPath = get3DIconPath(character);
            if (!threeDPath) return;

            const rankValue = typeof rankData === 'number'
                ? rankData
                : (rankData && typeof rankData.rank === 'number' ? rankData.rank : 0);

            if (rankValue >= THREE_D_ICON_UNLOCK_RANK && !state.unlocked3DIcon) {
                state.unlocked3DIcon = true;
                state.use3DIcon = false;
                show3DIconUnlockPopup(character.name);
            }
        }

        function show3DIconUnlockPopup(characterName) {
            const dialog = document.createElement('div');
            dialog.className = 'achievement-notification';
            dialog.innerHTML = `
                <div class="achievement-content" style="background: linear-gradient(135deg, #ff9ec4 0%, #ffc3e1 100%); border: 3px solid #ff9ec4;">
                    <div class="achievement-icon" style="font-size: 3.5rem;">✨</div>
                    <h2 style="color: #fff; text-shadow: 1px 1px 4px rgba(0,0,0,0.2);">3Dアイコン解放！</h2>
                    <p style="color: #fff; font-weight: 600; font-size: 1.1rem; margin-bottom: 10px;">${characterName}が部長に昇格しました。</p>
                    <p style="color: #fff; margin-bottom: 15px;">ホームのキャラアイコンをタップすると、2Dと3Dを切り替えられます。</p>
                    <button class="btn-primary" onclick="this.closest('.achievement-notification').remove();" style="margin-top: 10px;">了解</button>
                </div>
            `;
            document.body.appendChild(dialog);

            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
        }

        function toggleCurrentCharacterIconMode() {
            if (!gameState.selectedCharacter) {
                showToast('キャラクターが選択されていません', 'info');
                return;
            }
            const state = getCurrentCharacterState();
            if (!state) return;

            const threeDPath = get3DIconPath(gameState.selectedCharacter);
            if (!threeDPath) {
                showToast('このキャラクターの3Dアイコンは準備中です', 'info');
                return;
            }
            if (!state.unlocked3DIcon) {
                showToast('部長に昇格すると3Dアイコンを使用できます', 'info');
                return;
            }

            state.use3DIcon = !state.use3DIcon;
            updateMainScreen();
            autoSave();
            showToast(state.use3DIcon ? '3Dアイコンに切り替えました' : '通常アイコンに戻しました', 'success');
        }

        function handleMainCharacterImageClick() {
            toggleCurrentCharacterIconMode();
        }

        function getStatsEligibleRank() {
            const stats = gameState.stats;
            let eligibleRank = 0;
            for (const rank of RANK_SYSTEM) {
                const meets =
                    stats.stress >= rank.requiredStats.stress &&
                    stats.knowledge >= rank.requiredStats.knowledge &&
                    stats.physical >= rank.requiredStats.physical &&
                    stats.communication >= rank.requiredStats.communication;
                if (meets) {
                    eligibleRank = rank.rank;
                } else {
                    break;
                }
            }
            return eligibleRank;
        }

        let selectedCharacterId = null;
        // 画面表示切り替え
        function showScreen(screenName) {
            console.log('画面切り替え:', screenName);
            
            // すべての画面を非表示
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });
            
            // 指定された画面を表示
            const targetScreen = document.getElementById(screenName);
            
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
                console.log('画面表示完了:', screenName);
                
                // ナビゲーションボタンのアクティブ状態を更新
                updateNavigationActive(screenName);
                
                // 画面ごとの初期化処理
                switch(screenName) {
                    case 'main':
                        updateMainScreen();
                        break;
                    case 'events':
                        startEvent();
                        break;
                    case 'shop':
                        renderShop();
                        break;
                    case 'habits':
                        renderHabitTracker();
                        break;
                    case 'settings':
                        updateGameStats();
                        renderBadges();
                        renderCurrentCharacterMovie();
                        syncTestModeUI();
                        hideTestModeInProduction();
                        break;
                    case '3d-characters':
                        render3DVideos();
                        break;
                    case 'shachi-history':
                        renderShachiHistory();
                        break;
                    case 'rank-list':
                        renderRankList();
                        break;
                }

                // 画面切り替え後はスクロール位置を最上部へ
                setTimeout(() => {
                    resetScrollPosition(targetScreen);
                }, 0);
            } else {
                console.error('画面が見つかりません:', screenName);
                // 利用可能な画面IDをログ出力
                const availableScreens = Array.from(document.querySelectorAll('.screen')).map(s => s.id);
                console.log('利用可能な画面ID:', availableScreens);
            }
        }

        // スクロール位置をリセット（window と 対象スクリーンの両方）
        function resetScrollPosition(targetScreen) {
            try {
                console.log('スクロール位置をリセットします');
                
                // ウィンドウ全体
                window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
                
                // すべてのスクリーン要素とその内部のスクロール可能な要素
                document.querySelectorAll('.screen').forEach(el => {
                    el.scrollTop = 0;
                    // スクリーン内のスクロール可能な要素もリセット
                    const scrollableElements = el.querySelectorAll('[data-scrollable], .scrollable, .events-content, .shop-content, .habits-content, .settings-content');
                    scrollableElements.forEach(scrollEl => {
                        if (scrollEl instanceof HTMLElement) {
                            scrollEl.scrollTop = 0;
                        }
                    });
                });
                
                // 対象スクリーン
                if (targetScreen) {
                    targetScreen.scrollTop = 0;
                    const targetScrollables = targetScreen.querySelectorAll('[data-scrollable], .scrollable, .events-content, .shop-content, .habits-content, .settings-content');
                    targetScrollables.forEach(scrollEl => {
                        if (scrollEl instanceof HTMLElement) {
                            scrollEl.scrollTop = 0;
                        }
                    });
                }
                
                console.log('スクロール位置リセット完了');
            } catch (e) {
                console.error('スクロールリセット時のエラー:', e);
                window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
                document.documentElement.scrollTop = 0;
                document.body.scrollTop = 0;
            }
        }
        
        function updateNavigationActive(activeScreenId) {
            // すべてのナビゲーションボタンからactiveクラスを削除
            const allNavBtns = document.querySelectorAll('.nav-btn');
            allNavBtns.forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 現在の画面に対応するナビゲーションボタンにactiveクラスを追加
            const activeNavBtn = document.querySelector(`#global-navigation .nav-btn[onclick="showScreen('${activeScreenId}')"]`);
            if (activeNavBtn) {
                activeNavBtn.classList.add('active');
            }
        }

        // テストモードUIと同期
        function syncTestModeUI() {
            const cb = document.getElementById('toggle-test-mode');
            if (cb) cb.checked = TEST_MODE;
        }

        function toggleTestMode() {
            TEST_MODE = !TEST_MODE;
            localStorage.setItem('TEST_MODE', TEST_MODE ? '1' : '0');
            console.log('TEST_MODE toggled:', TEST_MODE);
            // 表示を即時反映
            if (document.getElementById('events') && !document.getElementById('events').classList.contains('hidden')) {
                renderEventCards();
            }
        }

        function enableTestModeOnce() {
            TEST_MODE = true;
            console.log('TEST_MODE enabled once');
            syncTestModeUI();
            if (document.getElementById('events') && !document.getElementById('events').classList.contains('hidden')) {
                renderEventCards();
            }
        }
        
        // 本番環境ではテストモードセクションを非表示にする
        function hideTestModeInProduction() {
            const testModeSection = document.getElementById('test-mode-section');
            if (!testModeSection) return;
            
            // 本番環境の判定: localhost以外は本番環境とみなす
            const hostname = window.location.hostname;
            const isProduction = hostname !== 'localhost' && hostname !== '127.0.0.1' && !hostname.startsWith('192.168.') && !hostname.startsWith('10.') && hostname !== '';
            
            if (isProduction) {
                testModeSection.style.display = 'none';
                console.log('本番環境のため、テストモードセクションを非表示にしました');
            } else {
                testModeSection.style.display = '';
                console.log('開発環境のため、テストモードセクションを表示します');
            }
        }

        // キャラクター選択
        function selectCharacter(characterId) {
            console.log('キャラクター選択:', characterId);
            selectedCharacterId = characterId;
            
            // 前の選択を解除
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // 新しい選択を追加
            const selectedCard = document.querySelector(`[data-character-id="${characterId}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            // プレビューを更新
            updateCharacterPreview(characterId);
            
            // 確定ボタンを有効化
            const confirmBtn = document.getElementById('confirm-character');
            if (confirmBtn) {
                confirmBtn.disabled = false;
            }
        }

        // キャラクタープレビュー更新
        function updateCharacterPreview(characterId) {
            const character = CHARACTERS.find(c => c.id === characterId);
            if (!character) return;
            
            document.getElementById('preview-name').textContent = character.name;
            document.querySelector('.preview-image').innerHTML = `
                <img src="10_社畜アイコン/${character.icon}" alt="${character.name}" loading="lazy" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div style="width: 100%; height: 100%; background: #ddd; border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 48px; color: #666;">
                    ${character.name.charAt(0)}
                </div>
            `;
            document.getElementById('preview-stress').textContent = character.baseStats.stress;
            document.getElementById('preview-knowledge').textContent = character.baseStats.knowledge;
            document.getElementById('preview-physical').textContent = character.baseStats.physical;
            document.getElementById('preview-communication').textContent = character.baseStats.communication;
        }

        // キャラクター確定
        async function confirmCharacter() {
            console.log('キャラクター確定開始:', selectedCharacterId);
            
            if (!selectedCharacterId) {
                console.error('キャラクターが選択されていません');
                alert('キャラクターを選択してください');
                return;
            }
            
            const character = CHARACTERS.find(c => c.id === selectedCharacterId);
            if (!character) {
                console.error('キャラクターが見つかりません:', selectedCharacterId);
                alert('キャラクターが見つかりません');
                return;
            }
            
            console.log('選択されたキャラクター:', character);
            
            // ゲーム状態を更新
            gameState.characterStates = {};
            gameState.selectedCharacter = character;
            const initialState = ensureCharacterState(character);
            if (initialState) {
                initialState.stats = createInitialStats(character);
                initialState.level = 1;
                initialState.experience = 0;
                initialState.lastUsedAt = new Date().toISOString();
                initialState.updatedAt = initialState.lastUsedAt;
                applyCharacterState(character);
            } else {
                gameState.stats = createInitialStats(character);
                gameState.level = 1;
                gameState.experience = 0;
            }
            gameState.ownedCharacters = [character];
            gameState.party = [character];
            
            // キャラクター紹介動画を解放
            unlockCharacterIntroMovie(character.id);
            
            console.log('ゲーム状態更新完了:', gameState);
            
            // 自動セーブ
            await autoSave();
            
            // キャラクター紹介動画を再生
            await playCharacterIntroOnInitialSelection(character);
            
            // メイン画面に移動
            console.log('メイン画面に切り替え中...');
            showScreen('main');
            
            // メイン画面を更新
            updateMainScreen();
        }

        // DOM更新のキャッシュ（再描画を防ぐ）
        let lastRenderedState = {
            shachi: null,
            level: null,
            stats: null,
            characterId: null,
            iconMode3D: null,
            rank: null
        };
        
        // メイン画面更新
        async function updateMainScreen() {
            console.log('メイン画面更新開始');
            
            if (!gameState.selectedCharacter) {
                console.error('選択されたキャラクターがありません');
                return;
            }
            
            const character = gameState.selectedCharacter;
            const currentCharacterState = getCurrentCharacterState();
            if (!currentCharacterState) {
                console.error('キャラクター状態を取得できませんでした - キャラクター選択画面へリダイレクト');
                showScreen('character-selection');
                return;
            }
            const currentIconMode = currentCharacterState.use3DIcon ? '3d' : '2d';
            console.log('更新するキャラクター:', character);
            
            // 変更がない場合は更新をスキップ
            const currentRank = calculateRank();
            const hasChanges = 
                lastRenderedState.shachi !== gameState.shachi ||
                lastRenderedState.level !== gameState.level ||
                lastRenderedState.characterId !== character.id ||
                lastRenderedState.iconMode3D !== currentIconMode ||
                lastRenderedState.rank !== currentRank.rank ||
                JSON.stringify(lastRenderedState.stats) !== JSON.stringify(gameState.stats);
            
            if (!hasChanges && lastRenderedState.shachi !== null) {
                console.log('変更がないため、更新をスキップ');
                return;
            }
            
            // キャラクター情報を更新
            const characterNameEl = document.getElementById('character-name');
            const characterImageEl = document.getElementById('main-character-image');
            const characterLevelEl = document.getElementById('character-level');
            const characterRankNameEl = document.getElementById('character-rank-name');
            const currencyAmountEl = document.getElementById('currency-amount');
            
            ensure3DIconUnlockForCurrentCharacter(currentRank);
            
            if (characterNameEl) {
                characterNameEl.textContent = character.name;
                console.log('キャラクター名更新:', character.name);
            }
            
            if (characterImageEl) {
                const iconPath = getCharacterIconPath(character, currentCharacterState);
                const fallbackInitial = character.name.charAt(0);
                const has3D = Boolean(currentCharacterState.unlocked3DIcon && get3DIconPath(character));
                const badge = has3D ? `<span class="icon-mode-badge">${currentCharacterState.use3DIcon ? '3D' : '2D'}</span>` : '';
                characterImageEl.innerHTML = `
                    <img src="${iconPath}" alt="${character.name}" loading="lazy" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <div style="width: 100%; height: 100%; background: #ddd; border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 48px; color: #666;">
                        ${fallbackInitial}
                    </div>
                    ${badge}
                `;
                characterImageEl.classList.toggle('icon-3d-active', Boolean(currentCharacterState.use3DIcon && has3D));
                characterImageEl.classList.toggle('icon-3d-available', Boolean(has3D));
                characterImageEl.setAttribute('title', has3D ? 'タップで2D/3D切替' : '部長昇格で3D解放');
                console.log('キャラクター画像更新:', character.name);
            }
            
            if (characterRankNameEl) {
                characterRankNameEl.textContent = currentRank.name;
                console.log('役職更新:', currentRank.name);
            }
            
            if (characterLevelEl) {
                characterLevelEl.textContent = gameState.level;
                console.log('レベル更新:', gameState.level);
            }
            
            if (currencyAmountEl) {
                currencyAmountEl.textContent = gameState.shachi;
                console.log('通貨更新:', gameState.shachi);
            }
            
            // ショップ画面の通貨表示も更新
            const shopCurrencyAmountEl = document.getElementById('shop-currency-amount');
            if (shopCurrencyAmountEl) {
                shopCurrencyAmountEl.textContent = gameState.shachi;
            }
            // ステータスを更新
            await updateStatsDisplay();
            console.log('メイン画面更新完了');
            renderRareItems();
            
            // キャッシュを更新
            lastRenderedState = {
                shachi: gameState.shachi,
                level: gameState.level,
                stats: {...gameState.stats},
                characterId: character.id,
                iconMode3D: currentIconMode,
                rank: currentRank.rank
            };
        }

        // バッチをチェック（通知なしモード）
        let isInitialLoad = true;
        
        async function checkBadges(silent = false) {
            BADGES.forEach(badge => {
                const current = getCurrentBadgeProgress(badge);
                
                // 達成条件を満たしているかチェック
                if (current >= badge.target) {
                    // 既に達成済みかチェック
                    if (!gameState.completedBadges || !gameState.completedBadges.includes(badge.id)) {
                        // バッチ達成（サイレントモードの場合は通知をスキップ）
                        completeBadge(badge, current, silent);
                    }
                }
            });
            
            isInitialLoad = false;
        }
        
        // バッチの現在の進捗を取得
        function getCurrentBadgeProgress(badge) {
            switch (badge.category) {
                case 'level':
                    return gameState.level || 0;
                case 'events':
                    return gameState.totalEventsCompleted || 0;
                case 'items':
                    return gameState.totalItemsPurchased || 0;
                case 'shachi':
                    return gameState.totalShachiEarned || 0;
                case 'characters':
                    return gameState.ownedCharacters ? gameState.ownedCharacters.length : 0;
                case 'habits':
                    // 習慣チェックの合計数を計算
                    let totalHabitChecks = 0;
                    for (const dateKey in habitTrackerData) {
                        const dayData = habitTrackerData[dateKey];
                        totalHabitChecks += Object.values(dayData).filter(Boolean).length;
                    }
                    return totalHabitChecks;
                default:
                    return 0;
            }
        }
        // バッチ達成処理
        async function completeBadge(badge, currentValue, silent = false) {
            console.log('バッチ達成:', badge);
            
            // 達成リストに追加
            if (!gameState.completedBadges) {
                gameState.completedBadges = [];
            }
            gameState.completedBadges.push(badge.id);
            
            // シャチを追加（0以下にならないよう保護）
            adjustShachi(badge.reward);
            gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + badge.reward;
            
            // シャチ履歴を記録
            recordShachiHistory(badge.reward, 'badge', `バッチ獲得: ${badge.name}`);
            
            // データベースに保存
            await saveBadgeToDatabase(badge, currentValue);
            
            // 達成通知を表示（サイレントモードの場合はスキップ）
            if (!silent) {
                showBadgeNotification(badge, currentValue);
            }
            
            // UIを更新
            updateMainScreen();
            
            // 自動セーブ
            autoSave();
        }
        
        // バッチ達成通知を表示
        function showBadgeNotification(badge, currentValue) {
            const dialog = document.createElement('div');
            dialog.className = 'achievement-notification';
            dialog.innerHTML = `
                <div class="achievement-content">
                    <div class="achievement-icon">${badge.icon}</div>
                    <h3>バッチ獲得！</h3>
                    <p class="achievement-name">${badge.name}</p>
                    <p class="achievement-description">${badge.description}</p>
                    <p class="achievement-progress">進捗: ${currentValue}/${badge.target}</p>
                    <div style="font-size: 1.2rem; font-weight: bold; color: #ffd700; margin: 15px 0;">
                        💰 シャチ +${badge.reward} 獲得！
                    </div>
                    <button class="btn-primary" onclick="this.parentElement.parentElement.remove();">閉じる</button>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
        }
        
        // バッチ一覧を表示（2列×3行、6カテゴリー）
        function renderBadges() {
            const grid = document.getElementById('badge-grid');
            const completedGrid = document.getElementById('completed-badges-grid');
            if (!grid || !completedGrid) return;
            
            grid.innerHTML = '';
            completedGrid.innerHTML = '';
            
            // カテゴリーごとにグループ化
            const categories = {
                'level': { name: 'レベル', badges: [] },
                'events': { name: 'イベント', badges: [] },
                'items': { name: 'アイテム', badges: [] },
                'shachi': { name: 'シャチ', badges: [] },
                'characters': { name: 'キャラクター保有', badges: [] },
                'habits': { name: '習慣', badges: [] }
            };
            
            // バッチをカテゴリーごとに分類
            BADGES.forEach(badge => {
                if (categories[badge.category]) {
                    categories[badge.category].badges.push(badge);
                }
            });
            
            // 各カテゴリーのバッチをorder順にソート
            Object.keys(categories).forEach(categoryKey => {
                categories[categoryKey].badges.sort((a, b) => a.order - b.order);
            });
            
            // 各カテゴリーで次のバッチを取得（達成済みの次のバッチ、または最初の未達成バッチ）
            const categoryOrder = ['level', 'events', 'items', 'shachi', 'characters', 'habits'];
            const displayBadges = [];
            
            categoryOrder.forEach(categoryKey => {
                const category = categories[categoryKey];
                if (category.badges.length > 0) {
                    // このカテゴリーで達成済みのバッチを取得
                    const completedBadgesInCategory = category.badges.filter(b => 
                        gameState.completedBadges && gameState.completedBadges.includes(b.id)
                    );
                    
                    let nextBadge = null;
                    
                    if (completedBadgesInCategory.length > 0) {
                        // 達成済みバッチの中で最大のorderを取得
                        const maxCompletedOrder = Math.max(...completedBadgesInCategory.map(b => b.order));
                        
                        // その次のorderのバッチを探す
                        nextBadge = category.badges.find(b => b.order > maxCompletedOrder);
                        
                        // 次のバッチがない場合（すべて達成済み）、最終バッチを表示
                        if (!nextBadge) {
                            nextBadge = category.badges[category.badges.length - 1];
                        }
                    } else {
                        // まだ達成していない場合は最初のバッチ（order: 1）を表示
                        nextBadge = category.badges.find(b => b.order === 1) || category.badges[0];
                    }
                    
                    if (nextBadge) {
                        displayBadges.push({ badge: nextBadge, category: category.name });
                    }
                }
            });
            
            // 2列×3行のグリッドレイアウトで表示
            displayBadges.forEach((item, index) => {
                const badge = item.badge;
                const current = getCurrentBadgeProgress(badge);
                const completed = gameState.completedBadges && gameState.completedBadges.includes(badge.id);
                const progress = Math.min(100, (current / badge.target) * 100);
                
                const badgeCard = document.createElement('div');
                badgeCard.className = 'badge-card';
                badgeCard.style.cssText = `
                    background: ${completed ? 'linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%)' : '#f8f9fa'};
                    border: 2px solid ${completed ? '#4caf50' : '#e0e0e0'};
                    border-radius: 12px;
                    padding: 15px;
                    text-align: center;
                    position: relative;
                    box-shadow: ${completed ? '0 4px 12px rgba(76, 175, 80, 0.3)' : '0 2px 4px rgba(0,0,0,0.1)'};
                `;
                
                badgeCard.innerHTML = `
                    <div style="font-size: 3rem; margin-bottom: 10px;">${badge.icon}</div>
                    <div style="font-size: 0.85rem; color: #666; margin-bottom: 5px;">${item.category}</div>
                    <div style="font-size: 0.75rem; font-weight: bold; color: #ff6b00; margin-bottom: 5px;">STEP ${badge.order}</div>
                    <h4 style="font-size: 1rem; font-weight: bold; margin: 5px 0; color: ${completed ? '#2e7d32' : '#333'};">
                        ${badge.name}
                    </h4>
                    <p style="font-size: 0.8rem; color: #666; margin: 5px 0;">${badge.description}</p>
                    <div style="width: 100%; height: 8px; background: #e0e0e0; border-radius: 4px; margin: 10px 0; overflow: hidden;">
                        <div style="height: 100%; background: linear-gradient(90deg, #4caf50, #8bc34a); width: ${progress}%; transition: width 0.3s ease;"></div>
                    </div>
                    <p style="font-size: 0.75rem; color: #666; margin: 0;">
                        ${completed ? '✓ 完了済み' : `${current}/${badge.target}`}
                    </p>
                    ${completed ? '<div style="position: absolute; top: 10px; right: 10px; width: 30px; height: 30px; background: #4caf50; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;">✓</div>' : ''}
                    ${completed ? `<div style="font-size: 0.75rem; color: #ff6b00; font-weight: bold; margin-top: 5px;">💰 ${badge.reward}シャチ獲得済</div>` : `<div style="font-size: 0.75rem; color: #ff6b00; font-weight: bold; margin-top: 5px;">報酬: 💰 ${badge.reward}シャチ</div>`}
                `;
                
                grid.appendChild(badgeCard);
            });
            
            // グリッドのスタイルを設定（2列レイアウト）
            grid.style.cssText = `
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                margin-bottom: 20px;
            `;
            
            // 獲得済みバッチを下部に表示
            if (gameState.completedBadges && gameState.completedBadges.length > 0) {
                const completedBadgesList = BADGES.filter(b => gameState.completedBadges.includes(b.id));
                completedBadgesList.forEach(badge => {
                    const badgeItem = document.createElement('div');
                    badgeItem.style.cssText = `
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
                        border: 2px solid #4caf50;
                        border-radius: 8px;
                        padding: 8px 12px;
                        margin: 5px;
                        font-size: 2rem;
                        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
                    `;
                    badgeItem.innerHTML = `<span title="${badge.name}">${badge.icon}</span>`;
                    completedGrid.appendChild(badgeItem);
                });
            } else {
                completedGrid.innerHTML = '<p style="color: #999; font-size: 0.9rem;">まだ獲得したバッチはありません</p>';
            }
        }
        
        // 3Dキャラクターとムービーを表示
        function render3DVideos() {
            const gallery = document.getElementById('3d-video-gallery');
            if (!gallery) return;
            
            gallery.innerHTML = '';
            
            // キャラクターIDから3Dアイコンと動画のマッピング
            // アイコンファイル名（001.pngなど）から番号を抽出
            CHARACTERS.forEach((character, index) => {
                // アイコンファイル名から番号を抽出（例: "001.png" → "01"）
                const iconMatch = character.icon.match(/^(\d+)\.png$/);
                if (!iconMatch) return;
                
                const iconNumber = parseInt(iconMatch[1]);
                const paddedNumber = String(iconNumber).padStart(2, '0'); // "01", "02", etc.
                
                // 3Dアイコンのパス（例: "11_３Dアイコン/01_3D.png"）
                // キャラクター09は特別処理が必要（09_3D.pngまたは09_3D_01.png）
                let icon3DPath;
                if (iconNumber === 9) {
                    icon3DPath = '11_３Dアイコン/09_3D.png'; // デフォルトは09_3D.pngを使用
                } else {
                    icon3DPath = `11_３Dアイコン/${paddedNumber}_3D.png`;
                }
                
                // 3D動画のパス（例: "20_movie/32_3D/01_3D_01.mp4"）
                let video3DPath;
                if (iconNumber === 9) {
                    // キャラクター09は複数の動画がある可能性があるので、まず01を試す
                    video3DPath = '20_movie/32_3D/09_3D_01.mp4';
                } else {
                    video3DPath = `20_movie/32_3D/${paddedNumber}_3D_01.mp4`;
                }
                
                    const videoItem = document.createElement('div');
                    videoItem.style.cssText = `
                    background: white;
                    border-radius: 15px;
                    padding: 15px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                    text-align: center;
                `;
                    
                    videoItem.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <img src="${icon3DPath}" 
                             alt="${character.name}" 
                             style="width: 100%; max-width: 200px; height: auto; border-radius: 10px;"
                             onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width:100%;height:150px;display:flex;align-items:center;justify-content:center;font-size:24px;color:#666;\\'>${character.name}</div>'">
                    </div>
                    <h4 style="font-size: 1rem; margin-bottom: 10px; color: #333;">${character.name}</h4>
                    <button onclick="play3DMovie('${video3DPath}', '${character.name}')" style="
                        background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%);
                        color: white;
                        border: none;
                        padding: 8px 20px;
                        border-radius: 20px;
                        font-size: 0.9rem;
                        font-weight: bold;
                        cursor: pointer;
                        transition: all 0.3s;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        gap: 8px;
                        width: 100%;
                        margin: 0 auto;
                    "><span>🎬</span></button>
                `;
                
                gallery.appendChild(videoItem);
            });
        }
        
        // 3Dムービーを再生
        function play3DMovie(videoPath, characterName) {
            // 既存のポップアップがあれば削除
            const existingPopup = document.getElementById('3d-movie-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // 新しいポップアップを作成
            const popup = document.createElement('div');
            popup.id = '3d-movie-popup';
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.95);
                z-index: 10000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            popup.innerHTML = `
                <div style="width: 100%; max-width: 900px; position: relative;">
                    <button onclick="close3DMoviePopup()" style="
                        position: absolute;
                        top: -40px;
                        right: 0;
                        background: rgba(255, 255, 255, 0.3);
                        color: white;
                        border: none;
                        padding: 10px 20px;
                        border-radius: 20px;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                        z-index: 10001;
                    ">✕ 閉じる</button>
                    <h3 style="color: white; text-align: center; margin-bottom: 20px; font-size: 1.5rem;">${characterName}</h3>
                    <video id="3d-movie-player" controls autoplay style="width: 100%; max-height: 80vh; border-radius: 10px;">
                            <source src="${videoPath}" type="video/mp4">
                            お使いのブラウザは動画をサポートしていません。
                        </video>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // 動画を再生
            const player = document.getElementById('3d-movie-player');
            if (player) {
                // 動画の読み込み完了を待ってから再生
                player.addEventListener('loadeddata', () => {
                player.play().catch(err => {
                    console.error('動画再生エラー:', err);
                        // エラーが発生した場合は、エラーメッセージを表示せずに静かに処理
                    });
                });
                // エラーが発生した場合の処理
                player.addEventListener('error', (e) => {
                    console.error('動画読み込みエラー:', e);
                    // エラーが発生した場合は、ポップアップを閉じる
                    close3DMoviePopup();
                });
            }
            
            // ESCキーで閉じる
            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    close3DMoviePopup();
                }
            };
            document.addEventListener('keydown', handleEsc);
            popup._escHandler = handleEsc;
        }
        
        // 3Dムービーポップアップを閉じる
        function close3DMoviePopup() {
            const popup = document.getElementById('3d-movie-popup');
            if (popup) {
                const player = document.getElementById('3d-movie-player');
                if (player) {
                    player.pause();
                    player.src = '';
                }
                if (popup._escHandler) {
                    document.removeEventListener('keydown', popup._escHandler);
                }
                popup.remove();
            }
        }
        
        // キャラクター紹介動画のマッピング（20_movie/30_キャラクター紹介）
        // キャラクターIDから動画番号へのマッピング
        const CHARACTER_MOVIE_NUMBER_MAP = {
            ikisui: '01',
            genkai: '02',
            muhai: '03',
            kokou: '04',
            kokoro: '05',
            seijitsu: '06',
            kyousou: '07',
            mypace: '08',
            yurufuwa: '09',
            kakure: '10',
            ohitoyoshi: '11',
            genjitsu: '012',
            katei: '13',
            balancer: '14',
            seika: '15',
            jiyujin: '16'
        };

        // キャラクターの動画を取得（解放済みのみ）
        function getCharacterMovies(characterId) {
            if (!characterId) return [];
            const state = gameState.characterStates?.[characterId];
            if (!state || !Array.isArray(state.unlockedMovies)) {
                return [];
            }
            const invalidMoviePrefixes = [
                '20_movie/01_紹介動画',
                '20_movie/02_特別動画1',
                '20_movie/03_特別動画2',
                '20_movie/04_3D動画1',
                '20_movie/05_3D動画2',
                '20_movie/06_3D動画3'
            ];
            // 文字列とオブジェクトの両方に対応し、不正なパスを除外
            return state.unlockedMovies
                .map(movie => {
                if (typeof movie === 'string') {
                    // 文字列の場合はオブジェクトに変換
                    return {
                        path: movie,
                        label: movie.split('/').pop()
                    };
                }
                // オブジェクトの場合はそのまま返す
                return movie;
                })
                .filter(movie => movie && movie.path && !invalidMoviePrefixes.some(prefix => movie.path.startsWith(prefix)));
        }

        // 動画を解放
        function unlockCharacterMovie(characterId, moviePath, movieLabel) {
            if (!characterId || !moviePath) return;
            const state = ensureCharacterState(CHARACTERS.find(c => c.id === characterId));
            if (!state) return;
            
            if (!Array.isArray(state.unlockedMovies)) {
                state.unlockedMovies = [];
            }
            
            // 既に解放済みかチェック
            const alreadyUnlocked = state.unlockedMovies.some(m => m.path === moviePath);
            if (!alreadyUnlocked) {
                state.unlockedMovies.push({
                    path: moviePath,
                    label: movieLabel || moviePath.split('/').pop()
                });
                console.log('動画を解放:', characterId, moviePath);
            }
        }

        // キャラクター獲得時に30_キャラクター紹介の動画を解放
        function unlockCharacterIntroMovie(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) return;
            
            // 30_キャラクター紹介の動画を解放（既存のCHARACTER_INTRO_MOVIESの定義に基づく）
            const introMovieMap = {
                ikisui: [{ path: '20_movie/30_キャラクター紹介/01キャラ紹介01.mp4', label: '01キャラ紹介01' }],
                genkai: [{ path: '20_movie/30_キャラクター紹介/02キャラ紹介02.mp4', label: '02キャラ紹介02' }],
                muhai: [{ path: '20_movie/30_キャラクター紹介/03キャラ紹介01.mp4', label: '03キャラ紹介01' }],
                kokou: [{ path: '20_movie/30_キャラクター紹介/04キャラ紹介02.mp4', label: '04キャラ紹介02' }],
                kokoro: [{ path: '20_movie/30_キャラクター紹介/05キャラ紹介01.mp4', label: '05キャラ紹介01' }],
                seijitsu: [{ path: '20_movie/30_キャラクター紹介/06キャラ紹介01.mp4', label: '06キャラ紹介01' }],
                kyousou: [{ path: '20_movie/30_キャラクター紹介/07キャラ紹介01.mp4', label: '07キャラ紹介01' }],
                mypace: [{ path: '20_movie/30_キャラクター紹介/08キャラ紹介01.mp4', label: '08キャラ紹介01' }],
                yurufuwa: [{ path: '20_movie/30_キャラクター紹介/09キャラ紹介02.mp4', label: '09キャラ紹介02' }],
                kakure: [{ path: '20_movie/30_キャラクター紹介/10キャラ紹介01.mp4', label: '10キャラ紹介01' }],
                ohitoyoshi: [{ path: '20_movie/30_キャラクター紹介/11キャラ紹介01.mp4', label: '11キャラ紹介01' }],
                genjitsu: [
                    { path: '20_movie/30_キャラクター紹介/012キャラ紹介01.mp4', label: '012キャラ紹介01' },
                    { path: '20_movie/30_キャラクター紹介/012キャラ紹介02.mp4', label: '012キャラ紹介02' }
                ],
                katei: [{ path: '20_movie/30_キャラクター紹介/13キャラ紹介01.mp4', label: '13キャラ紹介01' }],
                balancer: [{ path: '20_movie/30_キャラクター紹介/14キャラ紹介01.mp4', label: '14キャラ紹介01' }],
                seika: [{ path: '20_movie/30_キャラクター紹介/15キャラ紹介01.mp4', label: '15キャラ紹介01' }],
                jiyujin: [
                    { path: '20_movie/30_キャラクター紹介/16キャラ紹介01.mp4', label: '16キャラ紹介01' },
                    { path: '20_movie/30_キャラクター紹介/16キャラ紹介02.mp4', label: '16キャラ紹介02' }
                ]
            };
            
            const introMovies = introMovieMap[characterId];
            if (introMovies) {
                introMovies.forEach(movie => {
                    unlockCharacterMovie(characterId, movie.path, movie.label);
                });
            }
        }

        // 係長昇格時に31_キャラ特別01の動画を解放
        function unlockCharacterSpecial01Movie(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) return;
            
            let moviePath = `20_movie/31_キャラ特別01/${num}キャラ特別01.mp4`;
            // 特殊な命名規則の対応
            if (characterId === 'yurufuwa') {
                moviePath = `20_movie/31_キャラ特別01/09キャラ特別101.mp4`;
            } else if (characterId === 'kakure') {
                moviePath = `20_movie/31_キャラ特別01/10キャラ特別01..mp4`;
            }
            
            unlockCharacterMovie(characterId, moviePath, `${num}キャラ特別01`);
        }

        // 動画ファイル名から対象キャラクター番号を抽出
        function getCharacterNumbersFromMovieName(fileName) {
            // ファイル名の先頭から数字を抽出（例: "02,13_キャラ特別02.mp4" → ["02", "13"]）
            const match = fileName.match(/^(\d+(?:,\d+)*)_/);
            if (match) {
                return match[1].split(',');
            }
            // 単一の数字の場合（例: "02_キャラ特別02.mp4" → ["02"]）
            const singleMatch = fileName.match(/^(\d+)_/);
            if (singleMatch) {
                return [singleMatch[1]];
            }
            // 数字のみで始まる場合（例: "012キャラ特別02.mp4" → ["012"]）
            const numberOnlyMatch = fileName.match(/^(\d+)/);
            if (numberOnlyMatch) {
                return [numberOnlyMatch[1]];
            }
            return null;
        }
        
        // キャラクター番号からキャラクターIDを取得
        function getCharacterIdsByNumbers(numbers) {
            const characterIds = [];
            Object.entries(CHARACTER_MOVIE_NUMBER_MAP).forEach(([id, num]) => {
                if (numbers.includes(num)) {
                    characterIds.push(id);
                }
            });
            return characterIds;
        }
        
        // 主任昇格時に32_キャラ特別02の動画を解放
        function unlockCharacterSpecial02Movie(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            console.log('主任昇格時の動画解放開始:', characterId, '番号:', num);
            
            // 32_キャラ特別02の動画ファイルを確認（実際に存在するファイルをすべて含める）
            const movieFiles = [
                { file: '01_キャラ特別02.mp4', numbers: ['01'] },
                { file: '02,13_キャラ特別02.mp4', numbers: ['02', '13'] },
                { file: '03,12_キャラ特別02.mp4', numbers: ['03', '12'] },
                { file: '04,11_キャラ特別02.mp4', numbers: ['04', '11'] },
                { file: '05,15_キャラ特別02.mp4', numbers: ['05', '15'] },
                { file: '06_キャラ特別02.mp4', numbers: ['06'] },
                { file: '07,09_キャラ特別02.mp4', numbers: ['07', '09'] },
                { file: '08_キャラ特別02.mp4', numbers: ['08'] },
                { file: '10_キャラ特別02.mp4', numbers: ['10'] },
                { file: '14,16_キャラ特別02.mp4', numbers: ['14', '16'] },
                // 012（genjitsu）用
                { file: '012キャラ特別02.mp4', numbers: ['012'] }
            ];
            
            let found = false;
            for (const movieFile of movieFiles) {
                if (movieFile.numbers.includes(num)) {
                    const moviePath = `20_movie/32_キャラ特別02/${movieFile.file}`;
                    const label = `${num}キャラ特別02`;
                    console.log('動画を解放:', moviePath, label);
                    unlockCharacterMovie(characterId, moviePath, label);
                    found = true;
                    break;
                }
            }
            
            // 動画が見つからない場合は、デフォルトパターンを試す
            if (!found) {
                const defaultPath = `20_movie/32_キャラ特別02/${num}_キャラ特別02.mp4`;
                const label = `${num}キャラ特別02`;
                console.log('デフォルトパスで動画を解放:', defaultPath, label);
                unlockCharacterMovie(characterId, defaultPath, label);
            }
        }
        
        // キャラ特別03の動画を解放（新規追加）
        function unlockCharacterSpecial03Movie(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) return;
            
            // 33_キャラ特別03の動画ファイルを確認
            const movieFiles = [
                { file: '02,13_キャラ特別03.mp4', label: 'キャラ特別03' },
                { file: '012キャラ特別03.mp4', label: '012キャラ特別03' },
                { file: '06_キャラ特別03.mp4', label: '06_キャラ特別03' },
                { file: '08_キャラ特別03.mp4', label: '08_キャラ特別03' },
                { file: '16キャラ特別03.mp4', label: '16キャラ特別03' },
                // その他のキャラクター用（個別ファイルがある場合）
                { file: `${num}_キャラ特別03.mp4`, label: `${num}キャラ特別03` },
                { file: `${num}キャラ特別03.mp4`, label: `${num}キャラ特別03` }
            ];
            
            let found = false;
            for (const movieFile of movieFiles) {
                const numbers = getCharacterNumbersFromMovieName(movieFile.file);
                if (numbers && numbers.includes(num)) {
                    const moviePath = `20_movie/33_キャラ特別03/${movieFile.file}`;
                    unlockCharacterMovie(characterId, moviePath, movieFile.label);
                    found = true;
                    break;
                }
            }
            
            // 動画が見つからない場合は、デフォルトパターンを試す
            if (!found) {
                const defaultPath = `20_movie/33_キャラ特別03/${num}キャラ特別03.mp4`;
                unlockCharacterMovie(characterId, defaultPath, `${num}キャラ特別03`);
            }
        }

        // 部長昇格時に32_3Dの動画1を解放
        function unlockCharacter3DMovie(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) return;
            
            // 32_3Dの動画1のみを解放（3D_02は事業部長で解放）
            const moviePath = `20_movie/32_3D/${num}_3D_01.mp4`;
            unlockCharacterMovie(characterId, moviePath, `${num}_3D_01`);
        }
        
        // 事業部長昇格時に34_3D_02の動画を解放（追加）
        function unlockCharacter3DMovie02(characterId) {
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) return;
            
            // 34_3D_02の動画ファイルを確認
            const movieFiles = [
                { file: '02,13_3D_02.mp4', label: '3D_02' },
                { file: '09_3D_02.mp4', label: '09_3D_02' },
                // その他のキャラクター用（個別ファイルがある場合）
                { file: `${num}_3D_02.mp4`, label: `${num}_3D_02` }
            ];
            
            let found = false;
            for (const movieFile of movieFiles) {
                const numbers = getCharacterNumbersFromMovieName(movieFile.file);
                if (numbers && numbers.includes(num)) {
                    const moviePath = `20_movie/34_3D_02/${movieFile.file}`;
                    unlockCharacterMovie(characterId, moviePath, movieFile.label);
                    found = true;
                    break;
                }
            }
            
            // 動画が見つからない場合は、デフォルトパターンを試す
            if (!found) {
                const defaultPath = `20_movie/34_3D_02/${num}_3D_02.mp4`;
                unlockCharacterMovie(characterId, defaultPath, `${num}_3D_02`);
            }
        }

        // 全キャラクターの動画確認（rank 8まで）
        function checkAllCharacterMovies() {
            const allCharacters = Object.keys(CHARACTER_MOVIE_NUMBER_MAP);
            const missingMovies = [];
            const report = [];
            
            report.push('=== Rank 8までの全キャラクター動画確認 ===\n');
            
            // 実際のファイルリスト（実際のフォルダから取得した情報）
            const actualFiles = {
                '32_キャラ特別02': [
                    '01_キャラ特別02.mp4',
                    '02,13_キャラ特別02.mp4',
                    '03,12_キャラ特別02.mp4',
                    '04,11_キャラ特別02.mp4',
                    '05,15_キャラ特別02.mp4',
                    '06_キャラ特別02.mp4',
                    '07,09_キャラ特別02.mp4',
                    '08_キャラ特別02.mp4',
                    '10_キャラ特別02.mp4',
                    '14,16_キャラ特別02.mp4'
                ],
                '33_キャラ特別03': [
                    '01,13_キャラ特別03.mp4',
                    '02,08_キャラ特別03.mp4',
                    '03,14_キャラ特別03.mp4',
                    '04,06_キャラ特別03.mp4',
                    '05,09_キャラ特別03.mp4',
                    '07,10_キャラ特別03.mp4',
                    '11,15_キャラ特別03.mp4',
                    '12_キャラ特別03.mp4',
                    '16_キャラ特別03.mp4'
                ],
                '34_3D_02': [
                    '01,16_3D_02.mp4',
                    '02,10_3D_02.mp4',
                    '03,11_3D_02.mp4',
                    '04,13_3D_02.mp4',
                    '05,12_3D_02.mp4',
                    '06_3D_02.mp4',
                    '07,15_3D_02.mp4',
                    '08_3D_02.mp4',
                    '09,14_3D_02.mp4'
                ]
            };
            
            // ファイル名からキャラクター番号を抽出する関数（012と12の両方を考慮）
            function getNumbersFromFileName(fileName) {
                const match = fileName.match(/^(\d+(?:,\d+)*)_/);
                if (match) {
                    return match[1].split(',').map(n => {
                        // 012と12の両方を考慮（012は'012'として、12は'12'として扱う）
                        if (n === '12') return '012'; // ファイル名の'12'はキャラクター番号'012'に対応
                        return n;
                    });
                }
                return [];
            }
            
            // 各キャラクターがどのファイルに含まれているかを確認
            function checkCharacterCoverage(folder, files, rank, movieType) {
                const covered = new Set();
                const coverage = {};
                
                files.forEach(file => {
                    const numbers = getNumbersFromFileName(file);
                    numbers.forEach(num => {
                        covered.add(num);
                        if (!coverage[num]) coverage[num] = [];
                        coverage[num].push(file);
                    });
                });
                
                const missing = [];
                allCharacters.forEach(id => {
                    const num = CHARACTER_MOVIE_NUMBER_MAP[id];
                    if (!covered.has(num)) {
                        const char = CHARACTERS.find(c => c.id === id);
                        missing.push({
                            id: id,
                            num: num,
                            name: char?.name || id
                        });
                    }
                });
                
                if (missing.length > 0) {
                    missingMovies.push({
                        rank: rank,
                        movieType: movieType,
                        characters: missing.map(m => `${m.num} (${m.name})`),
                        expectedPath: missing.map(m => `20_movie/${folder}/${m.num}${movieType.includes('3D') ? '_3D_02' : movieType.includes('特別03') ? 'キャラ特別03' : 'キャラ特別02'}.mp4`)
                    });
                    report.push(`❌ Rank ${rank} (${movieType}): 以下の${missing.length}キャラクターの動画が不足しています:`);
                    missing.forEach(m => {
                        report.push(`   - ${m.num} (${m.name}): 20_movie/${folder}/${m.num}${movieType.includes('3D') ? '_3D_02' : movieType.includes('特別03') ? 'キャラ特別03' : 'キャラ特別02'}.mp4`);
                    });
                } else {
                    report.push(`✅ Rank ${rank} (${movieType}): 全16キャラクター対応`);
                    // 詳細なカバレッジ情報を追加
                    report.push(`   カバレッジ詳細:`);
                    Object.keys(CHARACTER_MOVIE_NUMBER_MAP).forEach(id => {
                        const num = CHARACTER_MOVIE_NUMBER_MAP[id];
                        const char = CHARACTERS.find(c => c.id === id);
                        if (coverage[num]) {
                            report.push(`   - ${num} (${char?.name || id}): ${coverage[num].join(', ')}`);
                        }
                    });
                }
            }
            
            // rank 1（係長）: キャラ特別01
            report.push('✅ Rank 1（係長）: キャラ特別01 - 全16キャラクター対応（デフォルトパターン + 特殊対応）');
            
            // rank 2（主任）: キャラ特別02
            report.push('\n--- Rank 2（主任）: キャラ特別02 ---');
            checkCharacterCoverage('32_キャラ特別02', actualFiles['32_キャラ特別02'], 2, 'キャラ特別02');
            
            // rank 3（課長代理）: キャラ特別03
            report.push('\n--- Rank 3（課長代理）: キャラ特別03 ---');
            checkCharacterCoverage('33_キャラ特別03', actualFiles['33_キャラ特別03'], 3, 'キャラ特別03');
            
            // rank 6（部長）: 3D動画1
            report.push('\n✅ Rank 6（部長）: 3D動画1 - 全16キャラクター対応（デフォルトパターン: {num}_3D_01.mp4）');
            
            // rank 8（事業部長）: 3D_02
            report.push('\n--- Rank 8（事業部長）: 3D_02 ---');
            checkCharacterCoverage('34_3D_02', actualFiles['34_3D_02'], 8, '3D_02');
            
            // 結果を表示
            console.log(report.join('\n'));
            
            // ポップアップで結果を表示
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                border-radius: 20px;
                padding: 30px;
                box-shadow: 0 20px 60px rgba(0,0,0,0.3);
                z-index: 10008;
                max-width: 90%;
                max-height: 80vh;
                overflow-y: auto;
            `;
            
            let dialogContent = '<h2 style="margin-top: 0; color: #333;">Rank 8までの動画確認結果</h2>';
            dialogContent += '<div style="font-family: monospace; font-size: 0.9rem; line-height: 1.6;">';
            dialogContent += report.join('<br>');
            dialogContent += '</div>';
            
            if (missingMovies.length === 0) {
                dialogContent += '<div style="margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 10px; color: #155724;"><strong>✅ 全16キャラクターの動画が揃っています！</strong></div>';
            } else {
                dialogContent += '<div style="margin-top: 20px; padding: 15px; background: #fff3cd; border-radius: 10px; color: #856404;">';
                dialogContent += '<strong>⚠️ 以下の動画が不足している可能性があります（デフォルトパターンで対応される可能性もあります）:</strong><br><br>';
                missingMovies.forEach(missing => {
                    dialogContent += `<strong>Rank ${missing.rank} (${missing.movieType}):</strong><br>`;
                    missing.characters.forEach((char, idx) => {
                        dialogContent += `&nbsp;&nbsp;${char}: ${missing.expectedPath[idx]}<br>`;
                    });
                    dialogContent += '<br>';
                });
                dialogContent += '</div>';
            }
            
            dialogContent += '<button onclick="this.closest(\'div\').remove()" style="margin-top: 20px; padding: 10px 30px; background: #007bff; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1rem;">閉じる</button>';
            
            dialog.innerHTML = dialogContent;
            document.body.appendChild(dialog);
            
            if (missingMovies.length === 0) {
                return true;
            } else {
                return false;
            }
        }
        
        // グローバルスコープに公開（コンソールから実行可能）
        window.checkAllCharacterMovies = checkAllCharacterMovies;
        
        // 初期キャラクター選択時にキャラクター紹介動画を再生
        async function playCharacterIntroOnInitialSelection(character) {
            if (!character) {
                return;
            }

            const characterId = character.id;
            
            // 動画を直接取得（unlockCharacterIntroMovieで解放された動画）
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 30_キャラクター紹介の動画パスを取得
            const introMovieMap = {
                ikisui: [{ path: '20_movie/30_キャラクター紹介/01キャラ紹介01.mp4', label: '01キャラ紹介01' }],
                genkai: [{ path: '20_movie/30_キャラクター紹介/02キャラ紹介02.mp4', label: '02キャラ紹介02' }],
                muhai: [{ path: '20_movie/30_キャラクター紹介/03キャラ紹介01.mp4', label: '03キャラ紹介01' }],
                kokou: [{ path: '20_movie/30_キャラクター紹介/04キャラ紹介02.mp4', label: '04キャラ紹介02' }],
                kokoro: [{ path: '20_movie/30_キャラクター紹介/05キャラ紹介01.mp4', label: '05キャラ紹介01' }],
                seijitsu: [{ path: '20_movie/30_キャラクター紹介/06キャラ紹介01.mp4', label: '06キャラ紹介01' }],
                kyousou: [{ path: '20_movie/30_キャラクター紹介/07キャラ紹介01.mp4', label: '07キャラ紹介01' }],
                mypace: [{ path: '20_movie/30_キャラクター紹介/08キャラ紹介01.mp4', label: '08キャラ紹介01' }],
                yurufuwa: [{ path: '20_movie/30_キャラクター紹介/09キャラ紹介02.mp4', label: '09キャラ紹介02' }],
                kakure: [{ path: '20_movie/30_キャラクター紹介/10キャラ紹介01.mp4', label: '10キャラ紹介01' }],
                ohitoyoshi: [{ path: '20_movie/30_キャラクター紹介/11キャラ紹介01.mp4', label: '11キャラ紹介01' }],
                genjitsu: [
                    { path: '20_movie/30_キャラクター紹介/012キャラ紹介01.mp4', label: '012キャラ紹介01' },
                    { path: '20_movie/30_キャラクター紹介/012キャラ紹介02.mp4', label: '012キャラ紹介02' }
                ],
                katei: [{ path: '20_movie/30_キャラクター紹介/13キャラ紹介01.mp4', label: '13キャラ紹介01' }],
                balancer: [{ path: '20_movie/30_キャラクター紹介/14キャラ紹介01.mp4', label: '14キャラ紹介01' }],
                seika: [{ path: '20_movie/30_キャラクター紹介/15キャラ紹介01.mp4', label: '15キャラ紹介01' }],
                jiyujin: [
                    { path: '20_movie/30_キャラクター紹介/16キャラ紹介01.mp4', label: '16キャラ紹介01' },
                    { path: '20_movie/30_キャラクター紹介/16キャラ紹介02.mp4', label: '16キャラ紹介02' }
                ]
            };
            
            const introMovies = introMovieMap[characterId];
            if (!introMovies || introMovies.length === 0) {
                console.log('30_キャラクター紹介の動画が見つかりません:', characterId);
                return;
            }
            
            // 最初の動画を再生
            const introMovie = introMovies[0];

            // 動画を再生するオーバーレイを作成
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10010;
                padding: 20px;
                box-sizing: border-box;
            `;

            const container = document.createElement('div');
            container.style.cssText = `
                position: relative;
                width: min(90vw, 800px);
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 16px;
            `;

            const video = document.createElement('video');
            video.src = introMovie.path;
            video.style.cssText = `
                width: 100%;
                max-width: 800px;
                height: auto;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            `;
            video.controls = false;
            video.autoplay = true;
            video.muted = false;
            video.playsInline = true;

            const title = document.createElement('div');
            title.textContent = `${character.name}の紹介動画`;
            title.style.cssText = `
                color: #fff;
                font-size: 1.2rem;
                font-weight: 700;
                text-align: center;
            `;

            const skipButton = document.createElement('button');
            skipButton.textContent = 'スキップ';
            skipButton.style.cssText = `
                padding: 10px 24px;
                border-radius: 999px;
                border: none;
                background: rgba(255, 255, 255, 0.9);
                color: #333;
                font-weight: 600;
                cursor: pointer;
                font-size: 1rem;
                transition: background 0.2s ease;
            `;
            skipButton.onmouseenter = () => {
                skipButton.style.background = 'rgba(255, 255, 255, 1)';
            };
            skipButton.onmouseleave = () => {
                skipButton.style.background = 'rgba(255, 255, 255, 0.9)';
            };

            let resolvePromise = null;
            const closeOverlay = () => {
                video.pause();
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
                if (resolvePromise) {
                    resolvePromise();
                }
            };

            const escHandler = (event) => {
                if (event.key === 'Escape') {
                    closeOverlay();
                }
            };

            container.appendChild(title);
            container.appendChild(video);
            container.appendChild(skipButton);
            overlay.appendChild(container);
            document.body.appendChild(overlay);

            // 動画の読み込みエラーを処理
            video.addEventListener('error', (e) => {
                console.error('動画の読み込みエラー:', e);
                showToast('動画の読み込みに失敗しました', 'error');
                closeOverlay();
            });

            // 動画の再生を待つ（Promiseでラップ）
            return new Promise((resolve) => {
                resolvePromise = resolve;
                video.addEventListener('ended', closeOverlay, { once: true });
                skipButton.addEventListener('click', closeOverlay);
                overlay.addEventListener('click', (event) => {
                    if (event.target === overlay) {
                        closeOverlay();
                    }
                });
                document.addEventListener('keydown', escHandler);
            });
        }
        
        // 係長昇格時にキャラクター紹介動画を再生
        async function playCharacterIntroOnPromotion() {
            if (!gameState.selectedCharacter) {
                return;
            }

            const characterId = gameState.selectedCharacter.id;
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 少し待ってから動画を取得（解放処理が完了するまで）
            await new Promise(resolve => setTimeout(resolve, 200));
            
            const movies = getCharacterMovies(characterId);
            
            // 31_キャラ特別01の動画を探す
            let special01Movie = movies.find(m => m.path && m.path.includes('31_キャラ特別01'));
            
            // 動画が見つからない場合は、直接パスを構築して試す
            if (!special01Movie) {
                console.log('31_キャラ特別01の動画が見つかりません。フォールバックパスを試します:', characterId);
                
                let moviePath = `20_movie/31_キャラ特別01/${num}キャラ特別01.mp4`;
                // 特殊な命名規則の対応
                if (characterId === 'yurufuwa') {
                    moviePath = `20_movie/31_キャラ特別01/09キャラ特別101.mp4`;
                } else if (characterId === 'kakure') {
                    moviePath = `20_movie/31_キャラ特別01/10キャラ特別01..mp4`;
                }
                
                special01Movie = { path: moviePath, label: `${num}キャラ特別01` };
            }

            if (special01Movie && special01Movie.path) {
                await playCharacterSpecialMovie(special01Movie, `${gameState.selectedCharacter.name}の紹介動画`);
            } else {
                console.error('動画パスを取得できませんでした:', characterId);
            }
        }

        // 主任昇格時にキャラクター特別動画を再生
        async function playCharacterSpecial02OnPromotion() {
            if (!gameState.selectedCharacter) {
                return;
            }

            const characterId = gameState.selectedCharacter.id;
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 少し待ってから動画を取得（解放処理が完了するまで）
            await new Promise(resolve => setTimeout(resolve, 200));
            
            const movies = getCharacterMovies(characterId);
            
            // 32_キャラ特別02の動画を探す
            let special02Movie = movies.find(m => m.path && m.path.includes('32_キャラ特別02'));
            
            // 動画が見つからない場合は、直接パスを構築して試す
            if (!special02Movie) {
                console.log('32_キャラ特別02の動画が見つかりません。フォールバックパスを試します:', characterId);
                
                // 実際に存在するファイルパターンをすべて試す
                const movieFiles = [
                    { file: '01_キャラ特別02.mp4', numbers: ['01'] },
                    { file: '02,13_キャラ特別02.mp4', numbers: ['02', '13'] },
                    { file: '03,12_キャラ特別02.mp4', numbers: ['03', '12'] },
                    { file: '04,11_キャラ特別02.mp4', numbers: ['04', '11'] },
                    { file: '05,15_キャラ特別02.mp4', numbers: ['05', '15'] },
                    { file: '06_キャラ特別02.mp4', numbers: ['06'] },
                    { file: '07,09_キャラ特別02.mp4', numbers: ['07', '09'] },
                    { file: '08_キャラ特別02.mp4', numbers: ['08'] },
                    { file: '10_キャラ特別02.mp4', numbers: ['10'] },
                    { file: '14,16_キャラ特別02.mp4', numbers: ['14', '16'] },
                    { file: '012キャラ特別02.mp4', numbers: ['012'] }
                ];
                
                let foundPath = null;
                for (const movieFile of movieFiles) {
                    if (movieFile.numbers.includes(num)) {
                        foundPath = `20_movie/32_キャラ特別02/${movieFile.file}`;
                        break;
                    }
                }
                
                // 見つからなかった場合はデフォルトパスを試す
                if (!foundPath) {
                    foundPath = `20_movie/32_キャラ特別02/${num}_キャラ特別02.mp4`;
                }
                
                special02Movie = { path: foundPath, label: `${num}キャラ特別02` };
                console.log('フォールバックパスを使用:', foundPath);
            }

            if (special02Movie && special02Movie.path) {
                await playCharacterSpecialMovie(special02Movie, `${gameState.selectedCharacter.name}の特別動画`);
            } else {
                console.error('動画パスを取得できませんでした:', characterId);
            }
        }

        // 課長代理昇格時にキャラクター特別動画を再生
        async function playCharacterSpecial03OnPromotion() {
            if (!gameState.selectedCharacter) {
                return;
            }

            const characterId = gameState.selectedCharacter.id;
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 少し待ってから動画を取得（解放処理が完了するまで）
            await new Promise(resolve => setTimeout(resolve, 200));
            
            const movies = getCharacterMovies(characterId);
            
            // 33_キャラ特別03の動画を探す
            let special03Movie = movies.find(m => m.path && m.path.includes('33_キャラ特別03'));
            
            // 動画が見つからない場合は、直接パスを構築して試す
            if (!special03Movie) {
                console.log('33_キャラ特別03の動画が見つかりません。フォールバックパスを試します:', characterId);
                
                // 複数のパターンを試す
                const possiblePaths = [
                    `20_movie/33_キャラ特別03/${num}キャラ特別03.mp4`,
                    `20_movie/33_キャラ特別03/${num}_キャラ特別03.mp4`
                ];
                
                // 動画ファイル名から対象キャラクターを判定するパターンも試す
                const movieFiles = [
                    { file: '02,13_キャラ特別03.mp4', numbers: ['02', '13'] },
                    { file: '012キャラ特別03.mp4', numbers: ['012'] },
                    { file: '06_キャラ特別03.mp4', numbers: ['06'] },
                    { file: '08_キャラ特別03.mp4', numbers: ['08'] },
                    { file: '16キャラ特別03.mp4', numbers: ['16'] }
                ];
                
                for (const movieFile of movieFiles) {
                    if (movieFile.numbers.includes(num)) {
                        possiblePaths.unshift(`20_movie/33_キャラ特別03/${movieFile.file}`);
                        break;
                    }
                }
                
                // 最初に見つかったパスを使用
                special03Movie = { path: possiblePaths[0], label: `${num}キャラ特別03` };
            }

            if (special03Movie && special03Movie.path) {
                await playCharacterSpecialMovie(special03Movie, `${gameState.selectedCharacter.name}の特別動画`);
            } else {
                console.error('動画パスを取得できませんでした:', characterId);
            }
        }

        // 部長昇格時に3D動画を再生
        async function playCharacter3DMovieOnPromotion() {
            if (!gameState.selectedCharacter) {
                return;
            }

            const characterId = gameState.selectedCharacter.id;
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 少し待ってから動画を取得（解放処理が完了するまで）
            await new Promise(resolve => setTimeout(resolve, 200));
            
            const movies = getCharacterMovies(characterId);
            
            // 32_3Dの動画を探す
            let threeDMovie = movies.find(m => m.path && m.path.includes('32_3D') && m.path.includes('_3D_01'));
            
            // 動画が見つからない場合は、直接パスを構築して試す
            if (!threeDMovie) {
                console.log('32_3Dの動画が見つかりません。フォールバックパスを試します:', characterId);
                const moviePath = `20_movie/32_3D/${num}_3D_01.mp4`;
                threeDMovie = { path: moviePath, label: `${num}_3D_01` };
            }

            if (threeDMovie && threeDMovie.path) {
                await playCharacterSpecialMovie(threeDMovie, `${gameState.selectedCharacter.name}の3D動画`);
            } else {
                console.error('動画パスを取得できませんでした:', characterId);
            }
        }

        // 事業部長昇格時に3D動画2を再生
        async function playCharacter3DMovie02OnPromotion() {
            if (!gameState.selectedCharacter) {
                return;
            }

            const characterId = gameState.selectedCharacter.id;
            const num = CHARACTER_MOVIE_NUMBER_MAP[characterId];
            if (!num) {
                console.log('キャラクター番号が見つかりません:', characterId);
                return;
            }
            
            // 少し待ってから動画を取得（解放処理が完了するまで）
            await new Promise(resolve => setTimeout(resolve, 200));
            
            const movies = getCharacterMovies(characterId);
            
            // 34_3D_02の動画を探す
            let threeDMovie02 = movies.find(m => m.path && m.path.includes('34_3D_02'));
            
            // 動画が見つからない場合は、直接パスを構築して試す
            if (!threeDMovie02) {
                console.log('34_3D_02の動画が見つかりません。フォールバックパスを試します:', characterId);
                
                // 複数のパターンを試す
                const possiblePaths = [
                    `20_movie/34_3D_02/${num}_3D_02.mp4`
                ];
                
                // 動画ファイル名から対象キャラクターを判定するパターンも試す
                const movieFiles = [
                    { file: '02,13_3D_02.mp4', numbers: ['02', '13'] },
                    { file: '09_3D_02.mp4', numbers: ['09'] }
                ];
                
                for (const movieFile of movieFiles) {
                    if (movieFile.numbers.includes(num)) {
                        possiblePaths.unshift(`20_movie/34_3D_02/${movieFile.file}`);
                        break;
                    }
                }
                
                // 最初に見つかったパスを使用
                threeDMovie02 = { path: possiblePaths[0], label: `${num}_3D_02` };
            }

            if (threeDMovie02 && threeDMovie02.path) {
                await playCharacterSpecialMovie(threeDMovie02, `${gameState.selectedCharacter.name}の3D動画2`);
            } else {
                console.error('動画パスを取得できませんでした:', characterId);
            }
        }

        // キャラクター特別動画を再生する共通関数
        async function playCharacterSpecialMovie(movie, titleText) {
            if (!movie || !movie.path) {
                console.error('動画情報が不正です:', movie);
                return;
            }

            // 動画を再生するオーバーレイを作成
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10010;
                padding: 20px;
                box-sizing: border-box;
            `;

            const container = document.createElement('div');
            container.style.cssText = `
                position: relative;
                width: min(90vw, 800px);
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 16px;
            `;

            const video = document.createElement('video');
            video.src = movie.path;
            video.style.cssText = `
                width: 100%;
                max-width: 800px;
                height: auto;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            `;
            video.controls = false;
            video.autoplay = true;
            video.muted = false;
            video.playsInline = true;

            const title = document.createElement('div');
            title.textContent = titleText;
            title.style.cssText = `
                color: #fff;
                font-size: 1.2rem;
                font-weight: 700;
                text-align: center;
            `;

            const skipButton = document.createElement('button');
            skipButton.textContent = 'スキップ';
            skipButton.style.cssText = `
                padding: 10px 24px;
                border-radius: 999px;
                border: none;
                background: rgba(255, 255, 255, 0.9);
                color: #333;
                font-weight: 600;
                cursor: pointer;
                font-size: 1rem;
                transition: background 0.2s ease;
            `;
            skipButton.onmouseenter = () => {
                skipButton.style.background = 'rgba(255, 255, 255, 1)';
            };
            skipButton.onmouseleave = () => {
                skipButton.style.background = 'rgba(255, 255, 255, 0.9)';
            };

            const closeOverlay = () => {
                video.pause();
                overlay.remove();
                document.removeEventListener('keydown', escHandler);
            };

            const escHandler = (event) => {
                if (event.key === 'Escape') {
                    closeOverlay();
                }
            };

            video.addEventListener('ended', closeOverlay);
            skipButton.addEventListener('click', closeOverlay);
            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) {
                    closeOverlay();
                }
            });
            document.addEventListener('keydown', escHandler);

            container.appendChild(title);
            container.appendChild(video);
            container.appendChild(skipButton);
            overlay.appendChild(container);
            document.body.appendChild(overlay);

            // 動画の読み込みエラーを処理
            video.addEventListener('error', (e) => {
                console.error('動画の読み込みエラー:', e, '動画パス:', movie.path);
                // エラーメッセージを表示せずに、静かに閉じる
                closeOverlay();
            });
            
            // 動画の読み込みができない場合のタイムアウト処理
            const loadTimeout = setTimeout(() => {
                if (video.readyState === 0) {
                    console.error('動画の読み込みがタイムアウトしました:', movie.path);
                    closeOverlay();
                }
            }, 5000);
            
            video.addEventListener('loadeddata', () => {
                clearTimeout(loadTimeout);
            });
        }
        
        // 現在のキャラクターの紹介動画を選択・再生
        function playCurrentCharacterMovie() {
            if (!gameState.selectedCharacter) {
                showToast('キャラクターが選択されていません', 'error');
                return;
            }
            
            const movies = getCharacterMovies(gameState.selectedCharacter.id);
            if (!movies.length) {
                showToast('このキャラクターの動画はまだ解放されていません', 'info');
                return;
            }
            
            closeCharacterMovieSelector();

            const overlay = document.createElement('div');
            overlay.id = 'character-movie-selector';
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10001;
                padding: 20px;
                box-sizing: border-box;
            `;

            const panel = document.createElement('div');
            panel.style.cssText = `
                width: min(520px, 95vw);
                max-height: 80vh;
                background: #fff;
                border-radius: 22px;
                padding: 24px;
                display: flex;
                flex-direction: column;
                gap: 16px;
                box-shadow: 0 18px 45px rgba(0,0,0,0.35);
            `;

            const title = document.createElement('h2');
            title.textContent = `${gameState.selectedCharacter.name}の紹介動画`;
            title.style.cssText = 'margin: 0; font-size: 1.3rem; color: #3c2a4d; text-align: center;';

            const subText = document.createElement('p');
            subText.textContent = '再生する動画を選択してください';
            subText.style.cssText = 'margin: 0; color: #6c5d7c; text-align: center;';

            const list = document.createElement('div');
            list.style.cssText = `
                display: flex;
                flex-direction: column;
                gap: 12px;
                overflow-y: auto;
                padding-right: 4px;
            `;

            movies.forEach((movie, index) => {
                const label = movie.label || `動画${index + 1}`;
                const button = document.createElement('button');
                button.type = 'button';
                button.textContent = label;
                button.style.cssText = `
                    width: 100%;
                    padding: 12px 16px;
                    border-radius: 14px;
                    border: 1.5px solid rgba(255, 140, 180, 0.4);
                    background: linear-gradient(135deg, rgba(255,240,248,0.95), rgba(240,225,255,0.95));
                    color: #4b3d60;
                    font-weight: 600;
                    font-size: 1rem;
                    cursor: pointer;
                    transition: transform 0.15s ease, box-shadow 0.15s ease;
                `;
                button.onmouseenter = () => {
                    button.style.transform = 'translateY(-2px)';
                    button.style.boxShadow = '0 6px 14px rgba(0,0,0,0.15)';
                };
                button.onmouseleave = () => {
                    button.style.transform = 'translateY(0)';
                    button.style.boxShadow = 'none';
                };
                button.addEventListener('click', () => {
                    closeCharacterMovieSelector();
                    play3DMovie(movie.path, `${gameState.selectedCharacter.name} - ${label}`);
                });
                list.appendChild(button);
            });

            const closeButton = document.createElement('button');
            closeButton.type = 'button';
            closeButton.textContent = '閉じる';
            closeButton.style.cssText = `
                width: 100%;
                padding: 12px;
                border-radius: 12px;
                border: none;
                background: #f0f0f5;
                color: #555;
                font-weight: 600;
                cursor: pointer;
            `;
            closeButton.addEventListener('click', closeCharacterMovieSelector);

            panel.appendChild(title);
            panel.appendChild(subText);
            panel.appendChild(list);
            panel.appendChild(closeButton);

            overlay.appendChild(panel);

            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    closeCharacterMovieSelector();
                }
            };
            document.addEventListener('keydown', handleEsc);
            overlay._escHandler = handleEsc;

            document.body.appendChild(overlay);
        }

        function closeCharacterMovieSelector() {
            const popup = document.getElementById('character-movie-selector');
            if (popup) {
                if (popup._escHandler) {
                    document.removeEventListener('keydown', popup._escHandler);
                }
                popup.remove();
            }
        }
        
        // キャラクター交代画面を表示
        function showCharacterSwitch() {
            const ownedCharacters = gameState.ownedCharacters || [];
            if (ownedCharacters.length === 0) {
                showToast('保有しているキャラクターがいません', 'error');
                return;
            }
            
            // 既存のポップアップがあれば削除
            const existingPopup = document.getElementById('character-switch-popup');
            if (existingPopup) {
                existingPopup.remove();
            }
            
            // ポップアップを作成
            const popup = document.createElement('div');
            popup.id = 'character-switch-popup';
            popup.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 20px;
                box-sizing: border-box;
            `;
            
            popup.innerHTML = `
                <div style="width: 100%; max-width: 600px; background: white; border-radius: 20px; padding: 30px; max-height: 80vh; overflow-y: auto;">
                    <h2 style="text-align: center; margin-bottom: 20px; color: #333;">保有キャラクター一覧</h2>
                    <div id="owned-characters-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <!-- 保有キャラクターがここに表示されます -->
                    </div>
                    <button onclick="closeCharacterSwitch()" style="
                        width: 100%;
                        padding: 15px;
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        border: none;
                        border-radius: 10px;
                        font-size: 1rem;
                        font-weight: bold;
                        cursor: pointer;
                    ">閉じる</button>
                </div>
            `;
            
            document.body.appendChild(popup);
            
            // 保有キャラクターを表示
            const listContainer = document.getElementById('owned-characters-list');
            ownedCharacters.forEach(character => {
                const isCurrent = gameState.selectedCharacter && gameState.selectedCharacter.id === character.id;
                
                const card = document.createElement('div');
                card.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    padding: 15px;
                    background: ${isCurrent ? 'linear-gradient(135deg, #e3f2fd, #bbdefb)' : 'white'};
                    border: 2px solid ${isCurrent ? '#2196f3' : '#e0e0e0'};
                    border-radius: 15px;
                    cursor: pointer;
                    transition: all 0.3s;
                    position: relative;
                `;
                card.onmouseover = function() {
                    if (!isCurrent) {
                        this.style.transform = 'translateY(-5px)';
                        this.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                    }
                };
                card.onmouseout = function() {
                    if (!isCurrent) {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = 'none';
                    }
                };
                card.onclick = function() {
                    if (!isCurrent) {
                        switchCharacter(character);
                        closeCharacterSwitch();
                    }
                };
                
                const img = document.createElement('img');
                img.src = `10_社畜アイコン/${character.icon}`;
                img.alt = character.name;
                img.style.cssText = 'width: 80px; height: 80px; object-fit: contain; border-radius: 10px; margin-bottom: 10px;';
                img.onerror = function() {
                    const fallback = document.createElement('div');
                    fallback.style.cssText = 'width:80px;height:80px;display:flex;align-items:center;justify-content:center;font-size:24px;color:#666;border-radius:10px;background:#f0f0f0;';
                    fallback.textContent = character.name.charAt(0);
                    this.parentNode.replaceChild(fallback, this);
                };
                
                card.innerHTML = `
                    <div style="font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; text-align: center;">${character.name}</div>
                    ${isCurrent ? '<div style="position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; background: #2196f3; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 0.7rem;">✓</div>' : ''}
                `;
                card.insertBefore(img, card.firstChild);
                
                listContainer.appendChild(card);
            });
            
            // ESCキーで閉じる
            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    closeCharacterSwitch();
                }
            };
            document.addEventListener('keydown', handleEsc);
            popup._escHandler = handleEsc;
        }
        
        // キャラクター交代ポップアップを閉じる
        function closeCharacterSwitch() {
            const popup = document.getElementById('character-switch-popup');
            if (popup) {
                if (popup._escHandler) {
                    document.removeEventListener('keydown', popup._escHandler);
                }
                popup.remove();
            }
        }
        
        // キャラクターを切り替える
        async function switchCharacter(character) {
            if (!character) {
                return;
            }
            if (gameState.selectedCharacter && gameState.selectedCharacter.id === character.id) {
                return;
            }
            syncCurrentCharacterState();
            gameState.selectedCharacter = character;
            applyCharacterState(character);
            await updateMainScreen();
            // キャラクター変更時に昇格試験解放をチェック
            checkMainStoryUnlock();
            await autoSave();
            showToast(`${character.name}に切り替えました`, 'success');
        }
        
        // 設定画面に現在のキャラクターの特別動画を表示
        function renderCurrentCharacterMovie() {
            const container = document.getElementById('current-character-movie');
            if (!container) return;

            container.innerHTML = '';
            
            if (!gameState.selectedCharacter) {
                container.innerHTML = '<p style="color: #999;">キャラクターが選択されていません</p>';
                return;
            }
            
            // ホーム画面のMovieと同じ動画を取得
            const movies = getCharacterMovies(gameState.selectedCharacter.id);
            
            if (!movies.length) {
                container.innerHTML = `<p style="color: #999;">${gameState.selectedCharacter.name}の動画はありません</p>`;
                return;
            }
            
            const wrapper = document.createElement('div');
            wrapper.style.cssText = 'background: white; border-radius: 16px; padding: 20px; box-shadow: 0 6px 14px rgba(0,0,0,0.12); display: flex; flex-direction: column; gap: 12px;';

            const heading = document.createElement('h4');
            heading.textContent = `${gameState.selectedCharacter.name}の動画`;
            heading.style.cssText = 'font-size: 1.05rem; margin: 0; color: #333;';

            const list = document.createElement('div');
            list.style.cssText = 'display: flex; flex-wrap: wrap; gap: 10px;';

            movies.forEach((movie, index) => {
                const label = movie.label || `動画${index + 1}`;
                const button = document.createElement('button');
                button.type = 'button';
                button.textContent = label;
                button.style.cssText = `
                    flex: 1 1 140px;
                    padding: 10px 12px;
                    border-radius: 12px;
                    border: 1.5px solid rgba(255, 145, 190, 0.45);
                    background: rgba(255, 240, 248, 0.8);
                    color: #4b3d60;
                    font-weight: 600;
                    cursor: pointer;
                `;
                button.addEventListener('click', () => {
                    play3DMovie(movie.path, `${gameState.selectedCharacter.name} - ${label}`);
                });
                list.appendChild(button);
            });

            wrapper.appendChild(heading);
            wrapper.appendChild(list);
            container.appendChild(wrapper);
        }
        
        // バッチをデータベースに保存
        async function saveBadgeToDatabase(badge, currentValue) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                return;
            }
            
            try {
                const { error } = await supabase
                    .from('user_achievements')
                    .upsert({
                        user_id: currentUser.id,
                        achievement_id: badge.id,
                        achievement_name: badge.name,
                        achievement_description: badge.description,
                        achievement_type: badge.category,
                        target_value: badge.target,
                        current_value: currentValue,
                        is_completed: true,
                        completed_at: new Date().toISOString(),
                        reward: { shachi: badge.reward }
                    }, {
                        onConflict: 'user_id,achievement_id'
                    });
                
                if (error) {
                    console.error('バッチ保存エラー:', error);
                } else {
                    console.log('バッチ保存成功');
                }
            } catch (error) {
                console.error('バッチ保存エラー:', error);
            }
        }
        
        // レベルを計算（キャラ固有の初期ステータスとの差分で成長を算出）
        async function calculateLevel() {
            const stats = gameState.stats;
            const baseStats = gameState.selectedCharacter ? createInitialStats(gameState.selectedCharacter) : { stress: 0, knowledge: 0, physical: 0, communication: 0 };
            const progress = CHARACTER_STAT_KEYS.reduce((sum, key) => {
                const current = stats?.[key] || 0;
                const base = baseStats?.[key] || 0;
                return sum + Math.max(0, current - base);
            }, 0);
            const newLevel = Math.floor(progress / 40) + 1;
            
            // レベルアップ判定
            if (newLevel > gameState.level && gameState.level > 0) {
                const levelDiff = newLevel - gameState.level;
                const oldLevel = gameState.level;
                gameState.level = newLevel;
                
                // レベルアップ演出を表示
                showLevelUpAnimation(oldLevel, newLevel);
                
                // データベースにレベルアップを記録
                await recordLevelUp(oldLevel, newLevel);
                
                // バッチをチェック
                await checkBadges();
                
                // レベルアップ報酬を付与（レベル差 × 50シャチ）
                const levelUpReward = levelDiff * 50;
                adjustShachi(levelUpReward);
                gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + levelUpReward;
                
                // シャチ履歴を記録
                recordShachiHistory(levelUpReward, 'level_up', `レベルアップ: Lv${oldLevel} → Lv${newLevel}`);
                
                // UIを更新
                updateMainScreen();
                
                showToast(`レベルアップ！レベル${oldLevel}から${newLevel}になりました！${levelUpReward}シャチ獲得！`, 'success');
                console.log(`レベル${oldLevel}から${newLevel}にアップ！報酬: ${levelUpReward}シャチ`);
            } else {
                gameState.level = newLevel;
            }
            
            return newLevel;
        }
        
        // 役職を計算
        function calculateRank() {
            const statsEligibleRank = getStatsEligibleRank();
            const unlockedRank = getCurrentCharacterRankProgress();
            const actualRankValue = Math.min(statsEligibleRank, unlockedRank);
            return RANK_SYSTEM.find(rank => rank.rank === actualRankValue) || RANK_SYSTEM[0];
        }
        
        // レベルアップをデータベースに記録
        async function recordLevelUp(oldLevel, newLevel) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                return;
            }
            
            try {
                // user_game_statsテーブルのhighest_level_reachedを更新
                const { error } = await supabase
                    .from('user_game_stats')
                    .upsert({
                        user_id: currentUser.id,
                        highest_level_reached: newLevel,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id'
                    });
                
                if (error) {
                    console.error('レベルアップ記録エラー:', error);
                } else {
                    console.log('レベルアップ記録成功');
                }
            } catch (error) {
                console.error('レベルアップ記録エラー:', error);
            }
        }
        // レベルアップ演出を表示
        function showLevelUpAnimation(oldLevel, newLevel) {
            const dialog = document.createElement('div');
            dialog.className = 'level-up-dialog';
            dialog.innerHTML = `
                <div class="level-up-content">
                    <div class="level-up-icon">🎉</div>
                    <h2>レベルアップ！</h2>
                    <div class="level-up-animation">
                        <span class="old-level">Level ${oldLevel}</span>
                        <span class="arrow">→</span>
                        <span class="new-level">Level ${newLevel}</span>
                    </div>
                    <p class="level-up-message">おめでとうございます！</p>
                    <button class="btn-primary" onclick="this.parentElement.parentElement.remove();">閉じる</button>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
        }
        
        // ステータス表示更新
        async function updateStatsDisplay() {
            console.log('ステータス表示更新開始');
            
            // レベルを計算
            await calculateLevel();
            
            const stats = gameState.stats;
            const statNames = ['stress', 'knowledge', 'physical', 'communication'];
            
            statNames.forEach((stat, index) => {
                const value = Math.max(0, stats[stat] || 0); // 負の値を0に制限
                
                const statBar = document.getElementById(`${stat}-bar`);
                const statValue = document.getElementById(`${stat}-value`);
                
                if (statBar) {
                    let percentage, tierClass;
                    
                    // 100刻みでクラス分け
                    if (value > 300) {
                        percentage = Math.min(100, ((value - 300) / 100) * 100);
                        tierClass = 'ultra-tier';
                    } else if (value > 200) {
                        percentage = Math.min(100, ((value - 200) / 100) * 100);
                        tierClass = 'high-tier';
                    } else if (value > 100) {
                        percentage = Math.min(100, ((value - 100) / 100) * 100);
                        tierClass = 'mid-tier';
                    } else {
                        percentage = (value / 100) * 100;
                        tierClass = 'low-tier';
                    }
                    
                    // 既存のクラスを削除して新しいクラスを追加
                    statBar.classList.remove('low-tier', 'mid-tier', 'high-tier', 'ultra-tier');
                    statBar.classList.add(tierClass);
                    
                    // アニメーション付きで更新
                    statBar.style.transition = 'width 1s ease-out';
                    statBar.style.width = `${percentage}%`;
                    console.log(`${stat}バー更新:`, percentage + '%', 'tier:', tierClass);
                }
                if (statValue) {
                    statValue.textContent = value; // 実際の値を表示
                }
            });
            
            // レベル表示を更新
            const levelElement = document.getElementById('character-level');
            if (levelElement) {
                levelElement.textContent = gameState.level;
            }
            
            // メインストーリー解放チェック
            checkMainStoryUnlock();
        }
        
        // メインストーリー解放チェック（ボスイベント解放チェックを統合）
        function checkMainStoryUnlock() {
            const currentRank = calculateRank();
            console.log('checkMainStoryUnlock: 現在の役職', currentRank.name, 'rank:', currentRank.rank);
            
            // 現在のキャラクターIDを取得
            const currentCharacterId = gameState?.selectedCharacter?.id || selectedCharacterId;
            if (!currentCharacterId) {
                console.log('キャラクターIDが取得できません');
                return;
            }
            
            // キャラクター状態を取得
            const characterState = gameState?.characterStates?.[currentCharacterId];
            if (!characterState) {
                console.log('キャラクター状態が見つかりません:', currentCharacterId);
                return;
            }
            
            // 解放済みボスイベントのリストを初期化
            if (!characterState.unlockedBossEvents) {
                characterState.unlockedBossEvents = [];
            }
            
            // ボスイベントの解放チェック
            const nextBossEvent = BOSS_EVENTS.find(boss => boss.requiredRank > currentRank.rank);
            
            if (nextBossEvent) {
                console.log('次のボスイベント:', nextBossEvent.title, 'requiredRank:', nextBossEvent.requiredRank);
                // 必要なステータスをチェック
                const nextRank = RANK_SYSTEM.find(r => r.rank === nextBossEvent.requiredRank);
                if (nextRank) {
                    const meetsRequirements = 
                        gameState.stats.stress >= nextRank.requiredStats.stress &&
                        gameState.stats.knowledge >= nextRank.requiredStats.knowledge &&
                        gameState.stats.physical >= nextRank.requiredStats.physical &&
                        gameState.stats.communication >= nextRank.requiredStats.communication;
                    
                    console.log('ステータス要件:', nextRank.requiredStats);
                    console.log('現在のステータス:', gameState.stats);
                    console.log('要件を満たしているか:', meetsRequirements);
                    
                    // キャラクターごとに解放済みかチェック
                    const alreadyUnlocked = characterState.unlockedBossEvents.includes(nextBossEvent.id);
                    console.log('キャラクターID:', currentCharacterId, 'ボスイベントID:', nextBossEvent.id, '既に解放済み:', alreadyUnlocked);
                    
                    if (meetsRequirements && !alreadyUnlocked) {
                        console.log('ポップアップを表示します！');
                        // キャラクター状態に追加
                        characterState.unlockedBossEvents.push(nextBossEvent.id);
                        // 即座に保存
                        autoSave();
                        showBossEventUnlockPopup(nextBossEvent);
                    }
                }
            } else {
                console.log('次のボスイベントが見つかりません');
            }
        }
        
        // ボスイベント解放ポップアップ
        function showBossEventUnlockPopup(bossEvent) {
            const dialog = document.createElement('div');
            dialog.className = 'achievement-notification';
            dialog.innerHTML = `
                <div class="achievement-content" style="background: linear-gradient(135deg, #FF6B6B, #FFE66D); border: 3px solid #FF6B00;">
                    <div class="achievement-icon" style="font-size: 4rem;">🎯</div>
                    <h2 style="color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">ボスイベントが解放された！</h2>
                    <p style="color: #fff; font-weight: bold; font-size: 1.2rem; margin: 20px 0;">${bossEvent.title}</p>
                    <p style="color: #fff; margin: 10px 0;">昇格試験が解放されました！</p>
                    <p style="color: #fff; font-size: 0.9rem; margin: 10px 0;">イベント画面上部で挑戦できます</p>
                    <button class="btn-primary" onclick="this.closest('.achievement-notification').remove();" style="margin-top: 20px;">了解</button>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
            
            // 5秒後に自動削除
            setTimeout(() => {
                if (dialog.parentElement) {
                    dialog.remove();
                }
            }, 5000);
        }
        
        // メインストーリー解放ポップアップ（廃止予定だが互換性のため残す）
        function showMainStoryUnlockPopup(mainStoryEvent) {
            showBossEventUnlockPopup(mainStoryEvent);
        }
        
        // 数値のカウントアップアニメーション
        function animateNumber(element, targetValue, duration) {
            const startValue = parseInt(element.textContent) || 0;
            const increment = targetValue > startValue ? 1 : -1;
            const steps = Math.abs(targetValue - startValue);
            const stepTime = duration / steps;
            
            let currentValue = startValue;
            const interval = setInterval(() => {
                currentValue += increment;
                element.textContent = currentValue;
                
                if (currentValue === targetValue) {
                    clearInterval(interval);
                }
            }, stepTime);
        }
        // キャラクターグリッド作成
        function createCharacterGrid() {
            console.log('キャラクターグリッド作成開始');
            const grid = document.getElementById('character-grid');
            if (!grid) {
                console.error('character-grid要素が見つかりません');
                return;
            }
            
            grid.innerHTML = '';
            
            CHARACTERS.forEach(character => {
                console.log('キャラクターカード作成:', character.name);
                const card = document.createElement('div');
                card.className = 'character-card';
                card.dataset.characterId = character.id;
                card.innerHTML = `
                    <div class="character-icon">
                        <img src="10_社畜アイコン/${character.icon}" alt="${character.name}" loading="lazy" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <div style="width: 100%; height: 100%; background: #ddd; border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 24px; color: #666;">
                            ${character.name.charAt(0)}
                        </div>
                    </div>
                    <div class="character-name">${character.name}</div>
                    <div class="character-level">Lv.1</div>
                `;
                
                card.addEventListener('click', () => {
                    console.log('キャラクターカードクリック:', character.id);
                    selectCharacter(character.id);
                });
                grid.appendChild(card);
            });
            
            console.log('キャラクターグリッド作成完了');
        }

        // トースト表示
        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ゲームデータのロード
        async function loadGameData() {
            // 認証済みの場合のみSupabaseから読み込み
            if (isAuthenticated && supabase) {
                const supabaseData = await loadGameDataFromSupabase();
                if (supabaseData) {
                    // Supabaseのデータを使用
                    gameState = {
                        selectedCharacter: supabaseData.selectedCharacter || null,
                        shachi: supabaseData.shachi || GAME_CONFIG.INITIAL_SHACHI,
                        level: supabaseData.level || 1,
                        experience: supabaseData.experience || 0,
                        stats: supabaseData.stats || { stress: 0, knowledge: 0, physical: 0, communication: 0 },
                        characterStates: supabaseData.characterStates || {},
                        ownedCharacters: supabaseData.ownedCharacters || [],
                        party: supabaseData.party || [],
                        dailyEventsCompleted: supabaseData.dailyEventsCompleted || 0,
                        completedEventTypes: supabaseData.completedEventTypes || [],
                        completedSeriesKeys: supabaseData.completedSeriesKeys || [],
                        lastPlayDate: supabaseData.lastPlayDate || null,
                        purchasedItems: supabaseData.purchasedItems || [],
                        totalDaysPlayed: supabaseData.totalDaysPlayed || 0,
                        totalShachiEarned: supabaseData.totalShachiEarned || 0,
                        totalEventsCompleted: supabaseData.totalEventsCompleted || 0,
                        totalItemsPurchased: supabaseData.totalItemsPurchased || 0,
                        totalShachiSpent: supabaseData.totalShachiSpent || 0,
                        completedBadges: supabaseData.completedBadges || supabaseData.completedAchievements || [],
                        lastGachaDate: supabaseData.lastGachaDate || null,
                        todayGachaCount: supabaseData.todayGachaCount || 0,
                        lastHabitRewardDate: supabaseData.lastHabitRewardDate || null,
                        shachiHistory: supabaseData.shachiHistory || [],
                        rareItems: Array.isArray(supabaseData.rareItems) ? supabaseData.rareItems : [],
                        rareItemsInventory: Array.isArray(supabaseData.rareItemsInventory) ? supabaseData.rareItemsInventory : []
                    };
                    console.log('Supabaseからゲームデータを読み込みました:', gameState);
                    console.log('読み込んだレアカード:', gameState.rareItems, '件数:', gameState.rareItems.length);
                    normalizeGameState();
                    console.log('normalize後のレアカード:', gameState.rareItems, '件数:', gameState.rareItems.length);
                    return;
                } else {
                    // Supabaseにデータがない場合、ローカルデータを移行
                    console.log('Supabaseにデータがありません。ローカルデータを移行します。');
                    await migrateLocalDataToSupabase();
                }
            }
            
            // ローカルストレージから読み込み（ユーザーごとのキー）
            const { data: savedData } = readLocalSaveData();
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    gameState = {
                        selectedCharacter: parsedData.selectedCharacter || null,
                        shachi: parsedData.shachi || GAME_CONFIG.INITIAL_SHACHI,
                        level: parsedData.level || 1,
                        experience: parsedData.experience || 0,
                        stats: parsedData.stats || { stress: 0, knowledge: 0, physical: 0, communication: 0 },
                        characterStates: parsedData.characterStates || {},
                        ownedCharacters: parsedData.ownedCharacters || [],
                        party: parsedData.party || [],
                        dailyEventsCompleted: parsedData.dailyEventsCompleted || 0,
                        completedEventTypes: parsedData.completedEventTypes || [],
                        completedSeriesKeys: parsedData.completedSeriesKeys || [],
                        lastPlayDate: parsedData.lastPlayDate || null,
                        purchasedItems: parsedData.purchasedItems || [],
                        totalDaysPlayed: parsedData.totalDaysPlayed || 0,
                        totalShachiEarned: parsedData.totalShachiEarned || 0,
                        totalEventsCompleted: parsedData.totalEventsCompleted || 0,
                        totalItemsPurchased: parsedData.totalItemsPurchased || 0,
                        totalShachiSpent: parsedData.totalShachiSpent || 0,
                        completedBadges: parsedData.completedBadges || parsedData.completedAchievements || [],
                        lastGachaDate: parsedData.lastGachaDate || null,
                        todayGachaCount: parsedData.todayGachaCount || 0,
                        lastHabitRewardDate: parsedData.lastHabitRewardDate || null,
                        shachiHistory: parsedData.shachiHistory || [],
                        rareItems: Array.isArray(parsedData.rareItems) ? parsedData.rareItems : [],
                        rareItemsInventory: Array.isArray(parsedData.rareItemsInventory) ? parsedData.rareItemsInventory : []
                    };
                    console.log('ローカルストレージからゲームデータを読み込みました:', gameState);
                    console.log('読み込んだレアカード:', gameState.rareItems, '件数:', gameState.rareItems.length);
                    normalizeGameState();
                    console.log('normalize後のレアカード:', gameState.rareItems, '件数:', gameState.rareItems.length);
                } catch (error) {
                    console.error('ゲームデータのロードに失敗しました:', error);
                    resetGameState();
                }
            } else {
                console.log('セーブデータが見つかりません - 新規ゲーム開始');
                resetGameState();
            }
        }
        
        // ゲーム状態をリセット
        function resetGameState() {
            gameState = {
                selectedCharacter: null,
                shachi: GAME_CONFIG.INITIAL_SHACHI,
                level: 1,
                experience: 0,
                stats: { stress: 0, knowledge: 0, physical: 0, communication: 0 },
                 characterStates: {},
                ownedCharacters: [],
                party: [],
                dailyEventsCompleted: 0,
                completedEventTypes: [], // 完了したイベントタイプ
                completedSeriesKeys: [], // 完了したシリーズキー
                lastPlayDate: null,
                purchasedItems: [],
                totalDaysPlayed: 0,
                totalShachiEarned: 0,
                totalEventsCompleted: 0,
                totalItemsPurchased: 0,
                totalShachiSpent: 0,
                completedBadges: [],
                lastGachaDate: null,
                todayGachaCount: 0,
                lastHabitRewardDate: null,
                shachiHistory: [],
                rareItems: [],
                rareItemsInventory: []
            };
            normalizeGameState();
        }
        
        // ゲームデータのセーブ
        async function saveGameData() {
            try {
                syncCurrentCharacterState();
                // rareItemsが確実に含まれているか確認
                if (!Array.isArray(gameState.rareItems)) {
                    console.warn('rareItemsが配列ではありません。初期化します。', gameState.rareItems);
                    gameState.rareItems = [];
                }
                if (!Array.isArray(gameState.rareItemsInventory)) {
                    console.warn('rareItemsInventoryが配列ではありません。初期化します。', gameState.rareItemsInventory);
                    gameState.rareItemsInventory = [];
                }
                console.log('保存前のレアカード:', gameState.rareItems, '件数:', gameState.rareItems.length);
                console.log('保存前のレアアイテム:', gameState.rareItemsInventory, '件数:', gameState.rareItemsInventory.length);
                // ローカルストレージに保存
                writeLocalSaveData(gameState);
                console.log('ローカルストレージに保存しました。レアカード:', gameState.rareItems.length, '件');
                
                // Supabaseにも保存（認証済みの場合）
                if (isAuthenticated) {
                    await saveGameDataToSupabase();
                }
                
                return true;
            } catch (error) {
                console.error('ゲームデータのセーブに失敗しました:', error);
                alert('ゲームデータの保存に失敗しました。ブラウザのストレージ容量を確認してください。');
                return false;
            }
        }
        
        // 自動セーブ機能
        async function autoSave() {
            if (gameState.selectedCharacter) {
                syncCurrentCharacterState();
                await saveGameData();
            }
        }
        
        // 自動バックアップ機能（5分ごと）
        let lastBackupTime = 0;
        const BACKUP_INTERVAL = 5 * 60 * 1000; // 5分
        
        function checkAutoBackup() {
            const now = Date.now();
            if (now - lastBackupTime >= BACKUP_INTERVAL && gameState.selectedCharacter) {
                console.log('自動バックアップを実行します');
                saveGameData();
                lastBackupTime = now;
            }
        }
        
        // 5分ごとに自動バックアップをチェック
        setInterval(checkAutoBackup, 60000); // 1分ごとにチェック
        
        // 日替わりリセットチェック
        function checkDailyReset() {
            // 認証前/未選択時はボーナス計算を行わない（ログイン前のデータ引き継ぎ防止）
            if (!gameState || !gameState.selectedCharacter) {
                return;
            }
            const today = getJSTDateString(); // 日本時間で今日の日付を取得
            if (gameState.lastPlayDate !== today) {
                // 昨日の習慣チェックに応じたボーナスを付与（初回ログイン時）
                try {
                    const yesterday = getJSTDate();
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yStr = formatDate(yesterday);
                    const dayData = habitTrackerData[yStr] || {};
                    const checks = Object.values(dayData).filter(Boolean).length;
                    if (checks > 0 && gameState.lastHabitRewardDate !== today) {
                        const rewardPerCheck = 20; // 1チェックあたりの報酬（シャチ）
                        const rewardAmount = checks * rewardPerCheck;
                        adjustShachi(rewardAmount);
                        gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + rewardAmount;
                        gameState.lastHabitRewardDate = today;
                        showHabitRewardModal(rewardAmount, checks);
                    }
                } catch (e) { console.warn('習慣リワード計算中の例外', e); }

                gameState.dailyEventsCompleted = 0;
                gameState.completedEventTypes = []; // 互換: イベントIDリセット
                gameState.completedSeriesKeys = []; // 仕様: シリーズキーをリセット
                gameState.lastPlayDate = today;
                gameState.totalDaysPlayed++;
                saveGameData();
                console.log('日替わりリセット完了');
            }
        }
        // テスト用：習慣トラッカーの報酬を手動でテストする関数
        function testHabitReward() {
            console.log('習慣トラッカー報酬のテストを開始します...');
            
            // 昨日の日付を取得（日本時間）
            const yesterday = getJSTDate();
            yesterday.setDate(yesterday.getDate() - 1);
            const yStr = formatDate(yesterday);
            
            // 習慣トラッカーデータに昨日のチェックを設定（テスト用）
            if (!habitTrackerData[yStr]) {
                habitTrackerData[yStr] = {};
            }
            // テスト用に3つの習慣にチェックを入れる
            habitTrackerData[yStr]['early_bed'] = true;
            habitTrackerData[yStr]['exercise'] = true;
            habitTrackerData[yStr]['journal'] = true;
            localStorage.setItem('shachipoke2_habits', JSON.stringify(habitTrackerData));
            console.log('テスト用の習慣データを設定しました:', yStr, habitTrackerData[yStr]);
            
            // lastPlayDateを昨日に設定（日付が変わったと判定されるように）
            const today = getJSTDateString(); // 日本時間で今日の日付を取得
            const yesterdayDateString = yesterday.toDateString();
            gameState.lastPlayDate = yesterdayDateString;
            gameState.lastHabitRewardDate = null; // 報酬を受け取っていない状態にする
            
            console.log('ゲーム状態をリセットしました。checkDailyReset()を実行します...');
            
            // checkDailyResetを実行
            checkDailyReset();
        }
        
        // 習慣リワードのモーダル表示
        function showHabitRewardModal(rewardAmount, checks) {
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.5)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '9999';

            const modal = document.createElement('div');
            modal.style.background = '#fff';
            modal.style.borderRadius = '16px';
            modal.style.padding = '20px';
            modal.style.width = '90%';
            modal.style.maxWidth = '360px';
            modal.style.textAlign = 'center';
            modal.style.boxShadow = '0 10px 24px rgba(0,0,0,0.2)';

            modal.innerHTML = `
                <h3 style="margin:0 0 10px;">昨日の習慣ボーナス</h3>
                <p style="margin:0 0 10px;">チェック数: <strong>${checks}</strong> 件</p>
                <div style="font-size:1.2rem; font-weight:700; color:#d32f2f; margin-bottom: 15px;">💰 シャチ +${rewardAmount}</div>
                <button id="habit-reward-ok" class="btn-primary" style="padding:10px 16px; border:none; border-radius:8px;">OK</button>
            `;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            const okBtn = modal.querySelector('#habit-reward-ok');
            okBtn.addEventListener('click', () => {
                overlay.remove();
                updateMainScreen();
                autoSave();
            });
        }
        
        // イベントシステム
        function startEvent() {
            // 要望により「本日のイベント終了」画面は表示しない
            // 常にイベント選択画面を表示し、完了済みはグレーアウトで全て出す
            document.getElementById('event-selection').style.display = 'block';
            document.getElementById('current-event').style.display = 'none';
            document.getElementById('event-complete').style.display = 'none';
            document.getElementById('no-events').style.display = 'none';
            
            // イベントカードを動的に生成
            renderEventCards();
        }
        
        // イベントカードを描画
        function renderEventCards() {
            console.log('renderEventCards() called');
            const mainStoryContainer = document.getElementById('main-story-container');
            const eventTypesContainer = document.getElementById('event-types');
            if (!mainStoryContainer || !eventTypesContainer) {
                console.error('Container not found');
                return;
            }
            
            console.log('Clearing containers');
            mainStoryContainer.innerHTML = '';
            eventTypesContainer.innerHTML = '';
            
            // イベントをランダムに表示
            // 6シリーズ固定で表示（各シリーズ1日1回）
            const seriesDefs = [
                { key: 'boss', label: 'イライラ上司', icon: '30_差し込み画像/02_Event/irairajoshi01.png' },
                { key: 'ojou', label: 'お局様の小言', icon: '30_差し込み画像/02_Event/otsubonesamanokogoto01.png' },
                { key: 'customer', label: '理不尽お客', icon: '30_差し込み画像/02_Event/rifujinokyaku01.png' },
                { key: 'system', label: 'システム障害', icon: '30_差し込み画像/02_Event/systemsyogai01.png' },
                { key: 'event', label: '社内イベント', icon: '30_差し込み画像/02_Event/syanaievent01.png' },
                { key: 'skill', label: '謎のセミナー', icon: '30_差し込み画像/02_Event/nazonoseminer01.png' },
            ];


            // 既に完了済みシリーズ（event idベースで保持しているため、シリーズ判定用にタイトル照合）
            const eventTypes = seriesDefs.map(series => {
                // 同シリーズの候補を抽出し、ランダムに1件サンプル（説明用）
                const candidates = DAILY_EVENTS.filter(e => e.series === series.key);
                const sample = candidates[Math.floor(Math.random()*candidates.length)];
                // サブタイトル部分のみ抽出（「上司シリーズ①：夜中23時の依頼」→「夜中23時の依頼」）
                let subtitle = '本日の案件';
                if (sample) {
                    const colonIndex = sample.title.indexOf('：');
                    if (colonIndex !== -1) {
                        subtitle = sample.title.substring(colonIndex + 1);
                    } else {
                        // コロンがない場合は、シリーズ名＋数字を除去
                        const regex = /^[^シリーズ]+シリーズ[①②③④⑤⑥⑦⑧⑨⑩]*：?(.*)/;
                        const match = sample.title.match(regex);
                        subtitle = match ? match[1] : sample.title;
                    }
                }
                
                // 特定のシリーズの詳細を7文字以下で固定
                if (series.key === 'boss') {
                    subtitle = '理不尽指示';
                } else if (series.key === 'ojou') {
                    subtitle = '小言攻撃';
                } else if (series.key === 'customer') {
                    subtitle = 'クレーム対応';
                } else if (series.key === 'system') {
                    subtitle = 'バグの嵐';
                } else if (series.key === 'event') {
                    subtitle = '飲み会、運動会';
                } else if (series.key === 'skill') {
                    subtitle = '誰も得しない会';
                }
                return {
                    id: sample ? sample.id : series.key,
                    seriesKey: series.key,
                    icon: series.icon,
                    title: series.label,
                    description: subtitle
                };
            });
            
            console.log('Generated eventTypes:', eventTypes);
            
            // 完了管理の初期化
            if (!gameState.completedEventTypes) gameState.completedEventTypes = []; // 旧: イベントID単位
            if (!gameState.completedSeriesKeys) gameState.completedSeriesKeys = []; // 新: シリーズ単位
            
            console.log('completedEventTypes:', gameState.completedEventTypes);
            
            // ボスイベントを上部に豪勢に表示
            const currentRank = calculateRank();
            console.log('現在の役職:', currentRank.name, 'rank:', currentRank.rank);
            console.log('現在のステータス:', gameState.stats);
            const rankProgress = getCurrentCharacterRankProgress();
            const nextRankTarget = rankProgress + 1;
            console.log('解放済み役職ランク:', rankProgress);
            const nextRankDefinition = RANK_SYSTEM.find(r => r.rank === nextRankTarget);
            let availableBossEvents = [];
            if (nextRankDefinition) {
                const bossEventForNextRank = BOSS_EVENTS.find(bossEvent => bossEvent.requiredRank === nextRankDefinition.rank);
                if (bossEventForNextRank) {
                    const statsCheck =
                        gameState.stats.stress >= nextRankDefinition.requiredStats.stress &&
                        gameState.stats.knowledge >= nextRankDefinition.requiredStats.knowledge &&
                        gameState.stats.physical >= nextRankDefinition.requiredStats.physical &&
                        gameState.stats.communication >= nextRankDefinition.requiredStats.communication;
                    const notCompleted = !hasCurrentCharacterCompletedBossEvent(bossEventForNextRank.id);
                    console.log(`次のボスイベント ${bossEventForNextRank.title}: notCompleted=${notCompleted}, statsCheck=${statsCheck}`);
                    if (notCompleted && statsCheck) {
                        availableBossEvents = [bossEventForNextRank];
                    }
                }
            }
            
            console.log('表示されるボスイベント数:', availableBossEvents.length);
            if (availableBossEvents.length > 0) {
                availableBossEvents.forEach(bossEvent => {
                    const isCompleted = hasCurrentCharacterCompletedBossEvent(bossEvent.id);
                    
                    const card = document.createElement('div');
                    card.className = `event-type-card main-story-type boss-event ${isCompleted ? 'completed' : ''}`;
                    card.onclick = isCompleted ? null : () => selectBossEvent(bossEvent.id);
                    card.innerHTML = `
                        <div class="event-series" style="font-weight: 900; font-size: 1.3rem;">${bossEvent.title}</div>
                        <div class="event-icon" style="font-size: 4rem;">${bossEvent.icon}</div>
                        <p style="font-weight: bold; margin: 15px 0;">${bossEvent.description}</p>
                        <div style="color: #FF6B00; font-weight: bold; margin-top: 10px; font-size: 1.1rem; padding: 10px; background: rgba(255, 107, 0, 0.1); border-radius: 8px;">参加費: ${bossEvent.participationCost}シャチ</div>
                        ${isCompleted ? '<div class="completed-badge">完了済み</div>' : ''}
                    `;
                    mainStoryContainer.appendChild(card);
                });
            }
            
            eventTypes.forEach(eventType => {
                // シリーズ完了判定：同シリーズのいずれかIDがcompletedに含まれるか
                // 正しいマッチングロジックを使用
                // シリーズ単位の完了判定を使用
                const seriesCompleted = (gameState.completedSeriesKeys||[]).includes(eventType.seriesKey);
                
                const effectiveCompleted = TEST_MODE ? false : seriesCompleted;
                console.log(`Series ${eventType.title} (${eventType.seriesKey}) completed:`, seriesCompleted, 'effective:', effectiveCompleted);
                const card = document.createElement('div');
                
                // タイプ別クラスを追加
                let typeClass = '';
                if (eventType.title.includes('イライラ上司')) {
                    typeClass = 'boss-type';
                } else if (eventType.title.includes('理不尽お客')) {
                    typeClass = 'customer-type';
                } else if (eventType.title.includes('お局様の小言')) {
                    typeClass = 'ojou-type';
                } else if (eventType.title.includes('システム障害')) {
                    typeClass = 'system-type';
                } else if (eventType.title.includes('社内イベント')) {
                    typeClass = 'event-type';
                } else if (eventType.title.includes('謎のセミナー')) {
                    typeClass = 'skill-type';
                }
                
                card.className = `event-type-card ${typeClass} ${effectiveCompleted ? 'completed' : ''}`;
                card.onclick = effectiveCompleted ? null : () => selectEventSeries(eventType.title);
                card.innerHTML = `
                    <div class="event-series">${eventType.title}</div>
                    <div class="event-icon">
                        ${eventType.icon.endsWith('.png') ? 
                            `<img src="${eventType.icon}" alt="${eventType.title}" style="width: 90px; height: 90px; object-fit: contain;">` : 
                            eventType.icon
                        }
                    </div>
                    <p>${eventType.description}</p>
                    ${effectiveCompleted ? '<div class="completed-badge">完了済み</div>' : ''}
                `;
                eventTypesContainer.appendChild(card);
            });
            
            console.log('renderEventCards() completed, cards added:', eventTypesContainer.children.length);
        }
        // メインストーリーイベント選択
        function selectMainStoryEvent(eventId) {
            console.log('メインストーリーイベント選択:', eventId);
            
            const mainStoryEvent = MAIN_STORY_EVENTS.find(e => e.id === eventId);
            if (!mainStoryEvent) {
                console.error('メインストーリーイベントが見つかりません:', eventId);
                return;
            }
            
            // シャチが足りるかチェック
            if (gameState.shachi < mainStoryEvent.participationCost) {
                showToast(`シャチが不足しています。${mainStoryEvent.participationCost}シャチ必要です。`, 'error');
                return;
            }
            
            // 既に完了済みかチェック
            const eventCompleted = (gameState.completedSeriesKeys||[]).includes(eventId);
            if (eventCompleted && !TEST_MODE) {
                showToast('このメインストーリーは既に完了しています', 'warning');
                return;
            }
            
            // 参加費を支払う（0以下にならないよう保護）
            adjustShachi(-mainStoryEvent.participationCost);
            gameState.totalShachiSpent = (gameState.totalShachiSpent || 0) + mainStoryEvent.participationCost;
            
            // イベント選択画面を非表示
            document.getElementById('event-selection').style.display = 'none';
            
            // 選択情報を保存
            selectedEventType = eventId;
            selectedSeriesKey = null; // メインストーリーはシリーズキーなし
            currentSelectedEventId = eventId;
            
            // 4択画面を表示
            showMainStoryChoices(mainStoryEvent);
        }
        
        // メインストーリーの選択肢を表示
        function showMainStoryChoices(mainStoryEvent) {
            const eventTitleEl = document.getElementById('event-title');
            const eventDescriptionEl = document.getElementById('event-description');
            const eventChoicesEl = document.getElementById('event-choices');
            
            if (eventTitleEl) eventTitleEl.textContent = mainStoryEvent.title;
            if (eventDescriptionEl) eventDescriptionEl.textContent = mainStoryEvent.description;
            
            if (eventChoicesEl) {
                eventChoicesEl.innerHTML = '';
                mainStoryEvent.choices.forEach((choice, index) => {
                    const choiceBtn = document.createElement('button');
                    choiceBtn.className = 'choice-btn';
                    choiceBtn.textContent = choice.text;
                    choiceBtn.onclick = () => handleMainStoryChoice(mainStoryEvent, index);
                    eventChoicesEl.appendChild(choiceBtn);
                });
            }
            
            document.getElementById('current-event').style.display = 'block';
        }
        
        // メインストーリーの選択を処理
        async function handleMainStoryChoice(mainStoryEvent, choiceIndex) {
            const choice = mainStoryEvent.choices[choiceIndex];
            
            // 効果を適用
            const statChanges = {};
            let shachiChange = 0;
            
            if (choice.effect) {
                Object.keys(choice.effect).forEach(key => {
                    if (key === 'shachi') {
                        shachiChange += choice.effect[key];
                    } else if (gameState.stats[key] !== undefined) {
                        statChanges[key] = (statChanges[key] || 0) + choice.effect[key];
                        gameState.stats[key] = Math.max(0, Math.min(999, gameState.stats[key] + choice.effect[key]));
                    }
                });
            }
            
            adjustShachi(shachiChange);
            
            // 獲得したシャチのみを記録（負の値は消費なので記録しない）
            if (shachiChange > 0) {
                gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + shachiChange;
            }
            
            // レベルを再計算
            await calculateLevel();
            
            // メインストーリーイベントを完了として記録
            if (!gameState.completedSeriesKeys) gameState.completedSeriesKeys = [];
            if (!gameState.completedSeriesKeys.includes(mainStoryEvent.id)) {
                gameState.completedSeriesKeys.push(mainStoryEvent.id);
            }
            
            // 完了画面を表示
            showMainStoryComplete(mainStoryEvent, choice, statChanges, shachiChange);
        }
        
        // メインストーリー完了画面を表示
        function showMainStoryComplete(mainStoryEvent, choice, statChanges, shachiChange) {
            document.getElementById('current-event').style.display = 'none';
            const completeEl = document.getElementById('event-complete');
            const feedbackEl = document.getElementById('event-feedback');
            const rewardsEl = document.getElementById('event-rewards');
            
            if (feedbackEl) feedbackEl.textContent = choice.feedback;
            
            if (rewardsEl) {
                let rewardsHtml = '';
                if (Object.keys(statChanges).length > 0) {
                    rewardsHtml += '<div class="stat-rewards">ステータス変化:<br>';
                    Object.entries(statChanges).forEach(([stat, value]) => {
                        const statNames = {
                            stress: 'ストレス耐性',
                            knowledge: '知識',
                            physical: '体力',
                            communication: 'コミュ力'
                        };
                        rewardsHtml += `  ${statNames[stat] || stat}: ${value > 0 ? '+' : ''}${value}<br>`;
                    });
                    rewardsHtml += '</div>';
                }
                if (shachiChange !== 0) {
                    rewardsHtml += `<div class="shachi-reward">シャチ: ${shachiChange > 0 ? '+' : ''}${shachiChange}</div>`;
                }
                rewardsEl.innerHTML = rewardsHtml || '報酬なし';
            }
            
            completeEl.style.display = 'block';
            
            // ステータス変更により役職が変わる可能性があるため、キャッシュをクリア
            lastRenderedState.rank = null;
            
            // メイン画面を更新
            updateMainScreen();
            autoSave();
            
            console.log('メインストーリーイベント完了');
        }
        
        // ボスイベント選択
        function selectBossEvent(eventId) {
            console.log('ボスイベント選択:', eventId);
            
            const bossEvent = BOSS_EVENTS.find(e => e.id === eventId);
            if (!bossEvent) {
                console.error('ボスイベントが見つかりません:', eventId);
                return;
            }
            
            // シャチが足りるかチェック
            if (gameState.shachi < bossEvent.participationCost) {
                showToast(`シャチが不足しています。${bossEvent.participationCost}シャチ必要です。`, 'error');
                return;
            }
            
            // 既に完了済みかチェック
            const eventCompleted = hasCurrentCharacterCompletedBossEvent(eventId);
            if (eventCompleted && !TEST_MODE) {
                showToast('このボスイベントは既に完了しています', 'warning');
                return;
            }
            
            // 参加費を支払う（0以下にならないよう保護）
            adjustShachi(-bossEvent.participationCost);
            gameState.totalShachiSpent = (gameState.totalShachiSpent || 0) + bossEvent.participationCost;
            
            // シャチ履歴を記録
            recordShachiHistory(-bossEvent.participationCost, 'boss_event_cost', `ボスイベント参加費: ${bossEvent.title}`);
            
            // イベント選択画面を非表示
            document.getElementById('event-selection').style.display = 'none';
            
            // 選択情報を保存
            selectedEventType = eventId;
            selectedSeriesKey = null;
            currentSelectedEventId = eventId;
            
            // 4択画面を表示（選択肢をランダムに並び替え）
            showBossEventChoices(bossEvent);
        }
        
        // ボスイベントの選択肢を表示（選択肢をランダムに並び替え）
        function showBossEventChoices(bossEvent) {
            const eventTitleEl = document.getElementById('event-title');
            const eventDescriptionEl = document.getElementById('event-description');
            const eventChoicesEl = document.getElementById('event-choices');
            
            if (eventTitleEl) eventTitleEl.textContent = bossEvent.title;
            if (eventDescriptionEl) eventDescriptionEl.textContent = bossEvent.description;
            
            if (eventChoicesEl) {
                eventChoicesEl.innerHTML = '';
                
                // 選択肢と正解インデックスを一緒にシャッフル
                const choicesWithIndices = bossEvent.choices.map((choice, index) => ({ choice, originalIndex: index }));
                
                // Fisher-Yates shuffle
                for (let i = choicesWithIndices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [choicesWithIndices[i], choicesWithIndices[j]] = [choicesWithIndices[j], choicesWithIndices[i]];
                }
                
                // シャッフル後の正解インデックスを保存
                const shuffledCorrectIndex = choicesWithIndices.findIndex(item => item.originalIndex === bossEvent.correctAnswerIndex);
                
                choicesWithIndices.forEach((item, displayIndex) => {
                    const choiceBtn = document.createElement('button');
                    choiceBtn.className = 'choice-btn';
                    choiceBtn.textContent = item.choice.text;
                    choiceBtn.onclick = () => handleBossEventChoice(bossEvent, item.choice, item.originalIndex, displayIndex === shuffledCorrectIndex);
                    eventChoicesEl.appendChild(choiceBtn);
                });
            }
            
            document.getElementById('current-event').style.display = 'block';
        }
        
        // ボスイベントの選択を処理
        async function handleBossEventChoice(bossEvent, choice, originalIndex, isCorrect) {
            // 効果を適用
            const statChanges = {};
            let shachiChange = 0;
            const isBossEventChoice = true;
            
            if (choice.effect) {
                Object.keys(choice.effect).forEach(key => {
                    if (key === 'shachi') {
                        shachiChange += choice.effect[key];
                    } else if (gameState.stats[key] !== undefined) {
                        let delta = choice.effect[key];
                        if (isBossEventChoice) {
                            let scaled = Math.round(delta * BOSS_EVENT_STAT_GAIN_SCALE);
                            if (scaled === 0 && delta !== 0) {
                                scaled = delta > 0 ? 1 : -1;
                            }
                            delta = scaled;
                        }
                        statChanges[key] = (statChanges[key] || 0) + delta;
                        gameState.stats[key] = Math.max(0, Math.min(999, gameState.stats[key] + delta));
                    }
                });
            }
            
            adjustShachi(shachiChange);
            
            // 獲得したシャチのみを記録（負の値は消費なので記録しない）
            if (shachiChange > 0) {
                gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + shachiChange;
            }
            
            // シャチ履歴を記録（ボスイベントの報酬）
            if (shachiChange !== 0) {
                recordShachiHistory(shachiChange, 'boss_event_reward', `ボスイベント: ${bossEvent.title} - ${choice.feedback || '完了'}`);
            }
            
            // レベルを再計算
            await calculateLevel();
            
            // 正解の場合のみボスイベントを完了として記録し、役職昇格
            if (isCorrect) {
                // 現在の役職を保存
                const oldRank = calculateRank();
                
                // ボスイベントを完了として記録
                markCurrentCharacterBossEventCompleted(bossEvent.id);
                
                // レベルを再計算（ステータス更新含む）
                await calculateLevel();
                
                // 役職を再計算
                const newRank = calculateRank();
                
                ensure3DIconUnlockForCurrentCharacter(newRank);
                
                if (newRank.rank > oldRank.rank) {
                    const characterId = gameState.selectedCharacter?.id;
                    if (characterId) {
                        // 係長（rank: 1）になったタイミングで31_キャラ特別01の動画を解放
                        if (newRank.rank === 1) {
                            unlockCharacterSpecial01Movie(characterId);
                            playCharacterIntroOnPromotion();
                        }
                        // 主任（rank: 2）になったタイミングで32_キャラ特別02の動画を解放
                        if (newRank.rank === 2) {
                            unlockCharacterSpecial02Movie(characterId);
                            playCharacterSpecial02OnPromotion();
                        }
                        // 課長代理（rank: 3）になったタイミングで33_キャラ特別03の動画を解放
                        if (newRank.rank === 3) {
                            unlockCharacterSpecial03Movie(characterId);
                            playCharacterSpecial03OnPromotion();
                        }
                        // 部長（rank: 6）になったタイミングで32_3Dの動画1を解放
                        if (newRank.rank === 6) {
                            unlockCharacter3DMovie(characterId);
                            playCharacter3DMovieOnPromotion();
                        }
                        // 事業部長（rank: 8）になったタイミングで34_3D_02の動画を解放
                        if (newRank.rank === 8) {
                            unlockCharacter3DMovie02(characterId);
                            playCharacter3DMovie02OnPromotion();
                        }
                    }
                    showRankUpPopup(oldRank, newRank);
                }
            }
            
            // 完了画面を表示（正解かどうかを表示）
            showBossEventComplete(bossEvent, choice, statChanges, shachiChange, isCorrect);
        }
        
        // ボスイベント完了画面を表示
        function showBossEventComplete(bossEvent, choice, statChanges, shachiChange, isCorrect) {
            document.getElementById('current-event').style.display = 'none';
            const completeEl = document.getElementById('event-complete');
            const feedbackEl = document.getElementById('event-feedback');
            const rewardsEl = document.getElementById('event-rewards');
            
            if (feedbackEl) {
                const resultText = isCorrect ? 
                    '<div style="color: #4CAF50; font-weight: bold; font-size: 1.2rem; margin-bottom: 10px;">🎉 正解！昇格試験突破！</div>' :
                    '<div style="color: #f44336; font-weight: bold; font-size: 1.2rem; margin-bottom: 10px;">❌ 失敗！昇格試験不合格</div>';
                feedbackEl.innerHTML = resultText + choice.feedback;
            }
            
            if (rewardsEl) {
                let rewardsHtml = '';
                if (Object.keys(statChanges).length > 0) {
                    rewardsHtml += '<div class="stat-rewards">ステータス変化:<br>';
                    Object.entries(statChanges).forEach(([stat, value]) => {
                        const statNames = {
                            stress: 'ストレス耐性',
                            knowledge: '知識',
                            physical: '体力',
                            communication: 'コミュ力'
                        };
                        rewardsHtml += `  ${statNames[stat] || stat}: ${value > 0 ? '+' : ''}${value}<br>`;
                    });
                    rewardsHtml += '</div>';
                }
                if (shachiChange !== 0) {
                    rewardsHtml += `<div class="shachi-reward">シャチ: ${shachiChange > 0 ? '+' : ''}${shachiChange}</div>`;
                }
                rewardsEl.innerHTML = rewardsHtml || '報酬なし';
            }
            
            completeEl.style.display = 'block';
            
            // 役職変更の可能性があるため、キャッシュをクリアして強制更新
            lastRenderedState.rank = null;
            
            // メイン画面を更新
            updateMainScreen();
            autoSave();
            
            console.log('ボスイベント完了:', isCorrect ? '正解' : '失敗');
        }
        
        // 役職昇格ポップアップ
        function showRankUpPopup(oldRank, newRank) {
            console.log('showRankUpPopup呼び出し:', oldRank, newRank);
            
            // ランク報酬を取得
            const reward = RANK_REWARDS[newRank.rank];
            console.log('ランク報酬:', reward, 'ランク:', newRank.rank);
            
            if (!reward) {
                console.log('ランク報酬が定義されていません');
                showRankUpDialog(oldRank, newRank);
                return;
            }
            
            // 動画を解放・Movieに格納
            if (reward && reward.type === 'video' && reward.unlock) {
                const currentCharacterId = gameState?.selectedCharacter?.id;
                console.log('現在のキャラクターID:', currentCharacterId);
                
                if (currentCharacterId && reward.videoPath) {
                    // unlockCharacterMovie関数を使用して正しい形式で保存
                    unlockCharacterMovie(currentCharacterId, reward.videoPath, reward.title);
                        console.log('動画を解放:', reward.title, reward.videoPath);
                        autoSave(); // 即座に保存
                    } else {
                    console.warn('キャラクター状態が見つかりません、または動画パスが無効です:', currentCharacterId, reward.videoPath);
                }
            }
            
            // 3Dアイコンの解放（課長の場合）
            if (reward && reward.type === '3d_icon' && reward.unlock) {
                const currentCharacterId = selectedCharacterId || gameState?.selectedCharacterId || gameState?.selectedCharacter?.id;
                if (currentCharacterId && gameState?.characterStates?.[currentCharacterId]) {
                    const characterState = gameState.characterStates[currentCharacterId];
                    characterState.unlocked3DIcon = true;
                    console.log('3Dアイコンを解放');
                    autoSave(); // 即座に保存
                }
            }
            
            // 動画がある場合は再生
            // 係長（rank: 1）、主任（rank: 2）、課長代理（rank: 3）、部長（rank: 6）、事業部長（rank: 8）の場合は
            // キャラクター専用動画が再生されるため、RANK_REWARDSの動画はスキップ
            // RANK_REWARDSの動画は存在しないファイルを参照している可能性があるため、基本的にスキップ
            const hasCharacterSpecificMovie = newRank.rank === 1 || newRank.rank === 2 || newRank.rank === 3 || newRank.rank === 6 || newRank.rank === 8;
            
            if (hasCharacterSpecificMovie) {
                console.log('キャラクター専用動画が再生されるため、RANK_REWARDSの動画はスキップ');
            } else {
                console.log('RANK_REWARDSの動画はスキップ（存在しないファイルの可能性があるため）');
            }
                // 動画がない場合は通常の昇格ポップアップを表示
                showRankUpDialog(oldRank, newRank);
        }
        
        // 昇格時の動画再生
        function playRankUpVideo(videoPath, title, onComplete) {
            console.log('動画再生開始:', videoPath, title);
            
            // videoPathがundefinedまたは空の場合はエラー
            if (!videoPath || videoPath === 'undefined' || videoPath.trim() === '') {
                console.error('動画パスが無効です:', videoPath);
                if (onComplete) onComplete();
                return;
            }
            
            let timeoutId = null;
            let isVideoLoaded = false;
            let isVideoError = false;
            
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.95);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10007;
            `;
            
            const container = document.createElement('div');
            container.style.cssText = `
                position: relative;
                width: 90%;
                max-width: 800px;
                background: #000;
                border-radius: 20px;
                overflow: hidden;
            `;
            
            const video = document.createElement('video');
            video.src = videoPath;
            video.controls = true;
            video.playsInline = true;
            video.style.cssText = `
                width: 100%;
                height: auto;
                display: block;
            `;
            
            const titleDiv = document.createElement('div');
            titleDiv.textContent = title;
            titleDiv.style.cssText = `
                color: white;
                font-size: 1.5rem;
                font-weight: bold;
                padding: 20px;
                text-align: center;
                background: rgba(0, 0, 0, 0.8);
            `;
            
            const errorMsg = document.createElement('div');
            errorMsg.style.cssText = `
                color: #ff6b6b;
                font-size: 1rem;
                padding: 20px;
                text-align: center;
                display: none;
            `;
            
            const closeBtn = document.createElement('button');
            closeBtn.textContent = '閉じる';
            closeBtn.className = 'btn-primary';
            closeBtn.style.cssText = `
                margin: 20px auto;
                display: block;
                padding: 12px 30px;
            `;
            
            const handleClose = () => {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                video.pause();
                video.src = '';
                overlay.remove();
                if (onComplete) onComplete();
            };
            
            closeBtn.onclick = handleClose;
            
            // 動画のエラーハンドリング
            video.addEventListener('error', (e) => {
                console.error('動画読み込みエラー:', e, videoPath);
                isVideoError = true;
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                // 動画が存在しない場合は、動画を表示せずに直接閉じる
                overlay.remove();
                if (onComplete) onComplete();
            });
            
            // 動画の読み込み完了を待つ
            const handleLoadedData = () => {
                console.log('動画読み込み完了:', videoPath);
                isVideoLoaded = true;
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                video.play().catch(err => {
                    console.error('動画再生エラー:', err);
                    // 再生エラーでも動画は存在するので、エラーメッセージを表示
                    errorMsg.textContent = '動画の自動再生に失敗しました。手動で再生してください。';
                    errorMsg.style.display = 'block';
                });
            };
            
            video.addEventListener('loadeddata', handleLoadedData);
            video.addEventListener('canplay', handleLoadedData);
            
            video.addEventListener('ended', () => {
                console.log('動画再生終了');
                handleClose();
            });
            
            // 動画が読み込めない場合のタイムアウト処理（読み込み開始前のみ）
            timeoutId = setTimeout(() => {
                if (!isVideoLoaded && !isVideoError && video.readyState === 0) {
                    console.warn('動画読み込みタイムアウト:', videoPath);
                    // タイムアウト時も動画が存在しない可能性が高いので、動画を表示せずに閉じる
                    overlay.remove();
                    if (onComplete) onComplete();
                }
            }, 3000);
            
            container.appendChild(titleDiv);
            container.appendChild(video);
            container.appendChild(errorMsg);
            container.appendChild(closeBtn);
            overlay.appendChild(container);
            document.body.appendChild(overlay);
            
            // 動画の読み込みを開始
            video.load();
        }
        
        // 昇格ポップアップ表示
        function showRankUpDialog(oldRank, newRank) {
            const reward = RANK_REWARDS[newRank.rank];
            let rewardText = '';
            
            if (reward && reward.type === 'video') {
                rewardText = `<p style="color: #fff; font-size: 0.9rem; margin-top: 10px;">🎬 ${reward.title}が解放されました！Movie画面でいつでも視聴できます。</p>`;
            } else if (reward && reward.type === '3d_icon') {
                rewardText = `<p style="color: #fff; font-size: 0.9rem; margin-top: 10px;">🎨 3Dアイコンが解放されました！ホーム画面で変更可能です。</p>`;
            }
            
            const dialog = document.createElement('div');
            dialog.className = 'achievement-notification';
            dialog.innerHTML = `
                <div class="achievement-content" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: 3px solid #764ba2;">
                    <div class="achievement-icon" style="font-size: 4rem;">🎉</div>
                    <h2 style="color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">役職昇格！</h2>
                    <p style="color: #fff; font-weight: bold; font-size: 1.5rem; margin: 20px 0;">${oldRank.name} → ${newRank.name}</p>
                    <p style="color: #fff; font-size: 1rem; margin: 10px 0;">おめでとうございます！昇格試験に合格し、役職が上がりました！</p>
                    ${rewardText}
                    <button class="btn-primary" onclick="this.closest('.achievement-notification').remove(); updateMainScreen();" style="margin-top: 20px;">了解</button>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
            
            // ゲーム状態を保存
            autoSave();
        }
        
        // シリーズ選択時：同シリーズからランダムで1イベントを実施
        function selectEventSeries(seriesLabel) {
            console.log('シリーズ選択:', seriesLabel);
            
            // シリーズ名からキーを取得
            const seriesKeyMap = {
                'イライラ上司': 'boss',
                'お局様の小言': 'ojou', 
                '理不尽お客': 'customer',
                'システム障害': 'system',
                '社内イベント': 'event',
                '謎のセミナー': 'skill'
            };
            
            const seriesKey = seriesKeyMap[seriesLabel];
            console.log('シリーズキー:', seriesKey);
            
            if (!seriesKey) {
                console.error('シリーズキーが見つかりません:', seriesLabel);
                return;
            }
            
            // シリーズキーに基づいてイベントを検索
            const candidates = DAILY_EVENTS.filter(e => e.series === seriesKey);
            
            console.log('候補イベント数:', candidates.length);
            
            if (!candidates.length) {
                console.error('イベント候補が見つかりません');
                return;
            }
            
            const event = candidates[Math.floor(Math.random()*candidates.length)];
            console.log('選択されたイベント:', event.id);
            selectEventType(event.id);
        }
        
        function selectEventType(eventType) {
            console.log('イベントタイプ選択:', eventType);
            
            // completedEventTypesが未初期化の場合、初期化
            if (!gameState.completedEventTypes) {
                gameState.completedEventTypes = [];
            }
            
            // シリーズ完了済みかをチェック（通常モードのみ）
            const event = DAILY_EVENTS.find(e => e.id === eventType);
            if (!TEST_MODE) {
                if (!gameState.completedSeriesKeys) gameState.completedSeriesKeys = [];
                const sKey = event ? event.series : null;
                if (sKey && gameState.completedSeriesKeys.includes(sKey)) {
                    showToast('このシリーズは今日は既に完了しています', 'warning');
                    return;
                }
            }
            if (!event) {
                console.error('イベントが見つかりません:', eventType);
                return;
            }
            
            // 選択中のイベント情報を保存
            selectedEventType = eventType;
            // 現在のシリーズキーを保存
            selectedSeriesKey = event.series || null;
            currentSelectedEventId = event.id;
            
            // イベント選択画面を非表示
            document.getElementById('event-selection').style.display = 'none';
            
            // シリーズに応じた動画を再生してから4択画面を表示
            const videoSeries = ['boss', 'ojou', 'customer', 'system', 'event', 'skill'];
            if (videoSeries.includes(event.series)) {
                // 動画を再生
                playEventVideo(event);
            } else {
                // 動画がないシリーズは直接4択画面を表示
                showEventChoices(event);
            }
        }
        
        // イベントの動画を再生
        function playEventVideo(event) {
            // シリーズに応じた動画ファイルのリスト
            const videoFileMap = {
                'boss': [
                    '20_movie/20_イベント_上司/joushi01.mp4',
                    '20_movie/20_イベント_上司/joushi02.mp4',
                    '20_movie/20_イベント_上司/joushi03.mp4'
                ],
                'ojou': [
                    '20_movie/21_イベント_お局/otsubone01.mp4',
                    '20_movie/21_イベント_お局/otsubone02.mp4'
                ],
                'customer': [
                    '20_movie/22_イベント_お客/Okyaku01.mp4',
                    '20_movie/22_イベント_お客/Okyaku02.mp4'
                ],
                'system': [
                    '20_movie/23_イベント_システム障害/system01.mp4'
                ],
                'event': [
                    '20_movie/24_イベント_社内イベント/syanaievent01.mp4',
                    '20_movie/24_イベント_社内イベント/syanaievent02.mp4'
                ],
                'skill': [
                    '20_movie/25_イベント_謎のセミナー/nazonoseminer01.mp4',
                    '20_movie/25_イベント_謎のセミナー/nazonoseminer02.mp4'
                ]
            };
            
            const videoFiles = videoFileMap[event.series];
            if (!videoFiles || videoFiles.length === 0) {
                console.error('動画ファイルが見つかりません:', event.series);
                showEventChoices(event);
                return;
            }
            
            // ランダムに動画を選択
            const randomVideo = videoFiles[Math.floor(Math.random() * videoFiles.length)];
            
            // 動画再生用のオーバーレイとビデオ要素を作成
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.9)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10001';
            
            const container = document.createElement('div');
            container.style.position = 'relative';
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.alignItems = 'center';
            
            const video = document.createElement('video');
            video.src = randomVideo;
            video.style.width = '90vw';
            video.style.maxWidth = '800px';
            video.style.height = 'auto';
            video.style.borderRadius = '10px';
            video.controls = false;
            video.autoplay = true;
            video.muted = false;
            video.playsInline = true;
            
            const skipButton = document.createElement('button');
            skipButton.textContent = 'スキップ';
            skipButton.style.cssText = `
                margin-top: 16px;
                padding: 10px 20px;
                border-radius: 999px;
                border: none;
                background: rgba(255,255,255,0.9);
                color: #333;
                font-weight: 600;
                cursor: pointer;
            `;

            const closeOverlay = () => {
                video.pause();
                overlay.remove();
            };

            const cleanup = () => {
                document.removeEventListener('keydown', escHandler);
            };

            const finishVideo = () => {
                cleanup();
                closeOverlay();
                showEventChoices(event);
            };
            
            // 動画終了時に4択画面を表示
            video.addEventListener('ended', finishVideo);
            
            // エラー処理
            video.addEventListener('error', () => {
                console.error('動画の読み込みエラー');
                finishVideo();
                // 動画が再生できない場合は直接4択画面を表示
            });

            skipButton.addEventListener('click', finishVideo);
            
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    finishVideo();
                }
            };
            document.addEventListener('keydown', escHandler);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    finishVideo();
                }
            });

            container.appendChild(video);
            container.appendChild(skipButton);
            overlay.appendChild(container);
            document.body.appendChild(overlay);
            
            // 動画を再生
            video.play().catch(error => {
                console.error('動画の再生エラー:', error);
                overlay.remove();
                // 再生できない場合は直接4択画面を表示
                showEventChoices(event);
            });
        }
        
        // イベントの4択選択画面を表示
        function showEventChoices(event) {
            // イベント詳細画面を表示
            document.getElementById('event-title').textContent = event.title;
            document.getElementById('event-description').textContent = event.description;
            
            const choicesContainer = document.getElementById('event-choices');
            choicesContainer.innerHTML = '';
            
            event.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'event-choice-btn';
                button.textContent = choice.text;
                button.onclick = () => selectEventChoice(choice, index);
                choicesContainer.appendChild(button);
            });
            
            document.getElementById('current-event').style.display = 'block';
        }
        
        async function selectEventChoice(choice, choiceIndex) {
            console.log('イベント選択処理開始:', choice, 'index:', choiceIndex);
            
            // 現在選択中のイベント情報を取得
            const currentEventType = selectedEventType || 'unknown';
            const currentEventId = currentSelectedEventId || currentEventType;
            
            // 効果を適用
            const statChanges = {};
            let shachiChange = 0;
            if (choice.effect.shachi) {
                shachiChange = choice.effect.shachi;
                adjustShachi(shachiChange);
                gameState.totalShachiEarned += Math.max(0, shachiChange);
                
                // シャチ履歴を記録
                const event = DAILY_EVENTS.find(e => e.id === currentEventId);
                const eventTitle = event ? event.title : 'イベント';
                recordShachiHistory(shachiChange, 'event', `イベント: ${eventTitle} - ${choice.feedback || '完了'}`);
            }
            
            Object.keys(choice.effect).forEach(stat => {
                if (stat !== 'shachi' && gameState.stats[stat] !== undefined) {
                    const oldValue = gameState.stats[stat];
                    gameState.stats[stat] = Math.max(0, Math.min(GAME_CONFIG.STAT_CAP, 
                        gameState.stats[stat] + choice.effect[stat]));
                    statChanges[stat] = gameState.stats[stat] - oldValue;
                }
            });
            
            // フィードバック表示
            document.getElementById('event-feedback').textContent = choice.feedback;
            
            // 報酬表示
            const rewardsContainer = document.getElementById('event-rewards');
            rewardsContainer.innerHTML = '';
            
            if (choice.effect.shachi) {
                const reward = document.createElement('div');
                reward.textContent = `シャチ: ${choice.effect.shachi > 0 ? '+' : ''}${choice.effect.shachi}`;
                reward.className = choice.effect.shachi > 0 ? 'reward-positive' : 'reward-negative';
                rewardsContainer.appendChild(reward);
            }
            
            Object.keys(choice.effect).forEach(stat => {
                if (stat !== 'shachi' && choice.effect[stat] !== 0) {
                    const reward = document.createElement('div');
                    const statNames = { stress: 'ストレス耐性', knowledge: '知識', physical: '体力', communication: 'コミュ力' };
                    reward.textContent = `${statNames[stat]}: ${choice.effect[stat] > 0 ? '+' : ''}${choice.effect[stat]}`;
                    reward.className = choice.effect[stat] > 0 ? 'reward-positive' : 'reward-negative';
                    rewardsContainer.appendChild(reward);
                }
            });
            
            gameState.dailyEventsCompleted++;
            gameState.totalEventsCompleted++;
            
            // 完了したイベントID（互換のため）
            if (!gameState.completedEventTypes) gameState.completedEventTypes = [];
            if (!gameState.completedEventTypes.includes(currentEventType)) {
                gameState.completedEventTypes.push(currentEventType);
            }
            // シリーズ単位でも記録（本仕様）
            if (!gameState.completedSeriesKeys) gameState.completedSeriesKeys = [];
            if (selectedSeriesKey && !gameState.completedSeriesKeys.includes(selectedSeriesKey)) {
                gameState.completedSeriesKeys.push(selectedSeriesKey);
            }
            
            // データベースにイベント履歴を保存（テストモードではスキップ）
            if (!TEST_MODE) {
                await saveEventToDatabase(currentEventId, currentEventType, choiceIndex,
                    choice.effect, statChanges, choice.feedback);
            } else {
                console.log('[TEST_MODE] saveEventToDatabase skipped');
            }
            
            // 統計情報を更新（テストモードではスキップ）
            if (!TEST_MODE) {
                await updateGameStatsInDatabase();
            } else {
                console.log('[TEST_MODE] updateGameStatsInDatabase skipped');
            }
            
            // アチーブメントをチェック
            await checkBadges();
            
            document.getElementById('current-event').style.display = 'none';
            // 結果画面を最前面に表示し、選択リストは隠す
            const selectionEl = document.getElementById('event-selection');
            if (selectionEl) selectionEl.style.display = 'none';
            document.getElementById('event-complete').style.display = 'block';
            const remainingElAfterChoice = document.getElementById('events-remaining');
            if (remainingElAfterChoice) {
                remainingElAfterChoice.textContent = GAME_CONFIG.MAX_DAILY_EVENTS - gameState.dailyEventsCompleted;
            }
            
            // イベントカードを再描画（グレーアウト反映のため）
            renderEventCards();
            
            // ステータス変更により役職が変わる可能性があるため、キャッシュをクリア
            lastRenderedState.rank = null;
            
            updateMainScreen();
            autoSave();
            
            console.log('イベント選択処理完了');
        }
        
        function nextEvent() {
            console.log('nextEvent() called');
            console.log('dailyEventsCompleted:', gameState.dailyEventsCompleted);
            console.log('MAX_DAILY_EVENTS:', GAME_CONFIG.MAX_DAILY_EVENTS);
            
            // カウンターは既に増えているので、ここでは増やさない
            const remainingEl = document.getElementById('events-remaining');
            if (remainingEl) {
                remainingEl.textContent = GAME_CONFIG.MAX_DAILY_EVENTS - gameState.dailyEventsCompleted;
            }
            
            // 要望により、上限到達後も選択画面を表示
            console.log('Returning to event selection screen (always show)');
            document.getElementById('event-selection').style.display = 'block';
            document.getElementById('current-event').style.display = 'none';
            document.getElementById('event-complete').style.display = 'none';
            document.getElementById('no-events').style.display = 'none';
            console.log('Calling renderEventCards()');
            renderEventCards();
            console.log('renderEventCards() completed');
        }
        
        // ショップシステム（差分更新対応）
        let lastShopState = {
            shachi: null,
            purchasedItems: null
        };
        
        function renderShop() {
            const container = document.getElementById('shop-items');
            
            // 変更がない場合は再描画をスキップ
            const hasChanges = 
                lastShopState.shachi !== gameState.shachi ||
                JSON.stringify(lastShopState.purchasedItems) !== JSON.stringify(gameState.purchasedItems);
            
            if (!hasChanges && lastShopState.shachi !== null) {
                return;
            }
            
            container.innerHTML = '';
            
            // ガチャステータスを更新
            updateGachaStatus();
            
            // 現在の役職を取得
            const currentRank = calculateRank();
            
            SHOP_ITEMS.forEach(item => {
                // 役職連動アイテムのフィルタリング
                if (item.requiredRank !== null && currentRank.rank < item.requiredRank) {
                    return; // このアイテムをスキップ
                }
                
                const itemCard = document.createElement('div');
                let className = 'shop-item-card';
                
                // 役職連動アイテムにランククラスを追加
                if (item.requiredRank !== null) {
                    className += ` rank-${item.requiredRank}`;
                }
                
                itemCard.className = className;
                itemCard.innerHTML = `
                    <div class="item-icon">${item.icon}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-description">${item.description}</div>
                    <div class="item-cost">${item.cost}シャチ</div>
                    <button class="btn-primary" onclick="purchaseItem('${item.id}')" 
                            ${gameState.shachi < item.cost ? 'disabled' : ''}>
                        ${gameState.shachi < item.cost ? 'シャチ不足' : '購入'}
                    </button>
                `;
                container.appendChild(itemCard);
            });
            
            // 状態を記録
            lastShopState = {
                shachi: gameState.shachi,
                purchasedItems: [...gameState.purchasedItems]
            };
            
            // 社畜を解放するセクションを描画
            renderLiberationCharacters();
        }

        // ガチャステータス更新
        function updateGachaStatus() {
            const today = getJSTDateString(); // 日本時間で今日の日付を取得
            const btnEl = document.getElementById('gacha-button');
            const btnTextEl = document.getElementById('gacha-btn-text');
            
            if (!gameState.lastGachaDate) {
                gameState.lastGachaDate = null;
                gameState.todayGachaCount = 0;
            }
            
            // 日付が変わったらリセット
            if (gameState.lastGachaDate !== today) {
                gameState.todayGachaCount = 0;
                gameState.lastGachaDate = today;
            }
            
            const costTextEl = document.getElementById('gacha-cost-text');
            if (costTextEl) {
                if (gameState.todayGachaCount === 0) {
                    costTextEl.textContent = '(無料)';
                } else {
                    costTextEl.textContent = '(30シャチ)';
                }
            }
            
            if (btnEl && gameState.todayGachaCount > 0 && gameState.shachi < 30) {
                btnEl.disabled = true;
            } else if (btnEl) {
                btnEl.disabled = false;
            }
        }

        // ガチャを引く
        function drawGacha() {
            const today = getJSTDateString(); // 日本時間で今日の日付を取得
            
            // 日付が変わったらリセット
            if (gameState.lastGachaDate !== today) {
                gameState.todayGachaCount = 0;
                gameState.lastGachaDate = today;
            }
            
            // コスト判定
            let cost = 0;
            if (gameState.todayGachaCount === 0) {
                cost = 0; // 無料
            } else {
                cost = 30; // 2回目以降
                if (gameState.shachi < cost) {
                    showToast('シャチが足りません！', 'warning');
                    return;
                }
            }
            
            // シャチを消費（0以下にならないよう保護）
            if (cost > 0) {
                adjustShachi(-cost);
                // シャチ履歴を記録（ガチャ費用）
                recordShachiHistory(-cost, 'gacha_cost', `ガチャ: ${cost === 0 ? '無料' : cost + 'シャチ'}`);
            }
            gameState.todayGachaCount++;
            
            // ガチャ報酬を決定（レア度に基づいてランダム選択）
            const gachaReward = selectRandomGachaReward();
            
            // 報酬を適用（0以下にならないよう保護）
            if (gachaReward.type === 'シャチ') {
                adjustShachi(gachaReward.amount);
                gameState.totalShachiEarned = (gameState.totalShachiEarned || 0) + Math.max(0, gachaReward.amount);
                // シャチ履歴を記録（ガチャ報酬）
                recordShachiHistory(gachaReward.amount, 'gacha_reward', `ガチャ報酬: ${gachaReward.name}`);
            } else if (gachaReward.type === 'カード') {
                addRareCard(gachaReward.cardId);
            } else if (gachaReward.type === 'レアアイテム') {
                console.log('Gacha reward is rare item:', gachaReward);
                console.log('About to call addRareItem with itemId:', gachaReward.itemId);
                console.log('gameState before addRareItem:', gameState);
                addRareItem(gachaReward.itemId);
                console.log('gameState after addRareItem:', gameState);
            } else {
                // タイプ名をstatsキーに変換
                const statKeyMap = {
                    'ストレス耐性': 'stress',
                    '知識': 'knowledge',
                    '体力': 'physical',
                    'コミュ力': 'communication'
                };
                const statKey = statKeyMap[gachaReward.type];
                if (statKey && gameState.stats[statKey] !== undefined) {
                    gameState.stats[statKey] = Math.min(
                        GAME_CONFIG.STAT_CAP,
                        gameState.stats[statKey] + gachaReward.amount
                    );
                }
            }
            

        // レアアイテムを追加
        function addRareItem(itemId) {
            console.log('addRareItem called with itemId:', itemId);
            console.log('gameState at addRareItem:', gameState);
            
            // gameStateが存在することを確認
            if (!gameState) {
                console.error('gameState is not defined in addRareItem');
                return;
            }
            
            if (!gameState.rareItemsInventory) {
                console.log('Initializing rareItemsInventory array');
                gameState.rareItemsInventory = [];
            }
            
            const existingItem = gameState.rareItemsInventory.find(item => item.id === itemId);
            if (existingItem) {
                existingItem.count = (existingItem.count || 1) + 1;
                console.log('Increased count for existing item:', existingItem);
            } else {
                const newItem = { id: itemId, count: 1, obtainedAt: new Date().toISOString() };
                gameState.rareItemsInventory.push(newItem);
                console.log('Added new rare item:', newItem);
            }
            console.log('Current rareItemsInventory after addition:', gameState.rareItemsInventory);
            
            // 保存を強制実行
            console.log('Forcing save after rare item addition');
            autoSave();
        }

        // レアアイテム獲得アニメーション
        function showRareItemGetAnimation(item) {
            const dialog = document.createElement('div');
            dialog.className = 'rare-item-get-animation';
            dialog.innerHTML = `
                <div class="rare-item-content">
                    <div class="rare-item-glow"></div>
                    <div class="rare-item-icon">
                        <img src="${item.icon}" alt="${item.name}" style="width: 120px; height: 120px; object-fit: contain;">
                    </div>
                    <h2 style="color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);">レアアイテム獲得！</h2>
                    <p style="color: #fff; font-weight: bold; font-size: 1.2rem;">${item.name}</p>
                    <button class="btn-primary" onclick="this.closest('.rare-item-get-animation').remove(); updateMainScreen();">確認</button>
                </div>
            `;
            
            // スタイルを追加
            if (!document.getElementById('rare-item-styles')) {
                const style = document.createElement('style');
                style.id = 'rare-item-styles';
                style.textContent = `
                    .rare-item-get-animation {
                        position: fixed;
                        top: 0;
                        left: 0;
                        width: 100%;
                        height: 100%;
                        background: rgba(0, 0, 0, 0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                        animation: fadeIn 0.5s ease;
                    }
                    .rare-item-content {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        box-shadow: 0 20px 40px rgba(0,0,0,0.3);
                        position: relative;
                        overflow: hidden;
                    }
                    .rare-item-glow {
                        position: absolute;
                        top: -50%;
                        left: -50%;
                        width: 200%;
                        height: 200%;
                        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
                        animation: pulse 2s infinite;
                    }
                    .rare-item-icon {
                        position: relative;
                        z-index: 1;
                        margin: 20px 0;
                        animation: bounce 1s infinite;
                    }
                    @keyframes pulse {
                        0%, 100% { transform: scale(1); opacity: 0.5; }
                        50% { transform: scale(1.1); opacity: 0.8; }
                    }
                    @keyframes bounce {
                        0%, 100% { transform: translateY(0); }
                        50% { transform: translateY(-10px); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(dialog);
            
            // サウンド効果（あれば）
            showToast(`${item.name}を獲得しました！`, 'success');
        }


            // 動画をランダムに再生してから報酬を表示
            playRandomGachaVideo(gachaReward);
            
            // ステータス更新
            updateGachaStatus();
            renderShop();
            updateMainScreen();
            autoSave();
        }

        // ガチャ報酬リスト（社畜グッズ）
        const GACHA_REWARDS = [
            // レア度1（★☆☆☆☆）
            { rarity: 1, name: '会社のコピー用紙', type: 'シャチ', amount: 30, icon: '💰', effect: 'シャチ +30' },
            { rarity: 1, name: '使い古しのマウスパッド', type: 'ストレス耐性', amount: 12, icon: '😤', effect: 'ストレス耐性 +12' },
            { rarity: 1, name: '古い参考書', type: '知識', amount: 10, icon: '🧠', effect: '知識 +10' },
            { rarity: 1, name: '卓上カレンダー', type: '知識', amount: 11, icon: '📅', effect: '知識 +11' },
            { rarity: 1, name: 'アロマキャンドル', type: 'ストレス耐性', amount: 14, icon: '🕯️', effect: 'ストレス耐性 +14' },
            { rarity: 1, name: 'ストレッチマット', type: '体力', amount: 15, icon: '🧘‍♀️', effect: '体力 +15' },
            { rarity: 1, name: 'コミュニケーションカード', type: 'コミュ力', amount: 12, icon: '💌', effect: 'コミュ力 +12' },
            // レア度2（★★☆☆☆）
            { rarity: 2, name: '残業用カップ麺', type: '体力', amount: 20, icon: '💪', effect: '体力 +20' },
            { rarity: 2, name: '名刺入れ', type: 'コミュ力', amount: 18, icon: '💬', effect: 'コミュ力 +18' },
            { rarity: 2, name: 'ボーナス前金', type: 'シャチ', amount: 100, icon: '💰', effect: 'シャチ +100' },
            { rarity: 2, name: '栄養スムージー', type: '体力', amount: 26, icon: '🥤', effect: '体力 +26' },
            { rarity: 2, name: 'オンライン講座クーポン', type: '知識', amount: 28, icon: '💻', effect: '知識 +28' },
            { rarity: 2, name: 'ストレスケアブック', type: 'ストレス耐性', amount: 24, icon: '📖', effect: 'ストレス耐性 +24' },
            { rarity: 2, name: 'チームランチ券', type: 'コミュ力', amount: 25, icon: '🍱', effect: 'コミュ力 +25' },
            // レア度3（★★★☆☆）
            { rarity: 3, name: 'プレミアム紅茶セット', type: 'ストレス耐性', amount: 30, icon: '😤', effect: 'ストレス耐性 +30' },
            { rarity: 3, name: '専門書3冊セット', type: '知識', amount: 35, icon: '🧠', effect: '知識 +35' },
            { rarity: 3, name: 'ジムの回数券', type: '体力', amount: 32, icon: '💪', effect: '体力 +32' },
            { rarity: 3, name: 'コミュニケーション講座', type: 'コミュ力', amount: 30, icon: '💬', effect: 'コミュ力 +30' },
            { rarity: 3, name: 'リフレッシュ休暇チケット', type: 'ストレス耐性', amount: 38, icon: '🌴', effect: 'ストレス耐性 +38' },
            { rarity: 3, name: '語学研修サポート', type: '知識', amount: 40, icon: '🗣️', effect: '知識 +40' },
            { rarity: 3, name: 'パーソナルトレーナー体験', type: '体力', amount: 40, icon: '🏋️', effect: '体力 +40' },
            { rarity: 3, name: '社外交流イベント招待', type: 'コミュ力', amount: 38, icon: '🤝', effect: 'コミュ力 +38' },
            // レア度4（★★★★☆）
            { rarity: 4, name: '高級エナジードリンク', type: 'ストレス耐性', amount: 45, icon: '😤', effect: 'ストレス耐性 +45' },
            { rarity: 4, name: 'オンラインセミナー受講', type: '知識', amount: 50, icon: '🧠', effect: '知識 +50' },
            { rarity: 4, name: 'フィットネスグッズ', type: '体力', amount: 52, icon: '💪', effect: '体力 +52' },
            { rarity: 4, name: '社員旅行参加権', type: 'コミュ力', amount: 48, icon: '✈️', effect: 'コミュ力 +48' },
            { rarity: 4, name: 'プロコーチ面談', type: 'コミュ力', amount: 55, icon: '🧑‍💼', effect: 'コミュ力 +55' },
            { rarity: 4, name: 'ビジネススクール短期講座', type: '知識', amount: 60, icon: '🏫', effect: '知識 +60' },
            { rarity: 4, name: 'ウェアラブルデバイス', type: '体力', amount: 58, icon: '⌚', effect: '体力 +58' },
            { rarity: 4, name: 'メンタルケア年間パス', type: 'ストレス耐性', amount: 60, icon: '🧠', effect: 'ストレス耐性 +60' },
            { rarity: 4, name: '臨時ボーナス', type: 'シャチ', amount: 220, icon: '💰', effect: 'シャチ +220' },
            // レア度5（★★★★★）
            { rarity: 5, name: '最高級ストレス解消セット', type: 'ストレス耐性', amount: 70, icon: '😤', effect: 'ストレス耐性 +70' },
            { rarity: 5, name: 'エキスパート証明書', type: '知識', amount: 75, icon: '📜', effect: '知識 +75' },
            { rarity: 5, name: 'プレミアムジム会員', type: '体力', amount: 80, icon: '🏅', effect: '体力 +80' },
            { rarity: 5, name: 'マネジメント研修修了証', type: 'コミュ力', amount: 78, icon: '📣', effect: 'コミュ力 +78' },
            { rarity: 5, name: '特別賞与', type: 'シャチ', amount: 350, icon: '💎', effect: 'シャチ +350' },
            { rarity: 5, name: 'エリート海外研修', type: '知識', amount: 90, icon: '🌍', effect: '知識 +90' },
            { rarity: 5, name: 'エグゼクティブコーチング', type: 'コミュ力', amount: 90, icon: '🎤', effect: 'コミュ力 +90' },
            { rarity: 5, name: '究極フィットネス合宿', type: '体力', amount: 95, icon: '🏔️', effect: '体力 +95' },
            { rarity: 5, name: 'メンタルマスタープログラム', type: 'ストレス耐性', amount: 90, icon: '🧘‍♂️', effect: 'ストレス耐性 +90' },
            { rarity: 5, name: '年間パーフェクトボーナス', type: 'シャチ', amount: 500, icon: '💼', effect: 'シャチ +500' },
            // レア度5（勇者カード）
            { rarity: 5, name: '勇者カード01', type: 'カード', cardId: 'hero_01', image: '12_カード/10_勇者シリーズ/01_勇者.png', effect: '勇者カード01を獲得' },
            { rarity: 5, name: '勇者カード02', type: 'カード', cardId: 'hero_02', image: '12_カード/10_勇者シリーズ/02_勇者.png', effect: '勇者カード02を獲得' },
            { rarity: 5, name: '勇者カード03', type: 'カード', cardId: 'hero_03', image: '12_カード/10_勇者シリーズ/03_勇者.png', effect: '勇者カード03を獲得' },
            { rarity: 5, name: '勇者カード04', type: 'カード', cardId: 'hero_04', image: '12_カード/10_勇者シリーズ/04_勇者.png', effect: '勇者カード04を獲得' },
            { rarity: 5, name: '勇者カード05', type: 'カード', cardId: 'hero_05', image: '12_カード/10_勇者シリーズ/05_勇者.png', effect: '勇者カード05を獲得' },
            { rarity: 5, name: '勇者カード06', type: 'カード', cardId: 'hero_06', image: '12_カード/10_勇者シリーズ/06_勇者.png', effect: '勇者カード06を獲得' },
            { rarity: 5, name: '勇者カード07', type: 'カード', cardId: 'hero_07', image: '12_カード/10_勇者シリーズ/07_勇者.png', effect: '勇者カード07を獲得' },
            { rarity: 5, name: '勇者カード08', type: 'カード', cardId: 'hero_08', image: '12_カード/10_勇者シリーズ/08_勇者.png', effect: '勇者カード08を獲得' },
            { rarity: 5, name: '勇者カード09', type: 'カード', cardId: 'hero_09', image: '12_カード/10_勇者シリーズ/09_勇者.png', effect: '勇者カード09を獲得' },
            { rarity: 5, name: '勇者カード10', type: 'カード', cardId: 'hero_10', image: '12_カード/10_勇者シリーズ/10_勇者.png', effect: '勇者カード10を獲得' },
            { rarity: 5, name: '勇者カード11', type: 'カード', cardId: 'hero_11', image: '12_カード/10_勇者シリーズ/11_勇者.png', effect: '勇者カード11を獲得' },
            { rarity: 5, name: '勇者カード12', type: 'カード', cardId: 'hero_12', image: '12_カード/10_勇者シリーズ/12_勇者.png', effect: '勇者カード12を獲得' },
            { rarity: 5, name: '勇者カード13', type: 'カード', cardId: 'hero_13', image: '12_カード/10_勇者シリーズ/13_勇者.png', effect: '勇者カード13を獲得' },
            { rarity: 5, name: '勇者カード14', type: 'カード', cardId: 'hero_14', image: '12_カード/10_勇者シリーズ/14_勇者.png', effect: '勇者カード14を獲得' },
            { rarity: 5, name: '勇者カード15', type: 'カード', cardId: 'hero_15', image: '12_カード/10_勇者シリーズ/15_勇者.png', effect: '勇者カード15を獲得' },
            { rarity: 5, name: '勇者カード16', type: 'カード', cardId: 'hero_16', image: '12_カード/10_勇者シリーズ/16_勇者.png', effect: '勇者カード16を獲得' },
            // レア度5（フィギュアシリーズ - レアカード）
            { rarity: 5, name: 'フィギュアカード01', type: 'カード', cardId: 'figure_01', image: '12_カード/11_フィギュアシリーズ/01_フィギュア.png', effect: 'フィギュアカード01を獲得' },
            { rarity: 5, name: 'フィギュアカード02', type: 'カード', cardId: 'figure_02', image: '12_カード/11_フィギュアシリーズ/02_フィギュア.png', effect: 'フィギュアカード02を獲得' },
            { rarity: 5, name: 'フィギュアカード03', type: 'カード', cardId: 'figure_03', image: '12_カード/11_フィギュアシリーズ/03_フィギュア.png', effect: 'フィギュアカード03を獲得' },
            { rarity: 5, name: 'フィギュアカード04', type: 'カード', cardId: 'figure_04', image: '12_カード/11_フィギュアシリーズ/04_フィギュア.png', effect: 'フィギュアカード04を獲得' },
            { rarity: 5, name: 'フィギュアカード05', type: 'カード', cardId: 'figure_05', image: '12_カード/11_フィギュアシリーズ/05_フィギュア.png', effect: 'フィギュアカード05を獲得' },
            { rarity: 5, name: 'フィギュアカード06', type: 'カード', cardId: 'figure_06', image: '12_カード/11_フィギュアシリーズ/06_フィギュア.png', effect: 'フィギュアカード06を獲得' },
            { rarity: 5, name: 'フィギュアカード07', type: 'カード', cardId: 'figure_07', image: '12_カード/11_フィギュアシリーズ/07_フィギュア.png', effect: 'フィギュアカード07を獲得' },
            { rarity: 5, name: 'フィギュアカード08', type: 'カード', cardId: 'figure_08', image: '12_カード/11_フィギュアシリーズ/08_フィギュア.png', effect: 'フィギュアカード08を獲得' },
            { rarity: 5, name: 'フィギュアカード09', type: 'カード', cardId: 'figure_09', image: '12_カード/11_フィギュアシリーズ/09_フィギュア.png', effect: 'フィギュアカード09を獲得' },
            { rarity: 5, name: 'フィギュアカード10', type: 'カード', cardId: 'figure_10', image: '12_カード/11_フィギュアシリーズ/10_フィギュア.png', effect: 'フィギュアカード10を獲得' },
            { rarity: 5, name: 'フィギュアカード11', type: 'カード', cardId: 'figure_11', image: '12_カード/11_フィギュアシリーズ/11_フィギュア.png', effect: 'フィギュアカード11を獲得' },
            { rarity: 5, name: 'フィギュアカード12', type: 'カード', cardId: 'figure_12', image: '12_カード/11_フィギュアシリーズ/12_フィギュア.png', effect: 'フィギュアカード12を獲得' },
            { rarity: 5, name: 'フィギュアカード13', type: 'カード', cardId: 'figure_13', image: '12_カード/11_フィギュアシリーズ/13_フィギュア.png', effect: 'フィギュアカード13を獲得' },
            { rarity: 5, name: 'フィギュアカード14', type: 'カード', cardId: 'figure_14', image: '12_カード/11_フィギュアシリーズ/14_フィギュア.png', effect: 'フィギュアカード14を獲得' },
            { rarity: 5, name: 'フィギュアカード15', type: 'カード', cardId: 'figure_15', image: '12_カード/11_フィギュアシリーズ/15_フィギュア.png', effect: 'フィギュアカード15を獲得' },
            { rarity: 5, name: 'フィギュアカード16', type: 'カード', cardId: 'figure_16', image: '12_カード/11_フィギュアシリーズ/16_フィギュア.png', effect: 'フィギュアカード16を獲得' },
        ];

        const RARE_CARD_LIBRARY = GACHA_REWARDS.filter(r => r.type === 'カード').map(card => ({
            id: card.cardId,
            name: card.name,
            image: card.image,
            effect: card.effect,
            type: 'カード'
        }));
        const RARE_CARD_TOTAL = RARE_CARD_LIBRARY.length;
        const RARE_DIRECT_RATE = 0.20; // ガチャ1回あたりのレアカード直当たり率

        function getRareCardById(cardId) {
            return RARE_CARD_LIBRARY.find(card => card.id === cardId);
        }

        function getRareById(id) {
            return getRareCardById(id);
        }

        // レア度に基づいてランダムに報酬を選択
        function selectRandomGachaReward() {
            // レアアイテム判定（17%の確率）
            if (Math.random() < GAME_CONFIG.RARE_ITEM_DROP_RATE) {
                const randomItem = RARE_ITEMS[Math.floor(Math.random() * RARE_ITEMS.length)];
                console.log('ガチャ結果: レアアイテム', randomItem.name);
                return {
                    type: 'レアアイテム',
                    itemId: randomItem.id,
                    name: randomItem.name,
                    icon: randomItem.icon,
                    rarity: randomItem.rarity
                };
            }

            // レアカード直当たり判定（約5回に1回の期待値）
            if (Math.random() < RARE_DIRECT_RATE) {
                const rareRewards = GACHA_REWARDS.filter(r => r.type === 'カード');
                if (rareRewards.length) {
                    const directRare = rareRewards[Math.floor(Math.random() * rareRewards.length)];
                    console.log('ガチャ結果: 直当たりレアカード', directRare.name);
                    return directRare;
                }
            }

            // レア度の確率（より高ランクが少し出やすくなるよう調整）
            const rarityWeights = [
                { rarity: 1, weight: 35 },  // 35%
                { rarity: 2, weight: 30 },  // 30%
                { rarity: 3, weight: 20 },  // 20%
                { rarity: 4, weight: 10 },  // 10%
                { rarity: 5, weight: 5 }    // 5%
            ];
            
            // 重み付きランダムでレア度を決定
            const totalWeight = rarityWeights.reduce((sum, item) => sum + item.weight, 0);
            let random = Math.random() * totalWeight;
            let selectedRarity = 1; // デフォルト値（念のため）
            
            // 累積重みで判定（正しいアルゴリズム）
            let cumulativeWeight = 0;
            for (const item of rarityWeights) {
                cumulativeWeight += item.weight;
                if (random < cumulativeWeight) {
                    selectedRarity = item.rarity;
                    break;
                }
            }
            
            // 選択されたレア度の報酬をフィルタ
            let rewardsOfRarity = [];
            if (selectedRarity === 5) {
                // ★5の場合はカード以外を優先的に除外
                rewardsOfRarity = GACHA_REWARDS.filter(r => r.rarity === selectedRarity && r.type !== 'カード');
                if (rewardsOfRarity.length === 0) {
                    rewardsOfRarity = GACHA_REWARDS.filter(r => r.rarity === selectedRarity);
                }
            } else {
                rewardsOfRarity = GACHA_REWARDS.filter(r => r.rarity === selectedRarity && r.type !== 'カード');
                if (rewardsOfRarity.length === 0) {
                    rewardsOfRarity = GACHA_REWARDS.filter(r => r.rarity === selectedRarity);
                }
            }
            
            // そのレア度の中からランダムに選択
            if (rewardsOfRarity.length === 0) {
                console.error('レアリティ', selectedRarity, 'の報酬が見つかりません');
                // フォールバック: レアリティ1を返す
                const fallbackRewards = GACHA_REWARDS.filter(r => r.rarity === 1);
                return fallbackRewards[Math.floor(Math.random() * fallbackRewards.length)];
            }
            
            const selectedReward = rewardsOfRarity[Math.floor(Math.random() * rewardsOfRarity.length)];
            console.log('ガチャ結果: レアリティ', selectedRarity, selectedReward.name);
            return selectedReward;
        }

        function addRareCard(cardId) {
            if (!cardId) return;
            if (!Array.isArray(gameState.rareItems)) {
                gameState.rareItems = [];
            }
            const alreadyOwned = gameState.rareItems.includes(cardId);
            if (!alreadyOwned) {
                gameState.rareItems.push(cardId);
                const card = getRareCardById(cardId);
                const cardName = card ? card.name : 'カード';
                console.log('カード追加:', cardId, '現在の所持数:', gameState.rareItems.length, '全カード:', gameState.rareItems);
                showToast(`${cardName}を入手しました！`, 'success');
                // 即座に保存を実行
                autoSave().then(() => {
                    console.log('レアカード保存完了:', gameState.rareItems);
                }).catch(err => {
                    console.error('レアカード保存エラー:', err);
                });
            } else {
                adjustShachi(50);
                showToast('既に所持していたため50シャチを受け取りました', 'info');
            }
            renderRareItems();
        }

        // ランダムなガチャ動画を再生
        function playRandomGachaVideo(reward) {
            // 動画ファイルのリスト
            const videoFiles = [
                '20_movie/10_ガチャ/Gacha01.mp4',
                '20_movie/10_ガチャ/Gacha02.mp4',
                '20_movie/10_ガチャ/Gcha03.mp4'
            ];
            
            // ランダムに動画を選択
            const randomVideo = videoFiles[Math.floor(Math.random() * videoFiles.length)];
            
            // 動画再生用のオーバーレイとビデオ要素を作成
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.9)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10001';
            
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.alignItems = 'center';
            
            const video = document.createElement('video');
            video.src = randomVideo;
            video.style.width = '90vw';
            video.style.maxWidth = '800px';
            video.style.height = 'auto';
            video.style.borderRadius = '10px';
            video.controls = false;
            video.autoplay = true;
            video.muted = false;
            video.playsInline = true;
            
            const skipButton = document.createElement('button');
            skipButton.textContent = 'スキップ';
            skipButton.style.cssText = `
                margin-top: 16px;
                padding: 10px 20px;
                border-radius: 999px;
                border: none;
                background: rgba(255,255,255,0.9);
                color: #333;
                font-weight: 600;
                cursor: pointer;
            `;
            
            const closeOverlay = () => {
                video.pause();
                overlay.remove();
            };
            
            const finishVideo = () => {
                document.removeEventListener('keydown', escHandler);
                closeOverlay();
                showGachaRewardPopup(reward);
                showToast(`${reward.icon} ${reward.name}を獲得！`, 'success');
            };
            
            // 動画終了時に報酬ポップアップを表示
            video.addEventListener('ended', finishVideo);
            
            // エラー処理
            video.addEventListener('error', () => {
                console.error('動画の読み込みエラー');
                finishVideo();
            });
            
            skipButton.addEventListener('click', finishVideo);
            
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    finishVideo();
                }
            };
            document.addEventListener('keydown', escHandler);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    finishVideo();
                }
            });
            
            container.appendChild(video);
            container.appendChild(skipButton);
            overlay.appendChild(container);
            document.body.appendChild(overlay);
            
            // 動画を再生
            video.play().catch(error => {
                console.error('動画の再生エラー:', error);
                finishVideo();
            });
        }

        // ガチャ報酬ポップアップ表示
        function showGachaRewardPopup(reward) {
            // レア度に応じた星の表示
            const stars = '★'.repeat(reward.rarity) + '☆'.repeat(5 - reward.rarity);
            
            // レア度に応じた背景色とテキスト色
            const rarityColors = {
                1: { bg: '#F5F5F5', text: '#757575', border: '#E0E0E0' }, // グレー
                2: { bg: '#E8F5E9', text: '#2E7D32', border: '#4CAF50' }, // 緑
                3: { bg: '#E3F2FD', text: '#1565C0', border: '#2196F3' }, // 青
                4: { bg: '#F3E5F5', text: '#6A1B9A', border: '#9C27B0' }, // 紫
                5: { bg: '#FFF3E0', text: '#E65100', border: '#FF9800' }  // オレンジ/ゴールド
            };
            const colors = rarityColors[reward.rarity] || rarityColors[1];
            
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.7)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10000';
            overlay.style.animation = 'fadeIn 0.3s ease';
            
            const modal = document.createElement('div');
            modal.style.background = colors.bg;
            modal.style.border = `3px solid ${colors.border}`;
            modal.style.borderRadius = '20px';
            modal.style.padding = '40px 30px';
            modal.style.width = '95%';
            modal.style.maxWidth = reward.type === 'レアアイテム' || reward.type === 'カード' ? '600px' : '450px';
            modal.style.textAlign = 'center';
            modal.style.boxShadow = '0 15px 40px rgba(0,0,0,0.4)';
            modal.style.animation = 'scaleIn 0.3s ease';
            
            let itemPreview = '';
            let modalContent = '';
            
            if (reward.type === 'レアアイテム') {
                // レアアイテムの場合：画面全体に大きな画像を表示
                itemPreview = `<div class="rare-item-preview"><img src="${reward.icon}" alt="${reward.name}" style="width: 80vw; height: 60vh; max-width: 500px; max-height: 400px; object-fit: contain; margin: 20px 0;"></div>`;
                modalContent = `
                    <h3 style="font-size: 1.6rem; margin: 0 0 30px; color: #333; font-weight: bold;">
                        ${reward.name}
                    </h3>
                    ${itemPreview}
                    <button id="gacha-reward-ok" class="btn-primary" style="padding: 12px 30px; border: none; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; background: #FF1744; color: white;">
                        OK
                    </button>
                `;
            } else {
                // 通常のガチャ報酬の場合：従来のレイアウト
                if (reward.type === 'カード') {
                    itemPreview = `<div class="rare-card-preview"><img src="${reward.image}" alt="${reward.name}" style="width: 80vw; height: 60vh; max-width: 400px; max-height: 300px; object-fit: contain; margin: 20px 0;"></div>`;
                }
                
                const effectText = reward.effect || `${reward.type} +${reward.amount}`;
                
                modalContent = `
                    <div style="font-size: 4rem; margin-bottom: 20px; animation: bounce 0.6s ease;">
                        ${reward.icon}
                    </div>
                    <div style="font-size: 1.8rem; font-weight: bold; color: ${colors.text}; margin-bottom: 15px; letter-spacing: 3px;">
                        レア度：${stars}
                    </div>
                    <h3 style="font-size: 1.4rem; margin: 0 0 20px; color: #333; font-weight: bold;">
                        ${reward.name}
                    </h3>
                    <div style="font-size: 1.2rem; font-weight: bold; color: ${colors.text}; margin-bottom: 25px; padding: 10px; background: rgba(255,255,255,0.6); border-radius: 8px;">
                        ${effectText}
                    </div>
                    ${itemPreview}
                    <button id="gacha-reward-ok" class="btn-primary" style="padding: 12px 30px; border: none; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; background: #FF1744; color: white;">
                        OK
                    </button>
                `;
            }
            
            modal.innerHTML = modalContent;
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            const okBtn = modal.querySelector('#gacha-reward-ok');
            okBtn.addEventListener('click', () => {
                overlay.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => {
                    overlay.remove();
                }, 300);
            });
            
            // オーバーレイクリックで閉じる
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.style.animation = 'fadeOut 0.3s ease';
                    setTimeout(() => {
                        overlay.remove();
                    }, 300);
                }
            });
        }
        
        async function purchaseItem(itemId) {
            const item = SHOP_ITEMS.find(i => i.id === itemId);
            if (!item || gameState.shachi < item.cost) {
                if (!item) {
                    showToast('アイテムが見つかりません', 'error');
                } else if (gameState.shachi < item.cost) {
                    showToast('シャチが不足しています', 'warning');
                }
                return;
            }
            
            console.log('アイテム購入処理開始:', item);
            
            // ステータス変化を記録（購入前）
            const statChanges = {};
            
            // ステータス効果を適用
            Object.keys(item.effect).forEach(stat => {
                if (gameState.stats[stat] !== undefined) {
                    const oldValue = gameState.stats[stat];
                    gameState.stats[stat] = Math.max(0, Math.min(GAME_CONFIG.STAT_CAP, 
                        gameState.stats[stat] + item.effect[stat]));
                    statChanges[stat] = gameState.stats[stat] - oldValue;
                }
            });
            
            // シャチを消費（0以下にならないよう保護）
            adjustShachi(-item.cost);
            gameState.purchasedItems.push(itemId);
            gameState.totalShachiSpent = (gameState.totalShachiSpent || 0) + item.cost;
            gameState.totalItemsPurchased = (gameState.totalItemsPurchased || 0) + 1;
            
            // シャチ履歴を記録
            recordShachiHistory(-item.cost, 'item_purchase', `アイテム購入: ${item.name}`);
            
            // データベースに購入履歴を保存
            await savePurchaseToDatabase(itemId, item.name, item.cost, item.effect, statChanges);
            
            // 統計情報を更新
            await updateGameStatsInDatabase();
            
            // アチーブメントをチェック
            await checkBadges();
            
            // 詳細な購入成功ダイアログを表示
            showPurchaseSuccessDialog(item, statChanges);
            
            renderShop();
            updateMainScreen();
            autoSave();
            
            console.log('アイテム購入処理完了');
        }
        
        // 編成システム
        function renderFormation() {
            renderPartySlots();
            renderOwnedCharacters();
            renderPurchasableCharacters();
        }
        
        function renderPartySlots() {
            const container = document.getElementById('party-slots');
            container.innerHTML = '';
            
            for (let i = 0; i < 4; i++) {
                const slot = document.createElement('div');
                slot.className = 'party-slot';
                slot.innerHTML = `
                    <div class="slot-content">
                        ${gameState.party[i] ? `
                            <img src="10_社畜アイコン/${gameState.party[i].icon}" alt="${gameState.party[i].name}" loading="lazy">
                            <span>${gameState.party[i].name}</span>
                            <button onclick="removeFromParty(${i})">×</button>
                        ` : '<span>空きスロット</span>'}
                    </div>
                `;
                container.appendChild(slot);
            }
        }
        
        function renderOwnedCharacters() {
            const container = document.getElementById('owned-characters');
            container.innerHTML = '';
            
            gameState.ownedCharacters.forEach(character => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `
                    <img src="10_社畜アイコン/${character.icon}" alt="${character.name}" loading="lazy"
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                    <div style="width: 80px; height: 80px; background: #ddd; border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 32px; color: #666;">
                        ${character.name.charAt(0)}
                    </div>
                    <span>${character.name}</span>
                    <div class="character-card-buttons">
                        <button onclick="showCharacterDetails('${character.id}')" class="btn-detail">詳細</button>
                        <button onclick="addToParty('${character.id}')" class="btn-add">編成</button>
                    </div>
                `;
                container.appendChild(card);
            });
        }
        
        function renderPurchasableCharacters() {
            const container = document.getElementById('purchasable-characters');
            container.innerHTML = '';
            
            const purchasable = CHARACTERS.filter(char => 
                !gameState.ownedCharacters.some(owned => owned.id === char.id)
            );
            
            purchasable.forEach(character => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `
                    <img src="10_社畜アイコン/${character.icon}" alt="${character.name}" loading="lazy">
                    <span>${character.name}</span>
                    <div class="character-cost">${GAME_CONFIG.CHARACTER_COST}シャチ</div>
                    <button class="btn-primary" onclick="purchaseCharacter('${character.id}')" 
                            ${gameState.shachi < GAME_CONFIG.CHARACTER_COST ? 'disabled' : ''}>
                        ${gameState.shachi < GAME_CONFIG.CHARACTER_COST ? 'シャチ不足' : '購入'}
                    </button>
                `;
                container.appendChild(card);
            });
        }
        
        async function addToParty(characterId) {
            if (gameState.party.length >= 4) {
                showToast('パーティーは最大4人までです', 'error');
                return;
            }
            
            const character = gameState.ownedCharacters.find(c => c.id === characterId);
            if (character) {
                gameState.party.push(character);
                
                // データベースにパーティー編成を保存
                await savePartyToDatabase();
                
                renderFormation();
                autoSave();
            }
        }
        
        async function removeFromParty(slotIndex) {
            gameState.party.splice(slotIndex, 1);
            
            // データベースにパーティー編成を保存
            await savePartyToDatabase();
            
            renderFormation();
            autoSave();
        }
        
        // 社畜を解放するセクションの描画
        function renderLiberationCharacters() {
            const container = document.getElementById('liberation-characters');
            if (!container) return;
            
            container.innerHTML = '';
            
            // 全てのキャラクターを表示（順番はCHARACTERSの順を維持）
            CHARACTERS.forEach(character => {
                // 所有済みかどうかをチェック
                const isOwned = gameState.ownedCharacters.some(owned => {
                    if (typeof owned === 'object' && owned !== null) {
                        return owned.id === character.id;
                    }
                    return owned === character.id;
                });
                
                const card = document.createElement('div');
                // 解放済みかどうかでスタイルを分岐
                if (isOwned) {
                    card.style.cssText = `
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        padding: 15px;
                        background: #e0e0e0;
                        border-radius: 15px;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                        opacity: 0.6;
                    `;
                } else {
                    card.style.cssText = `
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        padding: 15px;
                        background: white;
                        border-radius: 15px;
                        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
                        transition: all 0.3s;
                        cursor: pointer;
                    `;
                    card.onmouseover = function() {
                        this.style.transform = 'translateY(-5px)';
                        this.style.boxShadow = '0 8px 16px rgba(0,0,0,0.2)';
                    };
                    card.onmouseout = function() {
                        this.style.transform = 'translateY(0)';
                        this.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
                    };
                }
                
                const img = document.createElement('img');
                img.src = `10_社畜アイコン/${character.icon}`;
                img.alt = character.name;
                img.style.cssText = 'width: 80px; height: 80px; object-fit: contain; border-radius: 10px; margin-bottom: 10px;';
                img.onerror = function() {
                    const fallback = document.createElement('div');
                    fallback.style.cssText = 'width:80px;height:80px;display:flex;align-items:center;justify-content:center;font-size:24px;color:#666;border-radius:10px;background:#f0f0f0;margin:0 auto 10px;';
                    fallback.textContent = character.name.charAt(0);
                    this.parentNode.replaceChild(fallback, this);
                };
                
                // 解放済みかどうかでHTMLを分岐
                if (isOwned) {
                    card.innerHTML = `
                        <div style="font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; text-align: center; color: #666;">${character.name}</div>
                        <div style="color: #999; font-weight: bold; font-size: 0.85rem; margin-bottom: 10px; padding: 5px 10px; background: #999; color: white; border-radius: 5px;">解放済</div>
                    `;
                } else {
                    card.innerHTML = `
                        <div style="font-weight: bold; font-size: 0.9rem; margin-bottom: 5px; text-align: center;">${character.name}</div>
                        <div style="color: #ff6b00; font-weight: bold; font-size: 0.85rem; margin-bottom: 10px;">500シャチ</div>
                        <button onclick="purchaseLiberationCharacter('${character.id}')" 
                                style="width: 100%; padding: 8px; background: linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%); color: white; border: none; border-radius: 8px; font-size: 0.9rem; font-weight: bold; cursor: pointer; transition: all 0.3s;"
                                onmouseover="this.style.background='linear-gradient(135deg, #ff85ab 0%, #ffb3cb 100%)'"
                                onmouseout="this.style.background='linear-gradient(135deg, #ff9ebb 0%, #ffc3d8 100%)'"
                                ${gameState.shachi < 500 ? 'disabled' : ''}>
                            ${gameState.shachi < 500 ? 'シャチ不足' : '解放する'}
                        </button>
                    `;
                }
                card.insertBefore(img, card.firstChild);
                
                container.appendChild(card);
            });
            
            // グリッドレイアウトのスタイルを設定（スマホは2列）
            container.style.cssText = `
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 20px;
                padding: 20px;
            `;
            
            // スマホ（画面幅768px以下）の場合は2列に固定
            const mediaQuery = window.matchMedia('(max-width: 768px)');
            const updateGridColumns = () => {
                if (mediaQuery.matches) {
                    container.style.gridTemplateColumns = 'repeat(2, 1fr)';
                } else {
                    container.style.gridTemplateColumns = 'repeat(auto-fill, minmax(150px, 1fr))';
                }
            };
            updateGridColumns();
            mediaQuery.addEventListener('change', updateGridColumns);
        }
        
        // 社畜を解放する（キャラクター購入）
        async function purchaseLiberationCharacter(characterId) {
            const cost = 500;
            if (gameState.shachi < cost) {
                showToast('シャチが不足しています', 'warning');
                return;
            }
            
            const character = CHARACTERS.find(c => c.id === characterId);
            if (character) {
                // シャチを消費（0以下にならないよう保護）
                adjustShachi(-cost);
                gameState.ownedCharacters.push(character);
                ensureCharacterState(character);
                
                // キャラクター獲得時に30_キャラクター紹介の動画を解放
                unlockCharacterIntroMovie(characterId);
                
                gameState.totalShachiSpent = (gameState.totalShachiSpent || 0) + cost;
                gameState.totalCharactersOwned = (gameState.totalCharactersOwned || 0) + 1;
                
                // シャチ履歴を記録
                recordShachiHistory(-cost, 'character_purchase', `キャラクター解放: ${character.name}`);
                
                // データベースにキャラクター所有情報を保存
                await saveCharacterToDatabase(character);
                
                // 統計情報を更新
                await updateGameStatsInDatabase();
                
                showToast(`${character.name}を解放しました！`, 'success');
                
                // ショップ画面を更新
                renderShop();
                updateMainScreen();
                autoSave();
            }
        }
        
        // シャチ履歴を記録
        function recordShachiHistory(amount, type, description) {
            if (!gameState.shachiHistory) {
                gameState.shachiHistory = [];
            }
            const timestamp = new Date().toISOString();
            gameState.shachiHistory.unshift({
                timestamp,
                amount,
                type,
                description
            });
            // 最新100件のみ保持
            if (gameState.shachiHistory.length > 100) {
                gameState.shachiHistory = gameState.shachiHistory.slice(0, 100);
            }
        }
        
        // シャチ履歴を表示
        function renderShachiHistory() {
            const container = document.getElementById('shachi-history-list');
            if (!container) return;
            
            if (!gameState.shachiHistory || gameState.shachiHistory.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">履歴がありません</p>';
                return;
            }
            
            container.innerHTML = gameState.shachiHistory.map(entry => {
                const date = new Date(entry.timestamp);
                const dateStr = `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                const sign = entry.amount >= 0 ? '+' : '';
                const color = entry.amount >= 0 ? '#4CAF50' : '#F44336';
                
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 10px; background: white; border-radius: 8px; border-left: 4px solid ${color};">
                        <div>
                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${entry.description}</div>
                            <div style="font-size: 0.85rem; color: #666;">${dateStr}</div>
                        </div>
                        <div style="font-weight: 700; font-size: 1.1rem; color: ${color};">
                            ${sign}${entry.amount.toLocaleString()}シャチ
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function renderRareItems() {
            const owned = Array.isArray(gameState?.rareItems) ? gameState.rareItems : [];
            const countEl = document.querySelector('.rare-items-count');
            if (countEl) {
                countEl.textContent = `${owned.length}/${RARE_CARD_TOTAL}`;
            }
        }

        function openCardFolder() {
            const ownedIds = Array.isArray(gameState?.rareItems) ? [...gameState.rareItems] : [];
            const ownedRares = ownedIds.map(id => getRareById(id)).filter(Boolean);

            // 勇者カードとフィギュアカードを分離（01~16の全16種類を生成）
            const heroCardMap = {};
            const figureCardMap = {};
            
            // 所持しているカードをマップに格納
            ownedRares.forEach(card => {
                if (card.id.startsWith('hero_')) {
                    heroCardMap[card.id] = card;
                } else if (card.id.startsWith('figure_')) {
                    figureCardMap[card.id] = card;
                }
            });
            
            // 01~16の全カードリストを生成（所持していないものはnull）
            const allHeroCards = [];
            const allFigureCards = [];
            
            for (let i = 1; i <= 16; i++) {
                const heroId = `hero_${String(i).padStart(2, '0')}`;
                const figureId = `figure_${String(i).padStart(2, '0')}`;
                allHeroCards.push(heroCardMap[heroId] || null);
                allFigureCards.push(figureCardMap[figureId] || null);
            }

            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10005;
                padding: 20px;
            `;

            const modal = document.createElement('div');
            modal.style.cssText = `
                width: min(95vw, 600px);
                max-height: 90vh;
                background: linear-gradient(135deg, #fff6fb, #f6ffff);
                border-radius: 28px;
                padding: 24px;
                box-shadow: 0 25px 60px rgba(0,0,0,0.35);
                position: relative;
                overflow-y: auto;
            `;

            const close = () => {
                overlay.remove();
                document.removeEventListener('keydown', keyHandler);
            };

            const keyHandler = (event) => {
                if (event.key === 'Escape') {
                    close();
                }
            };

            document.addEventListener('keydown', keyHandler);

            const hasCards = ownedRares.length > 0;
            modal.innerHTML = `
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
                    <div style="font-size:1.2rem;font-weight:800;color:#c5509a;letter-spacing:0.08em;">カードファイル</div>
                    <button style="background:none;border:none;font-size:1.5rem;color:#888;cursor:pointer;">×</button>
                </div>
                <div style="display:flex;flex-direction:column;gap:20px;">
                    <div>
                        <div style="font-size:1rem;font-weight:700;color:#8b4a9f;margin-bottom:12px;padding-bottom:8px;border-bottom:2px solid rgba(139,74,159,0.3);">勇者カード</div>
                        <div class="card-folder-grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:12px;">
                            ${allHeroCards.map((card, idx) => {
                                if (card) {
                                    return `
                                        <div class="card-item" data-card-index="${idx}" data-card-type="hero" data-card-id="${card.id}" style="position:relative;cursor:pointer;border-radius:12px;overflow:hidden;box-shadow:0 4px 12px rgba(0,0,0,0.15);transition:transform 0.2s;">
                                            <img src="${card.image}" alt="${card.name}" style="width:100%;height:auto;display:block;">
                                        </div>
                                    `;
                                } else {
                                    return `
                                        <div class="card-item-empty" style="position:relative;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.1);background:linear-gradient(135deg,#f5f5f5,#e0e0e0);display:flex;align-items:center;justify-content:center;min-height:140px;border:2px dashed #ccc;">
                                            <div style="text-align:center;color:#999;font-size:0.85rem;font-weight:600;">No Image</div>
                                        </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                    </div>
                    <div>
                        <div style="font-size:1rem;font-weight:700;color:#8b4a9f;margin-bottom:12px;padding-bottom:8px;border-bottom:2px solid rgba(139,74,159,0.3);">フィギュアカード</div>
                        <div class="card-folder-grid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:12px;">
                            ${allFigureCards.map((card, idx) => {
                                if (card) {
                                    return `
                                        <div class="card-item" data-card-index="${idx}" data-card-type="figure" data-card-id="${card.id}" style="position:relative;cursor:pointer;border-radius:12px;overflow:hidden;box-shadow:0 4px 12px rgba(0,0,0,0.15);transition:transform 0.2s;">
                                            <img src="${card.image}" alt="${card.name}" style="width:100%;height:auto;display:block;">
                                        </div>
                                    `;
                                } else {
                                    return `
                                        <div class="card-item-empty" style="position:relative;border-radius:12px;overflow:hidden;box-shadow:0 2px 8px rgba(0,0,0,0.1);background:linear-gradient(135deg,#f5f5f5,#e0e0e0);display:flex;align-items:center;justify-content:center;min-height:140px;border:2px dashed #ccc;">
                                            <div style="text-align:center;color:#999;font-size:0.85rem;font-weight:600;">No Image</div>
                                        </div>
                                    `;
                                }
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;

            const closeBtn = modal.querySelector('button');
            closeBtn.addEventListener('click', close);
            overlay.addEventListener('click', (event) => {
                if (event.target === overlay) close();
            });

            overlay.appendChild(modal);
            document.body.appendChild(overlay);

            // カードをタッチで大きく表示（所持しているカードのみ）
            const cardItems = modal.querySelectorAll('.card-item');
            cardItems.forEach(item => {
                item.addEventListener('click', () => {
                    const cardType = item.dataset.cardType;
                    const cardIndex = parseInt(item.dataset.cardIndex);
                    const targetCards = cardType === 'hero' ? allHeroCards : allFigureCards;
                    const card = targetCards[cardIndex];
                    
                    if (!card) return;

                    // 拡大表示用のオーバーレイ
                    const zoomOverlay = document.createElement('div');
                    zoomOverlay.style.cssText = `
                        position: fixed;
                        inset: 0;
                        background: rgba(0,0,0,0.95);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10006;
                        padding: 20px;
                        touch-action: pan-y;
                    `;

                    const zoomContainer = document.createElement('div');
                    zoomContainer.style.cssText = `
                        position: relative;
                        max-width: 90vw;
                        max-height: 90vh;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 16px;
                        width: 100%;
                    `;

                    const zoomImage = document.createElement('img');
                    zoomImage.src = card.image;
                    zoomImage.alt = card.name;
                    zoomImage.style.cssText = `
                        width: auto;
                        height: auto;
                        max-width: 100%;
                        max-height: 70vh;
                        border-radius: 16px;
                        box-shadow: 0 20px 40px rgba(0,0,0,0.5);
                        user-select: none;
                        -webkit-user-drag: none;
                    `;

                    const zoomName = document.createElement('div');
                    zoomName.textContent = card.name;
                    zoomName.style.cssText = `
                        color: #fff;
                        font-size: 1.3rem;
                        font-weight: 700;
                        text-align: center;
                    `;

                    // 左右の矢印ボタン
                    const prevButton = document.createElement('button');
                    prevButton.setAttribute('aria-label', '前のカード');
                    prevButton.style.cssText = `
                        position: absolute;
                        left: 0;
                        top: 10%;
                        bottom: 10%;
                        width: 25%;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        z-index: 10;
                        opacity: 0;
                    `;

                    const nextButton = document.createElement('button');
                    nextButton.setAttribute('aria-label', '次のカード');
                    nextButton.style.cssText = `
                        position: absolute;
                        right: 0;
                        top: 10%;
                        bottom: 10%;
                        width: 25%;
                        background: transparent;
                        border: none;
                        cursor: pointer;
                        z-index: 10;
                        opacity: 0;
                    `;

                    let currentZoomIndex = cardIndex;
                    const updateZoomCard = () => {
                        const currentCard = targetCards[currentZoomIndex];
                        if (currentCard) {
                            zoomImage.src = currentCard.image;
                            zoomImage.alt = currentCard.name;
                            zoomName.textContent = currentCard.name;
                            // 矢印の表示/非表示
                            prevButton.style.display = currentZoomIndex > 0 && targetCards.slice(0, currentZoomIndex).some(c => c !== null) ? 'flex' : 'none';
                            nextButton.style.display = currentZoomIndex < targetCards.length - 1 && targetCards.slice(currentZoomIndex + 1).some(c => c !== null) ? 'flex' : 'none';
                        }
                    };

                    prevButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // 前の所持しているカードを探す
                        for (let i = currentZoomIndex - 1; i >= 0; i--) {
                            if (targetCards[i]) {
                                currentZoomIndex = i;
                                updateZoomCard();
                                break;
                            }
                        }
                    });

                    nextButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        // 次の所持しているカードを探す
                        for (let i = currentZoomIndex + 1; i < targetCards.length; i++) {
                            if (targetCards[i]) {
                                currentZoomIndex = i;
                                updateZoomCard();
                                break;
                            }
                        }
                    });

                    // スワイプ機能
                    let touchStartX = 0;
                    let touchEndX = 0;
                    zoomImage.addEventListener('touchstart', (e) => {
                        touchStartX = e.changedTouches[0].screenX;
                    });
                    zoomImage.addEventListener('touchend', (e) => {
                        touchEndX = e.changedTouches[0].screenX;
                        handleSwipe();
                    });

                    const handleSwipe = () => {
                        const swipeThreshold = 50;
                        const diff = touchStartX - touchEndX;
                        if (Math.abs(diff) > swipeThreshold) {
                            if (diff > 0) {
                                // 左スワイプ（次のカード）
                                nextButton.click();
                            } else {
                                // 右スワイプ（前のカード）
                                prevButton.click();
                            }
                        }
                    };

                    updateZoomCard();

                    const closeZoom = () => {
                        zoomOverlay.remove();
                    };

                    zoomOverlay.addEventListener('click', (e) => {
                        if (e.target === zoomOverlay) closeZoom();
                    });
                    document.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            closeZoom();
                        } else if (e.key === 'ArrowLeft') {
                            prevButton.click();
                        } else if (e.key === 'ArrowRight') {
                            nextButton.click();
                        }
                    });

                    zoomContainer.appendChild(prevButton);
                    zoomContainer.appendChild(zoomImage);
                    zoomContainer.appendChild(nextButton);
                    zoomContainer.appendChild(zoomName);
                    zoomOverlay.appendChild(zoomContainer);
                    document.body.appendChild(zoomOverlay);
                });

                // ホバー効果
                item.addEventListener('mouseenter', () => {
                    item.style.transform = 'scale(1.05)';
                });
                item.addEventListener('mouseleave', () => {
                    item.style.transform = 'scale(1)';
                });
            });
        }
        
        function buildRankListHtml() {
            const unlockedRank = getCurrentCharacterRankProgress();
            const statsEligibleRank = getStatsEligibleRank();
            const currentRankValue = Math.min(unlockedRank, statsEligibleRank);
            return RANK_SYSTEM.map(rank => {
                const isCurrentRank = rank.rank === currentRankValue;
                const bossEvent = rank.rank > 0 ? BOSS_EVENTS.find(b => b.requiredRank === rank.rank) : null;
                const isCompleted = rank.rank === 0 || rank.rank <= unlockedRank;
                const meetsStats = 
                    gameState.stats.stress >= rank.requiredStats.stress &&
                    gameState.stats.knowledge >= rank.requiredStats.knowledge &&
                    gameState.stats.physical >= rank.requiredStats.physical &&
                    gameState.stats.communication >= rank.requiredStats.communication;
                
                let statusText = '';
                let statusColor = '';
                if (isCurrentRank) {
                    statusText = '現在の役職';
                    statusColor = '#4CAF50';
                } else if (rank.rank < currentRankValue) {
                    statusText = '達成済み';
                    statusColor = '#9E9E9E';
                } else if (rank.rank <= unlockedRank && !meetsStats) {
                    statusText = '要ステータス調整';
                    statusColor = '#F57C00';
                } else if (rank.rank === unlockedRank + 1) {
                    statusText = meetsStats ? 'ボスイベント挑戦可能' : 'ステータス不足';
                    statusColor = meetsStats ? '#FF9800' : '#F44336';
                } else if (!meetsStats) {
                    statusText = 'ステータス不足';
                    statusColor = '#F44336';
                } else {
                    statusText = '未到達';
                    statusColor = '#757575';
                }
                
                return `
                    <div style="padding: 15px; margin-bottom: 15px; background: ${isCurrentRank ? '#E8F5E9' : 'white'}; border-radius: 10px; border-left: 5px solid ${statusColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h3 style="margin: 0; font-size: 1.2rem; color: #333;">${rank.name}</h3>
                            <span style="padding: 5px 10px; background: ${statusColor}; color: white; border-radius: 5px; font-size: 0.85rem; font-weight: 600;">${statusText}</span>
                        </div>
                        <div style="font-size: 0.9rem; color: #666; margin-bottom: 8px;">
                            <div>ストレス耐性: ${rank.requiredStats.stress} / ${gameState.stats.stress} ${gameState.stats.stress >= rank.requiredStats.stress ? '✅' : '❌'}</div>
                            <div>知識: ${rank.requiredStats.knowledge} / ${gameState.stats.knowledge} ${gameState.stats.knowledge >= rank.requiredStats.knowledge ? '✅' : '❌'}</div>
                            <div>体力: ${rank.requiredStats.physical} / ${gameState.stats.physical} ${gameState.stats.physical >= rank.requiredStats.physical ? '✅' : '❌'}</div>
                            <div>コミュ力: ${rank.requiredStats.communication} / ${gameState.stats.communication} ${gameState.stats.communication >= rank.requiredStats.communication ? '✅' : '❌'}</div>
                        </div>
                        ${rank.rank > 0 ? `
                            <div style="font-size: 0.85rem; color: #999; margin-top: 8px;">
                                ボスイベント: ${bossEvent ? bossEvent.title : '未設定'}
                                ${rank.rank <= unlockedRank ? ' ✅クリア済み' : ' ❌未クリア'}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // 役職一覧を表示
        function renderRankList() {
            const container = document.getElementById('rank-list-content');
            if (!container) return;
            container.innerHTML = buildRankListHtml();
        }

        function showRankListPopup() {
            const existingPopup = document.getElementById('rank-list-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            const overlay = document.createElement('div');
            overlay.id = 'rank-list-popup';
            overlay.style.position = 'fixed';
            overlay.style.inset = '0';
            overlay.style.background = 'rgba(0,0,0,0.7)';
            overlay.style.display = 'flex';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '10050';
            overlay.style.padding = '20px';

            const popup = document.createElement('div');
            popup.style.width = '100%';
            popup.style.maxWidth = '640px';
            popup.style.maxHeight = '90vh';
            popup.style.overflowY = 'auto';
            popup.style.background = '#fff';
            popup.style.borderRadius = '16px';
            popup.style.boxShadow = '0 20px 60px rgba(0,0,0,0.25)';
            popup.style.padding = '24px';
            popup.style.position = 'relative';

            popup.innerHTML = `
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
                    <h2 style="margin:0;font-size:1.4rem;color:#333;">役職一覧</h2>
                    <button id="rank-list-popup-close" aria-label="閉じる" style="background:none;border:none;font-size:1.5rem;cursor:pointer;color:#666;">×</button>
                </div>
                <div>${buildRankListHtml()}</div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closePopup();
                }
            };

            const closePopup = () => {
                document.removeEventListener('keydown', escHandler);
                overlay.remove();
            };

            popup.querySelector('#rank-list-popup-close')?.addEventListener('click', closePopup);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closePopup();
                }
            });
            document.addEventListener('keydown', escHandler);
        }
        
        async function purchaseCharacter(characterId) {
            if (gameState.shachi < GAME_CONFIG.CHARACTER_COST) {
                showToast('シャチが不足しています', 'warning');
                return;
            }
            
            const character = CHARACTERS.find(c => c.id === characterId);
            if (character) {
                console.log('キャラクター購入処理開始:', character);
                
                // シャチを消費（0以下にならないよう保護）
                adjustShachi(-GAME_CONFIG.CHARACTER_COST);
                gameState.ownedCharacters.push(character);
                ensureCharacterState(character);
                gameState.totalShachiSpent = (gameState.totalShachiSpent || 0) + GAME_CONFIG.CHARACTER_COST;
                gameState.totalCharactersOwned = (gameState.totalCharactersOwned || 0) + 1;
                
                // データベースにキャラクター所有情報を保存
                await saveCharacterToDatabase(character);
                
                // 統計情報を更新
                await updateGameStatsInDatabase();
                
                showToast(`${character.name}を購入しました！`, 'success');
                renderFormation();
                updateMainScreen();
                autoSave();
                
                console.log('キャラクター購入処理完了');
            }
        }
        
        // 設定システム
        function saveGame() {
            if (saveGameData()) {
                showToast('ゲームをセーブしました！', 'success');
            } else {
                showToast('セーブに失敗しました', 'error');
            }
        }
        
        function loadGame() {
            loadGameData();
            updateMainScreen();
            updateGameStats();
            showToast('ゲームをロードしました！', 'success');
        }
        function resetGame() {
            if (confirm('本当にゲームをリセットしますか？\nすべてのデータが削除され、最初からやり直しになります。')) {
                // ローカルストレージをクリア
                removeLocalSaveData({ removeLegacy: true });
                
                // Supabaseのデータも削除（認証済みの場合）
                if (isAuthenticated && supabase) {
                    deleteSupabaseData();
                }
                
                // ゲーム状態をリセット
                resetGameState();
                
                // キャラクター選択画面に戻る
                showScreen('character-selection');
                showToast('ゲームをリセットしました！', 'success');
            }
        }
        
        // Supabaseのデータを削除
        async function deleteSupabaseData() {
            if (!isAuthenticated || !supabase || !currentUser) {
                return;
            }
            
            try {
                // game_savesテーブルからデータを削除
                const { error } = await supabase
                    .from('game_saves')
                    .delete()
                    .eq('user_id', currentUser.id)
                    .eq('game_name', 'shachipoke2');
                
                if (error) {
                    console.error('Supabaseデータ削除エラー:', error);
                } else {
                    console.log('Supabaseデータを削除しました');
                }
            } catch (error) {
                console.error('Supabaseデータ削除エラー:', error);
            }
        }
        
        function updateGameStats() {
            document.getElementById('total-days').textContent = gameState.totalDaysPlayed;
            document.getElementById('total-shachi').textContent = gameState.totalShachiEarned;
            document.getElementById('total-events').textContent = gameState.totalEventsCompleted;
            document.getElementById('owned-count').textContent = gameState.ownedCharacters.length;
        }
        
        
        // 初期化
        // 認証関連関数
        async function checkAuthStatus() {
            // 認証必須のため、ローカルモードでも認証チェックを実行
            if (!supabase) {
                console.log('Supabaseクライアントが利用できません');
                isAuthenticated = false;
                currentUser = null;
                return false;
            }
            
            try {
                const { data: { session }, error } = await supabase.auth.getSession();
                if (error) {
                    console.error('認証状態確認エラー:', error);
                    isAuthenticated = false;
                    currentUser = null;
                    return false;
                }
                
                if (session) {
                    currentUser = session.user;
                    isAuthenticated = true;
                    console.log('認証済みユーザー:', currentUser.email);
                    
                    // プロフィールを自動作成
                    await ensureUserProfile(currentUser);
                    
                    return true;
                } else {
                    currentUser = null;
                    isAuthenticated = false;
                    console.log('未認証状態');
                    return false;
                }
            } catch (error) {
                console.error('認証状態確認エラー:', error);
                isAuthenticated = false;
                currentUser = null;
                return false;
            }
        }
        
        async function signOut() {
            if (useLocalMode || !supabase) {
                console.log('ローカルモードまたはSupabase接続なしのため、ログアウトをスキップ');
                showToast('現在はローカルモードで動作しています', 'info');
                return;
            }
            
            try {
                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('ログアウトエラー:', error);
                    showToast('ログアウトに失敗しました', 'error');
                } else {
                    // 認証状態をリセット
                    currentUser = null;
                    isAuthenticated = false;
                    
                    // ローカルデータを完全削除（ユーザー別＋旧キー）
                    removeLocalSaveData({ removeLegacy: true });
                    removeHabitLocalData({ removeLegacy: true });
                    habitTrackerData = {};
                    
                    // ゲーム状態をリセット
                    resetGameState();
                    
                    console.log('ログアウト完了');
                    showToast('ログアウトしました', 'success');
                    
                    // ログイン必須画面に遷移
                    showScreen('login-required');
                    
                    // 認証状態をUIに反映
                    updateAuthStatus();
                }
            } catch (error) {
                console.error('ログアウトエラー:', error);
                showToast('ログアウトに失敗しました', 'error');
            }
        }
        
        // Supabaseにゲームデータを保存
        async function saveGameDataToSupabase() {
            if (!isAuthenticated || !currentUser) {
                console.log('未認証状態のためSupabase保存をスキップ');
                return false;
            }
            
            try {
                const { data, error } = await supabase
                    .from('game_saves')
                    .upsert({
                        user_id: currentUser.id,
                        game_name: 'shachipoke2',
                        save_data: gameState,
                        version: '1.0.0',
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id,game_name'
                    });
                
                if (error) {
                    console.error('Supabase保存エラー:', error);
                    showToast('クラウド保存に失敗しました', 'error');
                    return false;
                }
                
                console.log('Supabase保存成功:', data);
                showToast('クラウドに保存しました', 'success');
                return true;
            } catch (error) {
                console.error('Supabase保存エラー:', error);
                showToast('クラウド保存に失敗しました', 'error');
                return false;
            }
        }
        
        // イベント履歴をデータベースに保存
        async function saveEventToDatabase(eventId, eventType, choiceIndex, rewards, statChanges, feedback) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                console.log('ローカルモードまたは未認証状態のため、イベント履歴保存をスキップ');
                return;
            }
            
            try {
                console.log('イベント履歴を保存開始:', { eventId, eventType, choiceIndex, rewards, statChanges });
                
                // event_historyテーブルに保存
                const { error } = await supabase
                    .from('event_history')
                    .insert({
                        user_id: currentUser.id,
                        event_id: eventId,
                        event_type: eventType,
                        choice_made: choiceIndex,
                        rewards: rewards,
                        stats_change: statChanges,
                        shachi_earned: rewards.shachi || 0
                    });
                
                if (error) {
                    console.error('イベント履歴保存エラー:', error);
                } else {
                    console.log('イベント履歴保存成功');
                }
            } catch (error) {
                console.error('イベント履歴保存エラー:', error);
            }
        }
        
        // ゲーム統計情報をデータベースに更新
        async function updateGameStatsInDatabase() {
            if (useLocalMode || !supabase || !isAuthenticated) {
                console.log('ローカルモードまたは未認証状態のため、統計更新をスキップ');
                return;
            }
            
            try {
                // user_game_statsテーブルを更新または作成
                const { error: upsertError } = await supabase
                    .from('user_game_stats')
                    .upsert({
                        user_id: currentUser.id,
                        total_events_completed: gameState.totalEventsCompleted || 0,
                        total_shachi_earned: gameState.totalShachiEarned || 0,
                        total_items_purchased: gameState.totalItemsPurchased || 0,
                        total_shachi_spent: gameState.totalShachiSpent || 0,
                        total_characters_owned: gameState.ownedCharacters.length || 0,
                        last_play_date: new Date().toISOString().split('T')[0],
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id'
                    });
                
                if (upsertError) {
                    console.error('統計更新エラー:', upsertError);
                } else {
                    console.log('統計更新成功');
                }
            } catch (error) {
                console.error('統計更新エラー:', error);
            }
        }
        
        // 購入履歴をデータベースに保存
        async function savePurchaseToDatabase(itemId, itemName, itemCost, effects, statChanges) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                console.log('ローカルモードまたは未認証状態のため、購入履歴保存をスキップ');
                return;
            }
            
            try {
                console.log('購入履歴を保存開始:', { itemId, itemName, itemCost, effects, statChanges });
                
                // purchase_historyテーブルに保存
                const { error } = await supabase
                    .from('purchase_history')
                    .insert({
                        user_id: currentUser.id,
                        item_id: itemId,
                        item_name: itemName,
                        item_cost: itemCost,
                        quantity: 1,
                        stats_effect: statChanges
                    });
                
                if (error) {
                    console.error('購入履歴保存エラー:', error);
                } else {
                    console.log('購入履歴保存成功');
                }
            } catch (error) {
                console.error('購入履歴保存エラー:', error);
            }
        }
        
        // パーティー編成をデータベースに保存
        async function savePartyToDatabase() {
            if (useLocalMode || !supabase || !isAuthenticated) {
                console.log('ローカルモードまたは未認証状態のため、パーティー編成保存をスキップ');
                return;
            }
            
            try {
                console.log('パーティー編成を保存開始');
                
                // パーティースロットをJSONB形式に変換
                const partySlots = gameState.party.map(char => ({
                    characterId: char.id,
                    name: char.name,
                    icon: char.icon
                }));
                
                // user_partiesテーブルを更新または作成
                const { error } = await supabase
                    .from('user_parties')
                    .upsert({
                        user_id: currentUser.id,
                        party_name: 'メインパーティー',
                        party_slots: partySlots,
                        is_active: true,
                        updated_at: new Date().toISOString()
                    }, {
                        onConflict: 'user_id,party_name'
                    });
                
                if (error) {
                    console.error('パーティー編成保存エラー:', error);
                } else {
                    console.log('パーティー編成保存成功');
                }
            } catch (error) {
                console.error('パーティー編成保存エラー:', error);
            }
        }
        // キャラクター所有情報をデータベースに保存
        async function saveCharacterToDatabase(character) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                console.log('ローカルモードまたは未認証状態のため、キャラクター所有情報保存をスキップ');
                return;
            }
            
            try {
                console.log('キャラクター所有情報を保存開始:', character);
                
                const state = ensureCharacterState(character);
                const nowIso = new Date().toISOString();
                // user_charactersテーブルに保存
                const { error } = await supabase
                    .from('user_characters')
                    .upsert({
                        user_id: currentUser.id,
                        character_id: character.id,
                        level: state?.level ?? 1,
                        experience: state?.experience ?? 0,
                        stats: state?.stats || createInitialStats(character),
                        last_used_at: state?.lastUsedAt || nowIso,
                        updated_at: nowIso
                    }, {
                        onConflict: 'user_id,character_id'
                    });
                
                if (error) {
                    console.error('キャラクター所有情報保存エラー:', error);
                } else {
                    console.log('キャラクター所有情報保存成功');
                }
            } catch (error) {
                console.error('キャラクター所有情報保存エラー:', error);
            }
        }
        
        // キャラクター詳細を表示
        async function showCharacterDetails(characterId) {
            const character = gameState.ownedCharacters.find(c => c.id === characterId);
            if (!character) {
                showToast('キャラクターが見つかりません', 'error');
                return;
            }
            
            console.log('キャラクター詳細表示:', character);
            const state = ensureCharacterState(character);
            const stats = state?.stats || createInitialStats(character);
            const level = state?.level ?? 1;
            
            // 購入履歴を取得（データベースから）
            const purchaseHistory = await loadPurchaseHistoryFromDatabase(characterId);
            
            // キャラクター詳細ダイアログを表示
            const dialog = document.createElement('div');
            dialog.className = 'character-details-dialog';
            dialog.innerHTML = `
                <div class="character-details-content">
                    <div class="character-details-header">
                        <div class="character-details-icon">
                            <img src="10_社畜アイコン/${character.icon}" alt="${character.name}" loading="lazy"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                            <div style="width: 120px; height: 120px; background: #ddd; border-radius: 50%; display: none; align-items: center; justify-content: center; font-size: 48px; color: #666;">
                                ${character.name.charAt(0)}
                            </div>
                        </div>
                        <div class="character-details-info">
                            <h2>${character.name}</h2>
                            <p class="character-description">${character.description || '説明なし'}</p>
                        </div>
                    </div>
                    
                    <div class="character-details-stats">
                        <h3>ステータス</h3>
                        <div class="stat-grid">
                            <div class="stat-item">
                                <span class="stat-icon">😤</span>
                                <span class="stat-label">ストレス耐性</span>
                                <span class="stat-value">${stats.stress || 0}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-icon">🧠</span>
                                <span class="stat-label">知識</span>
                                <span class="stat-value">${stats.knowledge || 0}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-icon">💪</span>
                                <span class="stat-label">体力</span>
                                <span class="stat-value">${stats.physical || 0}</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-icon">💬</span>
                                <span class="stat-label">コミュ力</span>
                                <span class="stat-value">${stats.communication || 0}</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="character-details-purchases">
                        <h3>購入したアイテム (${purchaseHistory.length}件)</h3>
                        ${purchaseHistory.length > 0 ? `
                            <div class="purchase-list">
                                ${purchaseHistory.map(purchase => `
                                    <div class="purchase-item">
                                        <span class="purchase-icon">${purchase.icon || '💊'}</span>
                                        <span class="purchase-name">${purchase.item_name}</span>
                                        <span class="purchase-date">${new Date(purchase.purchased_at).toLocaleDateString('ja-JP')}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : '<p>まだ購入したアイテムがありません</p>'}
                    </div>
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-top:16px;">
                        <div style="font-weight:600;">レベル: ${level}</div>
                        <button class="btn-primary" onclick="this.parentElement.parentElement.remove();">閉じる</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
        }
        // 購入履歴をデータベースから読み込み
        async function loadPurchaseHistoryFromDatabase(characterId) {
            if (useLocalMode || !supabase || !isAuthenticated) {
                return [];
            }
            
            try {
                // purchase_historyテーブルから該当キャラクターの購入履歴を取得
                const { data, error } = await supabase
                    .from('purchase_history')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .order('purchased_at', { ascending: false })
                    .limit(10);
                
                if (error) {
                    console.error('購入履歴読み込みエラー:', error);
                    return [];
                }
                
                // アイテムアイコンを追加
                return data.map(item => {
                    const shopItem = SHOP_ITEMS.find(i => i.id === item.item_id);
                    return {
                        ...item,
                        icon: shopItem ? shopItem.icon : '💊'
                    };
                });
            } catch (error) {
                console.error('購入履歴読み込みエラー:', error);
                return [];
            }
        }
        
        // 購入成功ダイアログを表示
        function showPurchaseSuccessDialog(item, statChanges) {
            const dialog = document.createElement('div');
            dialog.className = 'purchase-success-dialog';
            dialog.innerHTML = `
                <div class="purchase-success-content">
                    <div class="purchase-success-icon">${item.icon}</div>
                    <h2>${item.name}を購入しました！</h2>
                    <div class="stat-changes">
                        ${Object.keys(statChanges).map(stat => {
                            const statNames = { 
                                stress: 'ストレス耐性', 
                                knowledge: '知識', 
                                physical: '体力', 
                                communication: 'コミュ力' 
                            };
                            const change = statChanges[stat];
                            const icon = stat === 'stress' ? '😤' : stat === 'knowledge' ? '🧠' : stat === 'physical' ? '💪' : '💬';
                            return `
                                <div class="stat-change-item ${change > 0 ? 'positive' : 'negative'}">
                                    <span class="stat-icon">${icon}</span>
                                    <span class="stat-name">${statNames[stat]}</span>
                                    <span class="stat-change">${change > 0 ? '+' : ''}${change}</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button class="btn-primary" onclick="this.parentElement.parentElement.remove(); animateStatBars();">閉じる</button>
                </div>
            `;
            document.body.appendChild(dialog);
            
            // アニメーション
            setTimeout(() => {
                dialog.style.opacity = '1';
                dialog.style.transform = 'scale(1)';
            }, 10);
        }
        
        // ステータスバーをアニメーション
        function animateStatBars() {
            const statElements = document.querySelectorAll('.stat-bar');
            statElements.forEach(el => {
                el.style.transition = 'width 0.5s ease';
                // トリガー再描画
                const width = el.style.width;
                el.style.width = '0';
                setTimeout(() => {
                    el.style.width = width;
                }, 10);
            });
        }
        
        // Supabaseからゲームデータを読み込み
        async function loadGameDataFromSupabase() {
            if (!isAuthenticated || !currentUser) {
                console.log('未認証状態のためSupabase読み込みをスキップ');
                return null;
            }
            
            try {
                const { data, error } = await supabase
                    .from('game_saves')
                    .select('save_data, version, updated_at')
                    .eq('user_id', currentUser.id)
                    .eq('game_name', 'shachipoke2')
                    .single();
                
                if (error) {
                    if (error.code === 'PGRST116') {
                        console.log('Supabaseにセーブデータが存在しません');
                        return null;
                    }
                    console.error('Supabase読み込みエラー:', error);
                    showToast('クラウド読み込みに失敗しました', 'error');
                    return null;
                }
                
                console.log('Supabase読み込み成功:', data);
                showToast('クラウドから読み込みました', 'success');
                return data.save_data;
            } catch (error) {
                console.error('Supabase読み込みエラー:', error);
                showToast('クラウド読み込みに失敗しました', 'error');
                return null;
            }
        }
        
        // ローカルデータをSupabaseに移行
        async function migrateLocalDataToSupabase() {
            if (!isAuthenticated || !supabase || !currentUser) {
                console.log('認証されていないため、データ移行をスキップ');
                return;
            }
            
            // プロフィールを確実に作成
            await ensureUserProfile(currentUser);
            
            const { data: localData } = readLocalSaveData();
            if (!localData) {
                console.log('ローカルデータが存在しないため、移行をスキップ');
                return;
            }
            
            try {
                const parsedData = JSON.parse(localData);
                
                // まず既存のデータがあるかチェック
                const { data: existingData, error: checkError } = await supabase
                    .from('game_saves')
                    .select('id')
                    .eq('user_id', currentUser.id)
                    .eq('game_name', 'shachipoke2')
                    .single();
                
                if (checkError && checkError.code !== 'PGRST116') {
                    console.error('既存データチェックエラー:', checkError);
                    showToast('データ移行に失敗しました', 'error');
                    return;
                }
                
                if (existingData) {
                    console.log('既存のデータが存在します。移行をスキップします。');
                    return;
                }
                
                // 新規データを挿入
                const { data, error } = await supabase
                    .from('game_saves')
                    .insert({
                        user_id: currentUser.id,
                        game_name: 'shachipoke2',
                        save_data: parsedData,
                        version: '1.0.0',
                        updated_at: new Date().toISOString()
                    });
                
                if (error) {
                    console.error('データ移行エラー:', error);
                    showToast('データ移行に失敗しました', 'error');
                } else {
                    console.log('ローカルデータをSupabaseに移行しました:', data);
                    showToast('データをクラウドに移行しました', 'success');
                }
            } catch (error) {
                console.error('データ移行エラー:', error);
                showToast('データ移行に失敗しました', 'error');
            }
        }
        
        // Supabase接続テスト関数
        async function testSupabaseConnection() {
            console.log('=== Supabase接続テスト開始 ===');
            console.log('useLocalMode:', useLocalMode);
            console.log('supabase:', supabase);
            
            // ローカルモードでは接続テストをスキップ
            if (useLocalMode) {
                console.log('ローカルモードのため、接続テストをスキップ');
                return true;
            }
            
            if (!supabase) {
                console.error('Supabaseクライアントがnullです');
                return false;
            }
            
            try {
                // 基本的な接続テスト
                console.log('1. 基本的な接続テスト...');
                const { data, error } = await supabase.from('profiles').select('count').limit(1);
                
                if (error) {
                    console.error('接続テストエラー:', error);
                    return false;
                }
                
                console.log('✅ 基本的な接続テスト成功:', data);
                
                // 認証テスト
                console.log('2. 認証テスト...');
                const { data: session, error: sessionError } = await supabase.auth.getSession();
                
                if (sessionError) {
                    console.error('認証テストエラー:', sessionError);
                } else {
                    console.log('✅ 認証テスト成功:', session);
                }
                
                // RLS設定の確認はスキップ（不要な通知を避けるため）
                
                return true;
                
            } catch (error) {
                console.error('Supabase接続テストエラー:', error);
                return false;
            }
        }
        // RLS設定の確認と修正
        async function checkAndFixRLS() {
            if (useLocalMode || !supabase) {
                console.log('ローカルモードまたはSupabase接続なしのため、RLS確認をスキップ');
                showToast('ローカルモードで動作中です', 'info');
                return;
            }
            
            try {
                console.log('=== RLS設定の確認開始 ===');
                showToast('RLS設定を確認中...', 'info');
                
                // RLS状況を確認（データアクセスでテスト）
                const { data: profiles, error: profilesError } = await supabase
                    .from('profiles')
                    .select('id')
                    .limit(1);
                
                console.log('RLSチェック結果:', { profiles, profilesError });
                
                // RLSが有効な場合、認証済みユーザーは自分のデータのみアクセス可能
                // RLSが無効な場合、認証済みでないユーザーでもアクセス可能
                if (profilesError) {
                    console.log('✅ RLSが有効になっています（エラー:', profilesError.code, ')');
                    showToast('✅ RLSが有効になっています', 'success');
                } else if (isAuthenticated) {
                    // 認証済みユーザーでデータが取得できる場合、RLSは正常に機能している
                    console.log('✅ RLSが正常に機能しています');
                    showToast('✅ RLSが正常に機能しています', 'success');
                } else {
                    // 未認証でデータが取得できた場合、RLSが無効の可能性
                    console.log('❌ RLSが無効になっています（未認証でもデータアクセス可能）');
                    // ローカルモードなので通知しない
                }
                
            } catch (error) {
                console.error('RLS確認エラー:', error);
                showToast('RLS確認中にエラーが発生しました', 'error');
            }
        }
        
        // RLS設定手順を表示（ローカルモードでは非表示）
        function showRLSSetupInstructions(showDialog = false) {
            // ローカルモードでは表示しない
            if (useLocalMode) {
                return;
            }
            
            const instructions = `
RLS設定が必要です。以下の手順でSupabase SQL Editorで実行してください：

1. Supabaseダッシュボード → SQL Editor
2. enable-rls-secure.sql の内容をコピー&ペースト
3. "Run"ボタンをクリック

これにより、セキュリティが強化されます。
            `;
            
            console.log(instructions);
            
            // オプションでユーザーに通知（デフォルトではスキップ）
            if (showDialog && confirm('データベースのセキュリティ設定が必要です。\n設定手順を表示しますか？')) {
                alert(instructions);
            }
        }
        
        // ゲームデータの整合性チェック
        function validateGameData(data) {
            try {
                // 必須フィールドの存在チェック
                if (!data.selectedCharacter || typeof data.shachi !== 'number' || typeof data.level !== 'number' || !data.stats) {
                    console.error('必須フィールドが不足しています');
                    return false;
                }
                
                // シャチの値が0以上かつ合理的な範囲内かチェック
                if (data.shachi < 0 || data.shachi > 1000000) {
                    console.error('シャチの値が範囲外です:', data.shachi);
                    return false;
                }
                
                // レベルの値が1以上かつ合理的な範囲内かチェック
                if (data.level < 1 || data.level > 100) {
                    console.error('レベルの値が範囲外です:', data.level);
                    return false;
                }
                
                // ステータスの構造チェック
                const requiredStats = ['stress', 'knowledge', 'physical', 'communication'];
                for (const stat of requiredStats) {
                    if (typeof data.stats[stat] !== 'number' || data.stats[stat] < 0 || data.stats[stat] > 200) {
                        console.error(`ステータス ${stat} の値が範囲外です:`, data.stats[stat]);
                        return false;
                    }
                }
                
                // 所有キャラクターの配列チェック
                if (!Array.isArray(data.ownedCharacters)) {
                    console.error('ownedCharactersは配列である必要があります');
                    return false;
                }
                
                // 購入アイテムの配列チェック
                if (!Array.isArray(data.purchasedItems)) {
                    console.error('purchasedItemsは配列である必要があります');
                    return false;
                }
                
                // 配列の長さが合理的かチェック
                if (data.ownedCharacters.length > 20 || data.purchasedItems.length > 100) {
                    console.error('配列の長さが異常です');
                    return false;
                }
                
                console.log('✅ ゲームデータの整合性チェック成功');
                return true;
            } catch (error) {
                console.error('データ整合性チェックエラー:', error);
                return false;
            }
        }
        
        // セキュリティ監査機能
        async function performSecurityAudit() {
            if (useLocalMode || !supabase) {
                console.log('ローカルモードまたはSupabase接続なしのため、セキュリティ監査をスキップ');
                return;
            }
            
            try {
                console.log('=== セキュリティ監査開始 ===');
                
                const auditResults = {
                    rlsEnabled: false,
                    dataAccess: false,
                    authentication: false,
                    dataIntegrity: false
                };
                
                // 1. RLS有効性チェック
                console.log('1. RLS有効性チェック...');
                const { data: profiles, error: profilesError } = await supabase
                    .from('profiles')
                    .select('id')
                    .limit(1);
                
                // RLSの判定を改善: エラーハンドリングと詳細ログ
                if (profilesError) {
                    // エラーが発生した場合、RLSが有効になっている可能性が高い
                    if (profilesError.code === 'PGRST301' || profilesError.code === '42883') {
                        auditResults.rlsEnabled = true;
                        console.log('✅ RLSが有効になっています');
                    } else {
                        console.log('⚠️ 予期しないエラー:', profilesError.code, profilesError.message);
                        // RLSは有効だが、他の理由でエラー
                        auditResults.rlsEnabled = true;
                    }
                } else {
                    // エラーがなく、データが取得できた場合
                    if (isAuthenticated && currentUser && profiles && profiles.length > 0) {
                        // 認証済みでデータが取得できた = RLSは正常に機能している
                        auditResults.rlsEnabled = true;
                        console.log('✅ RLSが正常に機能しています（自分のデータにアクセス可能）');
                    } else if (!isAuthenticated) {
                        // 未認証でデータが取得できた場合、RLSが無効の可能性
                        auditResults.rlsEnabled = false;
                        console.log('❌ RLSが無効になっています（未認証でもデータアクセス可能）');
                    } else {
                        // その他のケース
                        auditResults.rlsEnabled = true;
                        console.log('✅ RLSは有効ですが、データがありません');
                    }
                }
                
                // 2. データアクセスチェック（認証済みユーザーのみ）
                if (isAuthenticated) {
                    console.log('2. データアクセステスト...');
                    const { data: userData, error: userError } = await supabase
                        .from('profiles')
                        .select('id, email')
                        .eq('id', currentUser.id)
                        .single();
                    
                    if (!userError && userData) {
                        auditResults.dataAccess = true;
                        console.log('✅ 自分のデータにアクセス可能');
                    } else {
                        console.log('❌ 自分のデータにアクセスできません');
                    }
                }
                
                // 3. 認証状態チェック
                console.log('3. 認証状態チェック...');
                const { data: { session } } = await supabase.auth.getSession();
                if (session) {
                    auditResults.authentication = true;
                    console.log('✅ 認証状態が正常');
                } else {
                    console.log('❌ 認証状態に問題があります');
                }
                
                // 4. データ整合性チェック
                console.log('4. データ整合性チェック...');
                if (validateGameData(gameState)) {
                    auditResults.dataIntegrity = true;
                    console.log('✅ ゲームデータの整合性が正常');
                } else {
                    console.log('❌ ゲームデータの整合性に問題があります');
                }
                
                // 監査結果の表示
                console.log('=== セキュリティ監査結果 ===');
                console.log('RLS有効:', auditResults.rlsEnabled ? '✅' : '❌');
                console.log('データアクセス:', auditResults.dataAccess ? '✅' : '❌');
                console.log('認証状態:', auditResults.authentication ? '✅' : '❌');
                console.log('データ整合性:', auditResults.dataIntegrity ? '✅' : '❌');
                
                // セキュリティスコアの計算
                const securityScore = Object.values(auditResults).filter(Boolean).length;
                const totalChecks = Object.keys(auditResults).length;
                const percentage = Math.round((securityScore / totalChecks) * 100);
                
                console.log(`セキュリティスコア: ${securityScore}/${totalChecks} (${percentage}%)`);
                
                if (percentage < 100) {
                    showToast(`セキュリティスコア: ${percentage}% - 改善が必要です`, 'warning');
                } else {
                    showToast(`セキュリティスコア: ${percentage}% - 良好です`, 'success');
                }
                
            } catch (error) {
                console.error('セキュリティ監査エラー:', error);
            }
        }
        
        // ユーザープロフィールを自動作成
        async function ensureUserProfile(user) {
            if (!supabase || !user) return;
            
            try {
                // 既存のプロフィールをチェック
                const { data: existingProfile, error: checkError } = await supabase
                    .from('profiles')
                    .select('id')
                    .eq('id', user.id)
                    .single();
                
                if (checkError && checkError.code !== 'PGRST116') {
                    console.error('プロフィールチェックエラー:', checkError);
                    return false;
                }
                
                if (existingProfile) {
                    console.log('プロフィールが既に存在します');
                    return true;
                }
                
                // 新しいプロフィールを作成
                const { data, error } = await supabase
                    .from('profiles')
                    .insert({
                        id: user.id,
                        email: user.email,
                        display_name: user.user_metadata?.full_name || user.email,
                        avatar_url: user.user_metadata?.avatar_url || null
                    });
                
                if (error) {
                    console.error('プロフィール作成エラー:', error);
                    return false;
                }
                
                console.log('✅ プロフィールを作成しました:', data);
                return true;
                
            } catch (error) {
                console.error('プロフィール作成エラー:', error);
                return false;
            }
        }
        
        // 認証状態表示を更新
        function updateAuthStatus() {
            const authInfo = document.getElementById('auth-info');
            const loginPrompt = document.getElementById('login-prompt');
            const userEmail = document.getElementById('user-email');
            
            // 設定画面の認証状態表示
            const settingsAuthInfo = document.getElementById('settings-auth-info');
            const settingsLoginPrompt = document.getElementById('settings-login-prompt');
            const settingsUserEmail = document.getElementById('settings-user-email');
            
            console.log('updateAuthStatus called - isAuthenticated:', isAuthenticated, 'currentUser:', currentUser);
            
            if (isAuthenticated && currentUser) {
                console.log('認証済み状態を表示');
                // キャラクター選択画面
                if (authInfo) authInfo.style.display = 'block';
                if (loginPrompt) loginPrompt.style.display = 'none';
                if (userEmail) userEmail.textContent = currentUser.email;
                
                // 設定画面
                if (settingsAuthInfo) settingsAuthInfo.style.display = 'block';
                if (settingsLoginPrompt) settingsLoginPrompt.style.display = 'none';
                if (settingsUserEmail) settingsUserEmail.textContent = currentUser.email;
            } else {
                console.log('未認証状態を表示');
                // キャラクター選択画面
                if (authInfo) authInfo.style.display = 'none';
                if (loginPrompt) loginPrompt.style.display = 'block';
                
                // 設定画面
                if (settingsAuthInfo) settingsAuthInfo.style.display = 'none';
                if (settingsLoginPrompt) settingsLoginPrompt.style.display = 'block';
            }
            
            // Supabase接続エラーがある場合のメッセージ追加
            if (!supabase || useLocalMode) {
                const errorMsg = document.createElement('p');
                errorMsg.style.color = '#f44336';
                errorMsg.style.fontSize = '12px';
                errorMsg.textContent = '※ クラウド接続に問題があります。ローカル保存のみ利用可能です。';
                if (loginPrompt && !loginPrompt.querySelector('p[style*="color: #f44336"]')) {
                    loginPrompt.appendChild(errorMsg);
                }
            }
        }
        
        // メモリリーク防止: イベントリスナーの管理
        const eventListeners = [];
        
        function addEventListenerWithCleanup(element, event, handler) {
            element.addEventListener(event, handler);
            eventListeners.push({ element, event, handler });
        }
        
        function cleanup() {
            eventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            eventListeners.length = 0;
        }
        // ゲーム初期化
        async function init() {
            console.log('ゲーム初期化開始');
            
            // 以前のリスナーをクリーンアップ
            cleanup();
            
            // ローディング画面を非表示
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) {
                loadingScreen.classList.add('hidden');
            }
            
            // 認証状態をチェック
            // ローカルモードでは認証チェックをスキップ
            // 認証状態をチェック
            await checkAuthStatus();
            
            // Supabase接続テストを実行
            await testSupabaseConnection();
            
            // 認証状態表示を更新
            updateAuthStatus();
            
            // 習慣トラッカーデータを読み込み
            loadHabitTrackerData();
            
            // ゲームデータをロード
            await loadGameData();
            
            // 日替わりチェック
            checkDailyReset();
            
            // 既に達成条件を満たしているバッチをチェック（サイレントモード）
            await checkBadges(true);
            
            // キャラクターグリッドを作成
            createCharacterGrid();
            
            // イベントリスナーを設定（クリーンアップ対応）
            const confirmBtn = document.getElementById('confirm-character');
            if (confirmBtn) {
                addEventListenerWithCleanup(confirmBtn, 'click', confirmCharacter);
            }
            
            const rankInfoButton = document.getElementById('rank-info-button');
            if (rankInfoButton) {
                addEventListenerWithCleanup(rankInfoButton, 'click', showRankListPopup);
            }
            
            const mainCharacterImage = document.getElementById('main-character-image');
            if (mainCharacterImage) {
                addEventListenerWithCleanup(mainCharacterImage, 'click', handleMainCharacterImageClick);
            }
            
            // 認証状態に応じて画面を表示（認証必須）
            if (isAuthenticated && supabase) {
                console.log('認証済みユーザーでゲーム開始');
                if (gameState.selectedCharacter) {
                    showScreen('main');
                    updateMainScreen();
                } else {
                    console.log('キャラクターが選択されていません - キャラクター選択画面へ');
                    showScreen('character-selection');
                }
            } else {
                console.log('未認証状態 - 認証が必要');
                console.log('認証状態:', { isAuthenticated, hasSupabase: !!supabase });
                showScreen('login-required');
            }
            
            console.log('ゲーム初期化完了');
        }

        // ページ遷移時のクリーンアップ
        window.addEventListener('beforeunload', function() {
            cleanup();
        });
        // キーボードナビゲーション対応
        document.addEventListener('keydown', function(e) {
            // Tabキーでナビゲーション移動
            if (e.key === 'Tab') {
                document.body.classList.add('keyboard-navigation');
            }
            
            // Escキーでフォーカスをクリア
            if (e.key === 'Escape') {
                document.activeElement.blur();
            }
            
            // Enterキーでボタンアクティベーション
            if (e.key === 'Enter' && document.activeElement.classList.contains('nav-btn')) {
                e.preventDefault();
                document.activeElement.click();
            }
        });
        
        // マウス使用時にキーボードナビゲーションクラスを削除
        document.addEventListener('mousedown', function() {
            document.body.classList.remove('keyboard-navigation');
        });
        
        // キーボードナビゲーション用のスタイル
        const style = document.createElement('style');
        style.textContent = `
            .keyboard-navigation *:focus {
                outline: 3px solid #007bff !important;
                outline-offset: 2px;
            }
            
            .keyboard-navigation button:focus,
            .keyboard-navigation .nav-btn:focus {
                transform: scale(1.05);
            }
        `;
        document.head.appendChild(style);
        
        // 認証コールバック処理
        async function handleAuthCallback() {
            if (!supabase) return;
            
            try {
                const { data, error } = await supabase.auth.getSession();
                
                if (error) {
                    console.error('セッション取得エラー:', error);
                    return;
                }
                
                if (data.session) {
                    console.log('認証成功:', data.session);
                    // URLからハッシュフラグメントをクリーンアップ
                    if (window.location.hash.includes('access_token')) {
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }
                }
            } catch (error) {
                console.error('認証コールバック処理エラー:', error);
            }
        }
        
        // オフライン検出と通知
        window.addEventListener('online', function() {
            console.log('オンライン状態に復帰');
            if (typeof showToast === 'function') {
                showToast('ネットワーク接続が回復しました', 'success');
            }
        });

        window.addEventListener('offline', function() {
            console.log('オフライン状態');
            if (typeof showToast === 'function') {
                showToast('ネットワーク接続が切れました。ローカルデータでプレイします。', 'warning');
            }
        });

        // グローバルエラーハンドラー
        window.addEventListener('error', function(e) {
            console.error('グローバルエラー:', e.error);
            // 致命的なエラーの場合のみ通知
            if (e.error && e.error.message && !useLocalMode) {
                // ユーザーには見せず、コンソールに記録
            }
        });

        // Promise rejection ハンドラー
        window.addEventListener('unhandledrejection', function(e) {
            console.error('未処理のPromise rejection:', e.reason);
            // Supabase関連のエラーは無視（ローカルモードに自動フォールバック）
            if (e.reason && typeof e.reason === 'string' && e.reason.includes('Supabase')) {
                console.log('Supabaseエラーを無視します（ローカルモードに自動切替）');
                return;
            }
        });
        
        // ページ読み込み時に初期化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM読み込み完了');
            
            // 認証コールバックを処理
            handleAuthCallback();
            
            try {
                init();
            } catch (error) {
                console.error('初期化エラー:', error);
                document.body.innerHTML = `
                    <div style="padding: 20px; text-align: center; background: white; margin: 20px; border-radius: 10px;">
                        <h1>初期化エラー</h1>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">再読み込み</button>
                    </div>
                `;
            }
        });
    </script>
    
    <!-- グローバルナビゲーション（すべての画面で共通） -->
    <div class="main-navigation" id="global-navigation">
        <button class="nav-btn" onclick="showScreen('main')">
            <span class="nav-icon">
                <img src="30_差し込み画像/01_Top/Top_01-removebg-preview.png" alt="ホーム">
            </span>
            <span>ホーム</span>
        </button>
        <button class="nav-btn" onclick="showScreen('events')">
            <span class="nav-icon">
                <img src="30_差し込み画像/01_Top/Top_02-removebg-preview.png" alt="イベント">
            </span>
            <span>イベント</span>
        </button>
        <button class="nav-btn" onclick="showScreen('shop')">
            <span class="nav-icon">
                <img src="30_差し込み画像/01_Top/Top_03-removebg-preview.png" alt="ショップ">
            </span>
            <span>ショップ</span>
        </button>
        <button class="nav-btn" onclick="showScreen('habits')">
            <span class="nav-icon">
                <img src="30_差し込み画像/01_Top/Top_04-removebg-preview.png" alt="習慣">
            </span>
            <span>習慣</span>
        </button>
        <button class="nav-btn" onclick="showScreen('settings')">
            <span class="nav-icon">
                <img src="30_差し込み画像/01_Top/Top_05-removebg-preview.png" alt="設定">
            </span>
            <span>設定</span>
        </button>
    </div>
</body>
</html>